./components/AddProductButton.tsx
==== ./components/AddProductButton.tsx ====
import React from 'react';
import { TouchableOpacity, Text, StyleSheet } from 'react-native';

interface AddProductButtonProps {
  onPress: () => void;
  isLandscape: boolean;
}

const AddProductButton: React.FC<AddProductButtonProps> = ({ 
  onPress, 
  isLandscape 
}) => {
  return (
    <TouchableOpacity
      style={[
        styles.button,
        isLandscape && styles.buttonLandscape
      ]}
      onPress={onPress}
      activeOpacity={0.8}
    >
      <Text style={styles.buttonIcon}>+</Text>
      <Text style={styles.buttonText}>Add New Product</Text>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  button: {
    backgroundColor: '#2e7d32',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16,
    paddingHorizontal: 24,
    borderRadius: 12,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  buttonLandscape: {
    paddingHorizontal: 32,
  },
  buttonIcon: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#ffffff',
    marginRight: 8,
  },
  buttonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#ffffff',
  },
});

export default AddProductButton;./components/AppLoading.tsx
==== ./components/AppLoading.tsx ====
import React from 'react';
import { View, Text, StatusBar } from 'react-native';
import ErrorBoundary from './ErrorBoundary';

/**
 * Loading component untuk initial app startup
 */
const AppLoading: React.FC = () => {
  return (
    <ErrorBoundary>
      <StatusBar backgroundColor="#2e7d32" barStyle="light-content" />
      <View style={{
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#f8f9fa'
      }}>
        <Text style={{
          fontSize: 16,
          color: '#666',
          marginTop: 16
        }}>
          Initializing App...
        </Text>
      </View>
    </ErrorBoundary>
  );
};

export default AppLoading;./components/AuthGuardWrapper.tsx
==== ./components/AuthGuardWrapper.tsx ====
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { useNavigation } from '@react-navigation/native';

interface AuthGuardWrapperProps {
  isAuthenticated: boolean;
  children: React.ReactNode;
}

const AuthGuardWrapper: React.FC<AuthGuardWrapperProps> = ({ 
  isAuthenticated, 
  children 
}) => {
  const navigation = useNavigation();

  const handleLoginRedirect = () => {
    navigation.navigate('Profile' as never);
  };

  if (!isAuthenticated) {
    return (
      <View style={styles.container}>
        <Text style={styles.title}>üîí Authentication Required</Text>
        <Text style={styles.message}>
          Please log in to access this content. You need to be authenticated to view protected resources.
        </Text>
        <TouchableOpacity 
          style={styles.loginButton}
          onPress={handleLoginRedirect}
        >
          <Text style={styles.loginButtonText}>Go to Login</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return <>{children}</>;
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
    backgroundColor: '#f8f9fa',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 16,
    textAlign: 'center',
  },
  message: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 30,
    lineHeight: 22,
  },
  loginButton: {
    backgroundColor: '#2e7d32',
    paddingHorizontal: 32,
    paddingVertical: 12,
    borderRadius: 8,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
  },
  loginButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default AuthGuardWrapper;./components/BasicKeyChain.tsx
==== ./components/BasicKeyChain.tsx ====
import React from 'react';
import { Alert, Button, Text, View } from 'react-native';
import * as keychain from 'react-native-keychain';



export default function BasicKeychain() {


    const [token, setToken] = React.useState('')


    const saveToken = async () => {
        try {
            const result = await keychain.setGenericPassword('token', 'app-user-token',{ service: '@app:auth'})
            if (result) Alert.alert('Success', 'Token saved')
            } catch (error: any) {
            Alert.alert('Error', error.message)
        }
    }

    const loadToken = async () => {
        try {
            const credential = await keychain.getGenericPassword({ service: '@app:auth' })
            if (credential) {
                setToken(credential.password)
                Alert.alert('Success', 'Token loaded')
            } else {
                Alert.alert('Error', 'No token found')
            }
        } catch (error: any) {
            Alert.alert('Error', error.message)
        }
    }

    const removeToken = async () => {
        try {
            const result = await keychain.resetGenericPassword({ service: '@app:auth' })
            if (result) {
                setToken('')
                Alert.alert('Success', 'Token removed')
            }
        } catch (error : any) {
            Alert.alert('Error', error.message)
        }
    }


    return (
        <>
            <View>
                <Text>BasicKeychain</Text>
                <Text>Token: {token ? token : 'None'}</Text>
                <Button title='Save Token' onPress={saveToken} />
                <Button title='load Token' onPress={loadToken} /> 
                <Button title='remove Token' onPress={removeToken} /> 

            </View>
        </>
    )
}./components/CustomDrawerContent.tsx
==== ./components/CustomDrawerContent.tsx ====
import React, { useContext } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
} from 'react-native';
import {
  DrawerContentComponentProps,
  DrawerContentScrollView,
  DrawerItem,
} from '@react-navigation/drawer';
import { CommonActions } from '@react-navigation/native';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';
import { AuthContext } from '../context/AuthContext';

const CustomDrawerContent: React.FC<DrawerContentComponentProps> = (props) => {
  const { navigation } = props;
  const { isAuthenticated, user, logout } = useContext(AuthContext);

  const handleLogout = () => {
    logout();
    navigation.closeDrawer();
  };

  const handleLogin = () => {
    navigation.dispatch(
      CommonActions.navigate({
        name: 'Login',
      })
    );
    navigation.closeDrawer();
  };

  const handleCategories = () => {
    if (!isAuthenticated) {
      handleLogin();
      return;
    }
    navigation.dispatch(
      CommonActions.navigate({
        name: 'CategoriesWithBottomTabs',
      })
    );
    navigation.closeDrawer();
  };

  const handleProfile = () => {
    if (!isAuthenticated) {
      handleLogin();
      return;
    }
    navigation.dispatch(
      CommonActions.navigate({
        name: 'CategoriesWithBottomTabs',
      })
    );
    setTimeout(() => {
      navigation.navigate('Profile');
    }, 100);
    navigation.closeDrawer();
  };

  return (
    <View style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <View style={styles.avatar}>
          {isAuthenticated && user ? (
            <Text style={styles.avatarText}>
              {user.name.split(' ').map(n => n[0]).join('')}
            </Text>
          ) : (
            <FontAwesome6 name="user" size={24} color="#ffffff" iconStyle='solid' />
          )}
        </View>
        <Text style={styles.userName}>
          {isAuthenticated && user ? user.name : 'Welcome Guest'}
        </Text>
        <Text style={styles.userEmail}>
          {isAuthenticated && user ? user.email : 'Please login to continue'}
        </Text>
        <Text style={styles.storeName}>Eco Shop</Text>
        {isAuthenticated && (
          <TouchableOpacity style={styles.profileButton} onPress={handleProfile}>
            <Text style={styles.profileButtonText}>View Profile</Text>
          </TouchableOpacity>
        )}
      </View>

      <DrawerContentScrollView 
        {...props}
        style={styles.drawerScroll}
        contentContainerStyle={styles.drawerContent}
      >
        {/* Main Navigation Items */}
        <View style={styles.section}>
          <DrawerItem
            label="Home"
            onPress={() => navigation.navigate('Home')}
            labelStyle={styles.drawerLabel}
            icon={({ color, size }) => (
              <FontAwesome6 name="house" size={size} color={color} iconStyle='solid' />
            )}
          />
          <DrawerItem
            label="Categories"
            onPress={handleCategories}
            labelStyle={styles.drawerLabel}
            icon={({ color, size }) => (
              <FontAwesome6 name="cube" size={size} color={color} iconStyle='solid' />
            )}
          />
            <DrawerItem
              label="Analytics"
              onPress={() => navigation.navigate('Analytics')}
              labelStyle={styles.drawerLabel}
              icon={({ color, size }) => (
                <FontAwesome6 
                name="chart-line"
                size={size}
                color={color}
                iconStyle='solid' />
              )}
            />
          <DrawerItem
            label="Profile"
            onPress={handleProfile}
            labelStyle={styles.drawerLabel}
            icon={({ color, size }) => (
              <FontAwesome6 name="user" size={size} color={color} iconStyle='solid' />
            )}
          />
          <DrawerItem
            label="Settings"
            onPress={() => navigation.navigate('Settings')}
            labelStyle={styles.drawerLabel}
            icon={({ color, size }) => (
              <FontAwesome6 name="gear" size={size} color={color} iconStyle='solid' />
            )}
          />
        </View>
      </DrawerContentScrollView>

      {/* Footer */}
      <View style={styles.footer}>
        {isAuthenticated ? (
          <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
            <FontAwesome6 name="right-from-bracket" size={16} color="#ffffff" iconStyle='solid' />
            <Text style={styles.logoutText}> Logout</Text>
          </TouchableOpacity>
        ) : (
          <TouchableOpacity style={styles.loginButton} onPress={handleLogin}>
            <FontAwesome6 name="right-to-bracket" size={16} color="#ffffff" iconStyle='solid' />
            <Text style={styles.loginText}> Login</Text>
          </TouchableOpacity>
        )}
        <Text style={styles.version}>Eco Store v1.0.0</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f0f7f0',
  },
  header: {
    backgroundColor: '#2e7d32',
    padding: 20,
    paddingTop: 40,
    alignItems: 'center',
  },
  storeName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#ffffff',
    marginTop: 8,
    marginBottom: 8,
  },
  avatar: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: '#4caf50',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 12,
  },
  avatarText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#ffffff',
  },
  userName: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 4,
  },
  userEmail: {
    fontSize: 14,
    color: '#e8f5e9',
    opacity: 0.8,
    marginBottom: 12,
    textAlign: 'center',
  },
  profileButton: {
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
  },
  profileButtonText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: '500',
  },
  drawerScroll: {
    flex: 1,
  },
  drawerContent: {
    paddingTop: 10,
  },
  section: {
    marginBottom: 20,
  },
  drawerLabel: {
    fontSize: 16,
    fontWeight: '500',
    color: '#2e7d32',
    marginLeft: 10,
  },
  footer: {
    padding: 20,
    borderTopWidth: 1,
    borderTopColor: '#d4e8d4',
    backgroundColor: '#ffffff',
  },
  loginButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#2e7d32',
    padding: 12,
    borderRadius: 8,
    marginBottom: 12,
  },
  loginText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#ff5722',
    padding: 12,
    borderRadius: 8,
    marginBottom: 12,
  },
  logoutText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  version: {
    fontSize: 12,
    color: '#666',
    textAlign: 'center',
  },
});

export default CustomDrawerContent;./components/DeepLinkHandler.tsx
==== ./components/DeepLinkHandler.tsx ====
import React, { useEffect, useState, useRef, useCallback } from 'react';
import { Alert, AppState, AppStateStatus } from 'react-native';
import { useCart } from '../context/CartContext';
import { productApi } from '../services/api/productApi';
import deepLinkingHandler from '../utils/deepLinkingHandler';
import ProcessingOverlay from './ProcessingOverlay';

interface DeepLinkHandlerProps {
  children: React.ReactNode;
}

/**
 * Component untuk handle deep links dengan add-to-cart functionality
 * Memisahkan logic deep link dari main App component
 */
const DeepLinkHandler: React.FC<DeepLinkHandlerProps> = ({ children }) => {
  const { addToCart } = useCart();
  const appState = useRef(AppState.currentState);
  const [isProcessing, setIsProcessing] = useState(false);

  // ‚úÖ Setup deep link callbacks untuk add-to-cart
  const setupDeepLinkCallbacks = useCallback(() => {
    const callbacks = {
      onAddToCart: async (productId: string) => {
        if (isProcessing) {
          console.log('‚è≥ Skip add-to-cart, already processing...');
          return;
        }

        setIsProcessing(true);
        console.log(`üõí Deep link add-to-cart for product: ${productId}`);

        try {
          // Fetch product details dengan error handling
          const product = await productApi.getProductById(productId);
          
          // Add to cart
          addToCart(product);
          
          // Show success feedback
          Alert.alert(
            'Added to Cart üõí', 
            `${product.name} has been added to your cart!`,
            [
              { 
                text: 'View Cart', 
                onPress: () => {
                  console.log('Navigating to cart...');
                }
              },
              { 
                text: 'Continue Shopping', 
                style: 'cancel' 
              }
            ]
          );
          
          console.log('‚úÖ Product added to cart via deep link');
          
        } catch (error: any) {
          console.error('‚ùå Failed to add product via deep link:', error);
          
          // Error handling dengan berbagai scenario
          if (error.message?.includes('Failed to fetch') || error.message?.includes('Network')) {
            Alert.alert(
              'Network Error',
              'Please check your internet connection and try again.'
            );
          } else if (error.response?.status === 404) {
            Alert.alert(
              'Product Not Found',
              'The requested product could not be found.'
            );
          } else if (error.message?.includes('AbortError')) {
            console.log('Request was aborted');
          } else {
            Alert.alert(
              'Error',
              'Failed to add product to cart. Please try again.'
            );
          }
        } finally {
          setIsProcessing(false);
        }
      },
      
      onViewProduct: (productId: string) => {
        console.log(`üîç Deep link view-product for product: ${productId}`);
        // Navigation akan dihandle oleh deepLinkingHandler
      },
      
      onOpenCart: () => {
        console.log('üõí Deep link open-cart');
        // Navigation akan dihandle oleh deepLinkingHandler
      }
    };

    deepLinkingHandler.setCallbacks(callbacks);
    console.log('‚úÖ Deep link callbacks setup completed');
  }, [addToCart, isProcessing]);

  // ‚úÖ Setup app state monitoring untuk handle background/foreground transitions
  useEffect(() => {
    const handleAppStateChange = (nextAppState: AppStateStatus) => {
      console.log(`üîÑ App state changed: ${appState.current} ‚Üí ${nextAppState}`);
      
      if (appState.current.match(/inactive|background/) && nextAppState === 'active') {
        // App kembali ke foreground, process pending deep links
        console.log('üì± App came to foreground, checking for pending deep links...');
        setTimeout(() => {
          deepLinkingHandler.processPendingUrl();
        }, 500);
      }
      
      appState.current = nextAppState;
    };

    const subscription = AppState.addEventListener('change', handleAppStateChange);

    return () => {
      subscription.remove();
    };
  }, []);

  // ‚úÖ Setup deep link callbacks ketika component mount
  useEffect(() => {
    setupDeepLinkCallbacks();
  }, [setupDeepLinkCallbacks]);

  return (
    <>
      {children}
      <ProcessingOverlay visible={isProcessing} message="Adding to cart..." />
    </>
  );
};

export default DeepLinkHandler;./components/ErrorBoundary.tsx
==== ./components/ErrorBoundary.tsx ====
import React from 'react';
import { 
  View, Text, TouchableOpacity, StyleSheet, ScrollView, SafeAreaView, StatusBar 
} from 'react-native';

interface ErrorBoundaryProps {
  children: React.ReactNode;
  onReset?: () => void;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  private shouldBlockRender: boolean = false;
  private resetInProgress: boolean = false;

  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null
    };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    console.error('üõë ERROR BOUNDARY CAUGHT AN ERROR:');
    console.error('Error Message:', error.message);

    this.setState({ error });
    this.shouldBlockRender = true;
  }

  resetError = (): void => {
    if (this.resetInProgress) {
      console.log('‚è≥ Reset already in progress...');
      return;
    }
    
    this.resetInProgress = true;
    console.log('üîÑ Starting error boundary reset...');

    // Step 1: Reset state dulu
    this.shouldBlockRender = false;
    this.setState({
      hasError: false,
      error: null
    });

    // Step 2: Beri waktu untuk React update state, baru trigger parent reset
    setTimeout(() => {
      console.log('üéØ Triggering parent reset...');
      if (this.props.onReset) {
        this.props.onReset();
      }
      
      // Reset flag setelah semua proses selesai
      setTimeout(() => {
        this.resetInProgress = false;
        console.log('‚úÖ Reset completed');
      }, 500);
    }, 100);
  };

  render(): React.ReactNode {
    const { hasError, error } = this.state;
    const { children } = this.props;

    if (hasError) {
      console.log('üö´ BLOCKING re-render - showing fallback UI');
      return (
        <SafeAreaView style={styles.safeArea}>
          <StatusBar backgroundColor="#d32f2f" barStyle="light-content" />
          <ScrollView contentContainerStyle={styles.container}>
            <View style={styles.content}>
              <Text style={styles.emoji}>üö®</Text>
              <Text style={styles.title}>Maaf, Terjadi Gangguan</Text>
              <Text style={styles.message}>
                Aplikasi mengalami masalah tak terduga.
              </Text>
              
              <View style={styles.buttonContainer}>
                <TouchableOpacity 
                  style={styles.primaryButton}
                  onPress={this.resetError}
                  disabled={this.resetInProgress}
                >
                  <Text style={[
                    styles.primaryButtonText,
                    this.resetInProgress && styles.disabledText
                  ]}>
                    {this.resetInProgress ? 'Memuat Ulang...' : 'Mulai Ulang Aplikasi'}
                  </Text>
                </TouchableOpacity>
              </View>

              {__DEV__ && error && (
                <View style={styles.debugSection}>
                  <Text style={styles.debugTitle}>Error Details:</Text>
                  <Text style={styles.debugText}>{error.message}</Text>
                </View>
              )}
            </View>
          </ScrollView>
        </SafeAreaView>
      );
    }
    if (this.state.hasError) return null;
    return children;
  }
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#fff',
  },
  container: {
    flexGrow: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 24,
    backgroundColor: '#fff',
  },
  content: {
    width: '100%',
    maxWidth: 400,
    alignItems: 'center',
  },
  emoji: {
    fontSize: 80,
    marginBottom: 24,
  },
  title: {
    fontSize: 26,
    fontWeight: 'bold',
    color: '#d32f2f',
    marginBottom: 16,
    textAlign: 'center',
  },
  message: {
    fontSize: 18,
    color: '#424242',
    textAlign: 'center',
    marginBottom: 40,
    lineHeight: 24,
  },
  buttonContainer: {
    width: '100%',
    gap: 12,
  },
  primaryButton: {
    backgroundColor: '#2e7d32',
    paddingVertical: 16,
    paddingHorizontal: 24,
    borderRadius: 12,
    alignItems: 'center',
  },
  primaryButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  disabledText: {
    opacity: 0.6,
  },
  debugSection: {
    width: '100%',
    marginTop: 32,
    padding: 16,
    backgroundColor: '#f5f5f5',
    borderRadius: 8,
    borderLeftWidth: 4,
    borderLeftColor: '#d32f2f',
  },
  debugTitle: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#d32f2f',
    marginBottom: 8,
  },
  debugText: {
    fontSize: 12,
    color: '#424242',
    fontFamily: 'monospace',
  },
});

export default ErrorBoundary;./components/Header.tsx
==== ./components/Header.tsx ====
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { useNavigation, DrawerActions } from '@react-navigation/native';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';

interface HeaderProps {
  title: string;
  showBackButton?: boolean;
  rightComponent?: React.ReactNode;
}

const Header: React.FC<HeaderProps> = ({ 
  title, 
  showBackButton = false, 
  rightComponent 
}) => {
  const navigation = useNavigation();

  const handleBack = () => {
    navigation.goBack();
  };

  const handleMenu = () => {
    navigation.dispatch(DrawerActions.toggleDrawer());
  };

  return (
    <View style={styles.container}>
      <View style={styles.leftSection}>
        {showBackButton ? (
          <TouchableOpacity style={styles.button} onPress={handleBack}>
            <FontAwesome6 name="arrow-left" size={20} color="#ffffff" iconStyle='solid' />
          </TouchableOpacity>
        ) : (
          <TouchableOpacity style={styles.button} onPress={handleMenu}>
            <FontAwesome6 name="bars" size={20} color="#ffffff" iconStyle='solid' />
          </TouchableOpacity>
        )}
      </View>

      <View style={styles.centerSection}>
        <Text style={styles.title} numberOfLines={1}>
          {title}
        </Text>
      </View>

      <View style={styles.rightSection}>
        {rightComponent || (
          <TouchableOpacity style={styles.button}>
            <FontAwesome6 name="magnifying-glass" size={20} color="#ffffff" iconStyle='solid' />
          </TouchableOpacity>
        )}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#2e7d32',
    paddingHorizontal: 16,
    paddingVertical: 12,
    height: 60,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
  },
  leftSection: {
    flex: 1,
    alignItems: 'flex-start',
  },
  centerSection: {
    flex: 2,
    alignItems: 'center',
  },
  rightSection: {
    flex: 1,
    alignItems: 'flex-end',
  },
  button: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ffffff',
    textAlign: 'center',
  },
});

export default Header;./components/HydrantionStatus.tsx
==== ./components/HydrantionStatus.tsx ====
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

interface HydrationState {
  isHydrated: boolean;
  progress: number;
  loadedServices: string[];
  failedServices: string[];
  errors: string[];
}

interface HydrationStatusProps {
  hydrationState: HydrationState;
}

const HydrationStatus: React.FC<HydrationStatusProps> = ({ hydrationState }) => {
  const { failedServices, errors } = hydrationState;

  if (failedServices.length === 0 && errors.length === 0) {
    return null;
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Hydration Status</Text>
      
      {failedServices.length > 0 && (
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Fallback Services:</Text>
          {failedServices.map(service => (
            <Text key={service} style={styles.fallbackText}>
              ‚ö†Ô∏è {service} - Using default state
            </Text>
          ))}
        </View>
      )}
      
      {errors.length > 0 && (
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Errors:</Text>
          {errors.map((error, index) => (
            <Text key={index} style={styles.errorText}>
              ‚ùå {error}
            </Text>
          ))}
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    top: 50,
    left: 10,
    right: 10,
    backgroundColor: 'rgba(255,255,255,0.95)',
    borderRadius: 8,
    padding: 12,
    borderLeftWidth: 4,
    borderLeftColor: '#ff9800',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  title: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#ff9800',
    marginBottom: 8,
  },
  section: {
    marginBottom: 8,
  },
  sectionTitle: {
    fontSize: 12,
    fontWeight: '600',
    color: '#666',
    marginBottom: 4,
  },
  fallbackText: {
    fontSize: 11,
    color: '#ff9800',
    marginBottom: 2,
  },
  errorText: {
    fontSize: 11,
    color: '#f44336',
    marginBottom: 2,
  },
});

export default HydrationStatus;./components/HydrationManager.tsx
==== ./components/HydrationManager.tsx ====
import React, { useEffect, useState, useCallback } from 'react';
import { useAuth } from '../context/AuthContext';
import { useCart } from '../context/CartContext';
import { useWishlist } from '../context/WishListContext';
import SplashScreen from './SplashScreen';
import HydrationStatus from './HydrantionStatus';

// Services
import authService from '../services/auth/authService';
import cartService from '../services/cart/cartService';
import { wishlistService } from '../services/wishlist/wishlistService';
import { productCacheService } from '../services/product/productCacheService';

// Types
interface HydrationState {
  isHydrated: boolean;
  progress: number;
  loadedServices: string[];
  failedServices: string[];
  errors: string[];
}

interface HydrationManagerProps {
  children: React.ReactNode;
}

/**
 * Component untuk handle parallel state hydration
 * Memisahkan logic hydration dari App.tsx
 */
const HydrationManager: React.FC<HydrationManagerProps> = ({ children }) => {
  const { setUser, setToken, setIsAuthenticated } = useAuth();
  const { setCartItems, refreshCart } = useCart();
 const [wishlistItems, setWishlistItems] = useState<string[]>([]);

  
  const [hydrationState, setHydrationState] = useState<HydrationState>({
    isHydrated: false,
    progress: 0,
    loadedServices: [],
    failedServices: [],
    errors: []
  });

  // ‚úÖ PARALLEL STATE HYDRATION
  const hydrateAppState = useCallback(async (): Promise<void> => {
    console.log('üöÄ Starting app state hydration...');
    
    const totalServices = 4; // auth, cart, wishlist, cache
    let completedServices = 0;

    const updateProgress = (serviceName: string, success: boolean = true, error?: string) => {
      completedServices++;
      const progress = Math.round((completedServices / totalServices) * 100);
      
      setHydrationState(prev => ({
        ...prev,
        progress,
        loadedServices: success 
          ? [...prev.loadedServices, serviceName]
          : prev.loadedServices,
        failedServices: !success 
          ? [...prev.failedServices, serviceName]
          : prev.failedServices,
        errors: error ? [...prev.errors, error] : prev.errors
      }));

      console.log(`üì¶ ${serviceName}: ${success ? '‚úÖ' : '‚ùå'} (${progress}%)`);
    };

    try {
      // ‚úÖ PARALLEL LOADING DENGAN PROMISE.ALL
      const hydrationPromises = [
        // 1. Auth Token Hydration
        (async () => {
          try {
            const tokenData = await authService.loadToken();
            if (tokenData) {
              setToken(tokenData.token);
              setUser(tokenData.user);
              setIsAuthenticated(true);
              console.log('üîê Auth token hydrated');
            } else {
              // Clear auth state jika tidak ada token
              setToken(null);
              setUser(null);
              setIsAuthenticated(false);
            }
            updateProgress('Authentication', true);
          } catch (error) {
            console.error('‚ùå Auth hydration failed:', error);
            updateProgress('Authentication', false, 'Failed to load auth token');
            // Fallback: clear auth state
            setToken(null);
            setUser(null);
            setIsAuthenticated(false);
          }
        })(),

        // 2. Cart Data Hydration - MENGGUNAKAN CART CONTEXT YANG SUDAH ADA
        (async () => {
          try {
            // Gunakan refreshCart dari context yang sudah ada
            await refreshCart();
            console.log('üõí Cart data hydrated using context');
            updateProgress('Cart', true);
          } catch (error) {
            console.error('‚ùå Cart hydration failed:', error);
            updateProgress('Cart', false, 'Failed to load cart data');
            // Fallback: empty cart sudah dihandle oleh context
          }
        })(),

        // 3. Wishlist Data Hydration
        (async () => {
          try {
            const wishlistData = await wishlistService.loadWishlist();
            if (wishlistData && Array.isArray(wishlistData.items)) {
              setWishlistItems(wishlistData.items);
              console.log('‚ù§Ô∏è Wishlist data hydrated:', wishlistData.items.length, 'items');
            } else {
              // Fallback: empty wishlist
              setWishlistItems([]);
            }
            updateProgress('Wishlist', true);
          } catch (error) {
            console.error('‚ùå Wishlist hydration failed:', error);
            updateProgress('Wishlist', false, 'Failed to load wishlist data');
            // Fallback: empty wishlist
            setWishlistItems([]);
          }
        })(),

        // 4. Cache Metadata Hydration
        (async () => {
          try {
            const cacheMeta = await productCacheService.loadCacheMeta();
            console.log('üíæ Cache metadata hydrated:', cacheMeta);
            updateProgress('Cache', true);
          } catch (error) {
            console.error('‚ùå Cache hydration failed:', error);
            updateProgress('Cache', false, 'Failed to load cache metadata');
            // Fallback: cache akan rebuild otomatis
          }
        })()
      ];

      // ‚úÖ TUNGGU SEMUA PROMISE SELESAI
      await Promise.allSettled(hydrationPromises);

      // ‚úÖ TUNGGU SEBENTAR UNTUK SMOOTH TRANSITION
      await new Promise(resolve => setTimeout(resolve, 500));

      console.log('üéâ App state hydration completed!');
      setHydrationState(prev => ({
        ...prev,
        isHydrated: true,
        progress: 100
      }));

    } catch (error) {
      console.error('üí• Critical hydration error:', error);
      // Even if critical error, still proceed to app
      setHydrationState(prev => ({
        ...prev,
        isHydrated: true,
        errors: [...prev.errors, 'Critical hydration error']
      }));
    }
  }, [setUser, setToken, setIsAuthenticated, setCartItems, setWishlistItems, refreshCart]);

  // ‚úÖ START HYDRATION ON MOUNT
  useEffect(() => {
    hydrateAppState();
  }, [hydrateAppState]);

  // ‚úÖ TAMPILKAN SPLASH SCREEN SELAMA HYDRATION
  if (!hydrationState.isHydrated) {
    return (
      <>
        <SplashScreen 
          progress={hydrationState.progress}
          loadedServices={hydrationState.loadedServices}
          failedServices={hydrationState.failedServices}
        />
        <HydrationStatus hydrationState={hydrationState} />
      </>
    );
  }

  // ‚úÖ RENDER MAIN APP SETELAH HYDRATION SELESAI
  return (
    <>
      {children}
      {/* Show hydration errors if any */}
      {hydrationState.errors.length > 0 && (
        <HydrationStatus hydrationState={hydrationState} />
      )}
    </>
  );
};

export default HydrationManager;./components/InternetStatusHandler.tsx
==== ./components/InternetStatusHandler.tsx ====
import React from 'react';
import { View } from 'react-native';
import { useInternet } from '../context/InternetContext';
import OfflineBanner from './OfflineBanner';

interface InternetStatusHandlerProps {
  children: React.ReactNode;
}

/**
 * Component untuk handle internet status secara global
 * Wrap ini di sekitar app content Anda
 */
const InternetStatusHandler: React.FC<InternetStatusHandlerProps> = ({ 
  children 
}) => {
  const { isInternetReachable, isCheckingConnection } = useInternet();

  // Anda bisa tambahkan logic global di sini
  // Contoh: prevent API calls ketika offline, dll.

  return (
    <View style={{ flex: 1 }}>
      {/* Offline Banner akan muncul di atas semua content */}
      <OfflineBanner />
      
      {/* Main App Content */}
      <View style={{ 
        flex: 1,
        opacity: isInternetReachable ? 1 : 0.6 // Optional: reduce opacity when offline
      }}>
        {children}
      </View>
    </View>
  );
};

export default InternetStatusHandler;./components/OfflineBanner.tsx
==== ./components/OfflineBanner.tsx ====
import React, { useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Animated,
  Easing,
  Platform,
} from 'react-native';
import { useInternet } from '../context/InternetContext';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';

const OfflineBanner: React.FC = () => {
  const { isInternetReachable, isCheckingConnection } = useInternet();
  const slideAnim = useRef(new Animated.Value(-50)).current;
  const pulseAnim = useRef(new Animated.Value(1)).current;

  useEffect(() => {
    if (!isInternetReachable && !isCheckingConnection) {
      // Slide in animation
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 500,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        }),
        Animated.loop(
          Animated.sequence([
            Animated.timing(pulseAnim, {
              toValue: 1.1,
              duration: 1000,
              easing: Easing.inOut(Easing.ease),
              useNativeDriver: true,
            }),
            Animated.timing(pulseAnim, {
              toValue: 1,
              duration: 1000,
              easing: Easing.inOut(Easing.ease),
              useNativeDriver: true,
            }),
          ])
        ),
      ]).start();
    } else {
      // Slide out animation
      Animated.timing(slideAnim, {
        toValue: -50,
        duration: 300,
        easing: Easing.in(Easing.cubic),
        useNativeDriver: true,
      }).start();
    }
  }, [isInternetReachable, isCheckingConnection, slideAnim, pulseAnim]);

  // Don't show banner if checking connection or internet is reachable
  if (isCheckingConnection || isInternetReachable) {
    return null;
  }

  return (
    <Animated.View 
      style={[
        styles.banner,
        {
          transform: [
            { translateY: slideAnim },
            { scale: pulseAnim }
          ]
        }
      ]}
    >
      <View style={styles.bannerContent}>
        <View style={styles.iconContainer}>
          <FontAwesome6 
            name="wifi" 
            size={16} 
            color="#ffffff" 
            iconStyle='solid'
          />
        </View>
        <View style={styles.textContainer}>
          <Text style={styles.bannerTitle}>Tidak Terkoneksi</Text>
          <Text style={styles.bannerSubtitle}>Periksa koneksi internet Anda</Text>
        </View>
        <View style={styles.statusIndicator}>
          <View style={styles.pulsingDot} />
        </View>
      </View>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  banner: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    backgroundColor: '#dc2626',
    zIndex: 9999,
    elevation: 10,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  bannerContent: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    paddingTop: Platform.OS === 'ios' ? 50 : 12, // Account for status bar on iOS
  },
  iconContainer: {
    marginRight: 12,
    opacity: 0.9,
  },
  textContainer: {
    flex: 1,
  },
  bannerTitle: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 2,
  },
  bannerSubtitle: {
    color: 'rgba(255, 255, 255, 0.8)',
    fontSize: 14,
    fontWeight: '400',
  },
  statusIndicator: {
    marginLeft: 8,
  },
  pulsingDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: '#ffffff',
    opacity: 0.8,
  },
});

export default OfflineBanner;./components/ProcessingOverlay.tsx
==== ./components/ProcessingOverlay.tsx ====
import React from 'react';
import { View, Text, StatusBar, ActivityIndicator } from 'react-native';

interface ProcessingOverlayProps {
  visible: boolean;
  message?: string;
}

/**
 * Overlay component untuk menunjukkan processing state
 */
const ProcessingOverlay: React.FC<ProcessingOverlayProps> = ({ 
  visible, 
  message = "Processing..." 
}) => {
  if (!visible) return null;

  return (
    <View style={{
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0,0,0,0.5)',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 9999,
    }}>
      <StatusBar backgroundColor="#000000" barStyle="light-content" />
      <View style={{
        backgroundColor: 'rgba(0,0,0,0.8)',
        padding: 20,
        borderRadius: 10,
        alignItems: 'center',
        minWidth: 150,
      }}>
        <ActivityIndicator size="large" color="#ffffff" />
        <Text style={{ 
          color: '#ffffff', 
          marginTop: 10, 
          fontSize: 16,
          textAlign: 'center'
        }}>
          {message}
        </Text>
      </View>
    </View>
  );
};

export default ProcessingOverlay;./components/ProductCard.tsx
==== ./components/ProductCard.tsx ====
import React from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  Image,
} from 'react-native';
import { Product } from '../types';
import WishlistButton from '../routes/WishlistButton';

interface ProductCardProps {
  product: Product;
  cardWidth: number;
  isLandscape: boolean;
  onPress: () => void;
}

const ProductCard: React.FC<ProductCardProps> = ({
  product,
  cardWidth,
  isLandscape,
  onPress,
}) => {
  const calculateDiscountedPrice = (price: number, discount?: number) => {
    if (!discount) return price;
    return price * (1 - discount / 100);
  };

  // Variasi background hijau berdasarkan kategori
  const getCardBackground = (category: string) => {
    const backgrounds: { [key: string]: string } = {
      electronics: '#f0f8f0', // Hijau sangat muda
      clothing: '#e8f5e9',    // Hijau muda
      food: '#f1f8e9',        // Hijau kekuningan
      automotive: '#e8f5e8',  // Hijau segar
      home: '#f0f7f0',        // Hijau soft
      beauty: '#e8f5ed',      // Hijau kebiruan
      sports: '#f0f8e8',      // Hijau cerah
      books: '#e8f5e6',       // Hijau natural
      default: '#f0f7f0'      // Default hijau
    };
    return backgrounds[category.toLowerCase()] || backgrounds.default;
  };

  const cardBackground = getCardBackground(product.category);

  return (
    <TouchableOpacity
      style={[
        styles.card,
        {
          width: cardWidth,
          minHeight: isLandscape ? 200 : 180,
          backgroundColor: cardBackground,
        }
      ]}
      onPress={onPress}
      activeOpacity={0.8}
    >
      {/* Header dengan gradient hijau */}
      <View style={styles.cardHeader}>
        <View style={styles.categoryBadge}>
          <Text style={styles.categoryText}>
            {product.category}
          </Text>
        </View>

        <View style={styles.badgeContainer}>
          {product.isNew && (
            <View style={[styles.badge, styles.newBadge]}>
              <Text style={styles.badgeText}>NEW</Text>
            </View>
          )}
          {product.discount && (
            <View style={[styles.badge, styles.discountBadge]}>
              <Text style={styles.badgeText}>{product.discount}% OFF</Text>
            </View>
          )}
        </View>
      </View>

      <View style={styles.imageContainer}>
        <Image
          source={{ uri: product.image }}
          style={styles.image}
          resizeMode="cover"
        />
        {/* Overlay hijau di image */}
        <View style={styles.wishlistContainer}>
          <WishlistButton product={product} size={20} />
        </View>
        <View style={styles.imageOverlay} />
      </View>

      <View style={styles.content}>
        <Text style={styles.name} numberOfLines={2}>
          {product.name}
        </Text>

        <View style={styles.priceContainer}>
          {product.discount ? (
            <>
              <Text style={styles.originalPrice}>
                ${product.price.toLocaleString()}
              </Text>
              <Text style={styles.discountedPrice}>
                ${calculateDiscountedPrice(product.price, product.discount).toLocaleString()}
              </Text>
            </>
          ) : (
            <Text style={styles.price}>
              ${product.price.toLocaleString()}
            </Text>
          )}
        </View>

        <Text style={styles.description} numberOfLines={2}>
          {product.description}
        </Text>

        {/* Eco Features */}
        <View style={styles.ecoFeatures}>
          <View style={styles.ecoFeature}>
            <Text style={styles.ecoIcon}>üåø</Text>
            <Text style={styles.ecoText}>Eco</Text>
          </View>
          <View style={styles.ecoFeature}>
            <Text style={styles.ecoIcon}>üíö</Text>
            <Text style={styles.ecoText}>Green</Text>
          </View>
          <View style={styles.ecoFeature}>
            <Text style={styles.ecoIcon}>üåé</Text>
            <Text style={styles.ecoText}>Earth</Text>
          </View>
        </View>
      </View>

      {/* Bottom accent hijau */}
      <View style={styles.bottomAccent} />
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  card: {
    position: 'relative',
    backgroundColor: '#f0f7f0',
    borderRadius: 20,
    marginBottom: 16,
    shadowColor: '#2e7d32',
    shadowOffset: {
      width: 0,
      height: 6,
    },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 8,
    overflow: 'hidden',
    borderWidth: 2,
    borderColor: '#e8f5e9',
  },
  thumbnail: {
    width: '100%',
    height: 150,
  },
  wishlistContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
    zIndex: 1, // Pastikan tombol di atas gambar
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingTop: 8,
    paddingBottom: 4,
  },
  categoryBadge: {
    backgroundColor: '#2e7d32',
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.2,
    shadowRadius: 3,
    elevation: 3,
  },
  categoryText: {
    color: '#ffffff',
    fontSize: 10,
    fontWeight: 'bold',
    textTransform: 'uppercase',
  },
  badgeContainer: {
    flexDirection: 'row',
    gap: 4,
  },
  badge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.3,
    shadowRadius: 3,
    elevation: 4,
  },
  newBadge: {
    backgroundColor: '#4caf50',
  },
  discountBadge: {
    backgroundColor: '#ff9800',
  },
  badgeText: {
    color: '#ffffff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  imageContainer: {
    position: 'relative',
    width: '100%',
    height: 120,
    marginVertical: 8,
  },
  image: {
    width: '100%',
    height: '100%',
  },
  imageOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(46, 125, 50, 0.1)',
  },
  content: {
    padding: 12,
    paddingTop: 0,
    flex: 1,
    justifyContent: 'space-between',
  },
  name: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#1b5e20',
    marginBottom: 6,
    lineHeight: 18,
    textAlign: 'center',
  },
  priceContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 8,
    gap: 6,
  },
  price: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2e7d32',
  },
  originalPrice: {
    fontSize: 14,
    color: '#78909c',
    textDecorationLine: 'line-through',
    fontWeight: '500',
  },
  discountedPrice: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ff5722',
  },
  description: {
    fontSize: 11,
    color: '#4caf50',
    lineHeight: 14,
    fontWeight: '500',
    marginBottom: 8,
    textAlign: 'center',
    fontStyle: 'italic',
  },
  ecoFeatures: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
    backgroundColor: 'rgba(76, 175, 80, 0.1)',
    paddingHorizontal: 8,
    paddingVertical: 6,
    borderRadius: 10,
    marginTop: 4,
  },
  ecoFeature: {
    alignItems: 'center',
    flex: 1,
  },
  ecoIcon: {
    fontSize: 14,
    marginBottom: 2,
  },
  ecoText: {
    fontSize: 9,
    color: '#2e7d32',
    fontWeight: 'bold',
  },
  bottomAccent: {
    height: 4,
    width: '100%',
    backgroundColor: '#4caf50',
    opacity: 0.8,
  },
});

export default ProductCard;./components/ProductForm.tsx
==== ./components/ProductForm.tsx ====
import React from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  Alert,
} from 'react-native';
import { NewProduct, ErrorsState } from '../types';

interface ProductFormProps {
  product: NewProduct;
  errors: ErrorsState;
  onChange: (field: keyof Omit<NewProduct, 'id'>, value: string) => void;
  onSubmit: () => void;
  onCancel: () => void;
  isSubmitting: boolean;
  screenHeight: number;
  insets: any;
}

const ProductForm: React.FC<ProductFormProps> = ({
  product,
  errors,
  onChange,
  onSubmit,
  onCancel,
  isSubmitting,
  screenHeight,
  insets,
}) => {
  const handleSubmit = () => {
    if (isSubmitting) return;
    onSubmit();
  };

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <View style={[styles.header, { paddingTop: insets.top + 16 }]}>
        <Text style={styles.headerTitle}>Add New Product</Text>
        <Text style={styles.headerSubtitle}>
          Fill in the details for your new eco-friendly product
        </Text>
      </View>

      <ScrollView 
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        <View style={styles.form}>
          {/* Product Name */}
          <View style={styles.inputGroup}>
            <Text style={styles.label}>Product Name *</Text>
            <TextInput
              style={[
                styles.input,
                errors.name && styles.inputError
              ]}
              value={product.name}
              onChangeText={(value) => onChange('name', value)}
              placeholder="Enter product name"
              placeholderTextColor="#999"
            />
            {errors.name && (
              <Text style={styles.errorText}>{errors.name}</Text>
            )}
          </View>

          {/* Price */}
          <View style={styles.inputGroup}>
            <Text style={styles.label}>Price *</Text>
            <TextInput
              style={[
                styles.input,
                errors.price && styles.inputError
              ]}
              value={product.price}
              onChangeText={(value) => onChange('price', value)}
              placeholder="Enter price"
              placeholderTextColor="#999"
              keyboardType="numeric"
            />
            {errors.price && (
              <Text style={styles.errorText}>{errors.price}</Text>
            )}
          </View>

          {/* Image URL */}
          <View style={styles.inputGroup}>
            <Text style={styles.label}>Image URL *</Text>
            <TextInput
              style={[
                styles.input,
                errors.imageUrl && styles.inputError
              ]}
              value={product.imageUrl}
              onChangeText={(value) => onChange('imageUrl', value)}
              placeholder="Enter image URL"
              placeholderTextColor="#999"
              autoCapitalize="none"
            />
            {errors.imageUrl && (
              <Text style={styles.errorText}>{errors.imageUrl}</Text>
            )}
          </View>

          {/* Description */}
          <View style={styles.inputGroup}>
            <Text style={styles.label}>Description *</Text>
            <TextInput
              style={[
                styles.textArea,
                errors.description && styles.inputError
              ]}
              value={product.description}
              onChangeText={(value) => onChange('description', value)}
              placeholder="Enter product description"
              placeholderTextColor="#999"
              multiline
              numberOfLines={4}
              textAlignVertical="top"
            />
            {errors.description && (
              <Text style={styles.errorText}>{errors.description}</Text>
            )}
          </View>

          {/* Preview Section */}
          {product.imageUrl && (
            <View style={styles.previewSection}>
              <Text style={styles.previewTitle}>Image Preview</Text>
              <View style={styles.previewImageContainer}>
                <TextInput
                  style={styles.previewImage}
                  value={product.imageUrl}
                  editable={false}
                />
                <Text style={styles.previewText}>
                  {product.imageUrl ? 'Valid URL' : 'No image URL provided'}
                </Text>
              </View>
            </View>
          )}
        </View>
      </ScrollView>

      <View style={[styles.footer, { paddingBottom: insets.bottom + 16 }]}>
        <TouchableOpacity
          style={[styles.button, styles.cancelButton]}
          onPress={onCancel}
          disabled={isSubmitting}
        >
          <Text style={styles.cancelButtonText}>Cancel</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[
            styles.button,
            styles.submitButton,
            isSubmitting && styles.submitButtonDisabled
          ]}
          onPress={handleSubmit}
          disabled={isSubmitting}
        >
          <Text style={styles.submitButtonText}>
            {isSubmitting ? 'Adding...' : 'Add Product'}
          </Text>
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  header: {
    backgroundColor: '#2e7d32',
    padding: 20,
    paddingBottom: 16,
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 8,
  },
  headerSubtitle: {
    fontSize: 16,
    color: '#e8f5e9',
    opacity: 0.9,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 20,
  },
  form: {
    gap: 20,
  },
  inputGroup: {
    gap: 8,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    color: '#2e7d32',
  },
  input: {
    backgroundColor: '#ffffff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    color: '#333',
  },
  textArea: {
    backgroundColor: '#ffffff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    color: '#333',
    height: 100,
    textAlignVertical: 'top',
  },
  inputError: {
    borderColor: '#ff5722',
  },
  errorText: {
    fontSize: 14,
    color: '#ff5722',
    marginTop: 4,
  },
  previewSection: {
    backgroundColor: '#ffffff',
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  previewTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#2e7d32',
    marginBottom: 12,
  },
  previewImageContainer: {
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#f5f5f5',
    borderRadius: 8,
  },
  previewImage: {
    fontSize: 12,
    color: '#666',
    textAlign: 'center',
  },
  previewText: {
    fontSize: 14,
    color: '#4caf50',
    marginTop: 8,
    fontWeight: '500',
  },
  footer: {
    flexDirection: 'row',
    gap: 12,
    padding: 20,
    backgroundColor: '#ffffff',
    borderTopWidth: 1,
    borderTopColor: '#e0e0e0',
  },
  button: {
    flex: 1,
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  cancelButton: {
    backgroundColor: 'transparent',
    borderWidth: 1,
    borderColor: '#666',
  },
  cancelButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#666',
  },
  submitButton: {
    backgroundColor: '#2e7d32',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
  },
  submitButtonDisabled: {
    backgroundColor: '#a5d6a7',
    opacity: 0.7,
  },
  submitButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#ffffff',
  },
});

export default ProductForm;./components/ResetStackButton.tsx
==== ./components/ResetStackButton.tsx ====
import React from 'react';
import { TouchableOpacity, Text, StyleSheet, Alert } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { HomeStackParamList } from '../types';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { DrawerNavigationProp } from '@react-navigation/drawer';

type NavigationProp = NativeStackNavigationProp<HomeStackParamList>;

const ResetStackButton = () => {
  const navigation = useNavigation<NavigationProp>();

  const handleResetStack = () => {
    Alert.alert(
      'Reset Navigation',
      'Are you sure you want to reset the navigation stack and close the drawer?',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Reset',
          style: 'destructive',
          onPress: () => {
            // Reset stack ke initial route (TopTabs)
            navigation.reset({
              index: 0,
              routes: [{ name: 'Home' }],
            });

            // Tutup drawer secara programatik
            const parent = navigation.getParent<DrawerNavigationProp<{}>>();
            if (parent?.closeDrawer) {
              parent.closeDrawer();
            }

            Alert.alert('Success', 'Navigation stack has been reset!');
          },
        },
      ]
    );
  };

  return (
    <TouchableOpacity style={styles.button} onPress={handleResetStack}>
      <Text style={styles.buttonText}>Reset Stack & Close Drawer</Text>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  button: {
    backgroundColor: '#ff5722',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
  },
  buttonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default ResetStackButton;./components/SplashScreen.tsx
==== ./components/SplashScreen.tsx ====
import React from 'react';
import { View, Text, ActivityIndicator, StyleSheet, Animated } from 'react-native';

interface SplashScreenProps {
  progress: number;
  loadedServices: string[];
  failedServices: string[];
  message?: string;
}

const SplashScreen: React.FC<SplashScreenProps> = ({ 
  progress, 
  loadedServices, 
  failedServices,
  message = "Loading your experience..." 
}) => {
  const progressAnim = React.useRef(new Animated.Value(0)).current;

  React.useEffect(() => {
    Animated.timing(progressAnim, {
      toValue: progress,
      duration: 300,
      useNativeDriver: false,
    }).start();
  }, [progress]);

  const progressWidth = progressAnim.interpolate({
    inputRange: [0, 100],
    outputRange: ['0%', '100%'],
  });

  return (
    <View style={styles.container}>
      {/* App Logo/Brand */}
      <View style={styles.brandContainer}>
        <Text style={styles.logo}>üõçÔ∏è</Text>
        <Text style={styles.appName}>E-Commerce App</Text>
        <Text style={styles.tagline}>Your Shopping Companion</Text>
      </View>

      {/* Loading Indicator */}
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#2e7d32" />
        <Text style={styles.loadingText}>{message}</Text>
        
        {/* Progress Bar */}
        <View style={styles.progressContainer}>
          <View style={styles.progressBackground}>
            <Animated.View 
              style={[
                styles.progressFill,
                { width: progressWidth }
              ]} 
            />
          </View>
          <Text style={styles.progressText}>{progress}%</Text>
        </View>

        {/* Service Status */}
        <View style={styles.servicesContainer}>
          {loadedServices.map(service => (
            <Text key={service} style={styles.serviceSuccess}>
              ‚úÖ {service}
            </Text>
          ))}
          {failedServices.map(service => (
            <Text key={service} style={styles.serviceError}>
              ‚ö†Ô∏è {service} (Using default)
            </Text>
          ))}
        </View>
      </View>

      {/* Footer */}
      <View style={styles.footer}>
        <Text style={styles.footerText}>
          Preparing your personalized experience...
        </Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#9bf89bff',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 60,
    paddingHorizontal: 20,
  },
  brandContainer: {
    alignItems: 'center',
    marginTop: 40,
  },
  logo: {
    fontSize: 64,
    marginBottom: 16,
  },
  appName: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  tagline: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  loadingContainer: {
    alignItems: 'center',
    width: '100%',
  },
  loadingText: {
    fontSize: 16,
    color: '#666',
    marginTop: 20,
    marginBottom: 30,
    textAlign: 'center',
  },
  progressContainer: {
    width: '80%',
    alignItems: 'center',
    marginBottom: 20,
  },
  progressBackground: {
    width: '100%',
    height: 6,
    backgroundColor: '#e0e0e0',
    borderRadius: 3,
    overflow: 'hidden',
    marginBottom: 8,
  },
  progressFill: {
    height: '100%',
    backgroundColor: '#2e7d32',
    borderRadius: 3,
  },
  progressText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '600',
  },
  servicesContainer: {
    width: '80%',
    maxHeight: 120,
  },
  serviceSuccess: {
    fontSize: 12,
    color: '#4caf50',
    marginBottom: 4,
  },
  serviceError: {
    fontSize: 12,
    color: '#ff9800',
    marginBottom: 4,
  },
  footer: {
    alignItems: 'center',
  },
  footerText: {
    fontSize: 12,
    color: '#999',
    textAlign: 'center',
  },
});

export default SplashScreen;./config/linkingConfig.ts
==== ./config/linkingConfig.ts ====
import { LinkingOptions } from '@react-navigation/native';
import { RootDrawerParamList } from '../types/navigation';
import { Linking } from 'react-native';

export const linkingConfig: LinkingOptions<RootDrawerParamList> = {
  prefixes: ['ecommerceapp://', 'https://ecommerceapp.com'],
  
  async getInitialURL() {
    const url = await Linking.getInitialURL();
    console.log('üì± getInitialURL:', url);
    return url;
  },

  subscribe(listener) {
    const linkingSubscription = Linking.addEventListener('url', ({ url }) => {
      console.log('üîó Linking event:', url);
      listener(url);
    });

    return () => {
      linkingSubscription.remove();
    };
  },

  config: {
    screens: {
      // ‚úÖ Sesuaikan dengan struktur DrawerNavigator yang sebenarnya
      Home: 'home',
      Cart: 'keranjang',
      Profile: {
        path: 'profil/:userId?',
        parse: {
          userId: (userId: string) => userId || '',
        },
      },
      Analytics: 'analytics',
      Settings: 'settings',
      CategoryList: 'categories/list',
      ProductCategory: 'category/:category',
      ProductList: 'products/list',
      Login: 'login',
      // Tambahkan screen lainnya sesuai struktur Drawer
    },
  },
};./context/apiClient.ts
==== ./context/apiClient.ts ====
import axios, { AxiosError } from 'axios';
import * as Keychain from 'react-native-keychain';

// 1. --- Konfigurasi Spesifik untuk API Key ---
const API_KEY_SERVICE = 'com.ecom:apiKey';
const API_KEY_USERNAME = 'api_client'; // Username statis sesuai permintaan

/**
 * Helper untuk mengelola API Key di Keychain.
 * Dibuat terpisah dari AuthContext karena ini adalah kredensial level aplikasi, bukan user.
 */
export const ApiKeychainHelper = {
  /**
   * Menyimpan API Key ke Keychain.
   * @param apiKey Kunci API yang akan disimpan.
   */
  async saveApiKey(apiKey: string): Promise<void> {
    try {
      await Keychain.setGenericPassword(API_KEY_USERNAME, apiKey, {
        service: API_KEY_SERVICE,
      });
      console.log('‚úÖ API Key saved to Keychain successfully.');
    } catch (error) {
      console.error('‚ùå Error saving API Key to Keychain:', error);
      throw new Error('Could not save API Key.');
    }
  },

  /**
   * Mengambil API Key dari Keychain.
   * @returns API Key atau null jika tidak ditemukan.
   */
  async getApiKey(): Promise<string | null> {
    try {
      const credentials = await Keychain.getGenericPassword({
        service: API_KEY_SERVICE,
      });
      if (credentials) {
        console.log('‚úÖ API Key retrieved from Keychain.');
        return credentials.password;
      }
      return null;
    } catch (error) {
      console.error('‚ùå Error retrieving API Key from Keychain:', error);
      return null;
    }
  },
};

// 2. --- Fungsi untuk Setup dan Penyimpanan API Key ---

/**
 * Fungsi ini dijalankan sekali saat aplikasi dimulai untuk memastikan
 * API Key rahasia tersimpan dengan aman di Keychain.
 */
export const setupAndStoreApiKey = async () => {
  const staticApiKey = 'API_KEY_SECRET_XYZ'; // Kunci API rahasia Anda

  // Cek apakah key sudah ada untuk menghindari penulisan berulang
  const existingKey = await ApiKeychainHelper.getApiKey();
  if (!existingKey) {
    console.log('üîë API Key not found in Keychain, saving now...');
    await ApiKeychainHelper.saveApiKey(staticApiKey);
  } else {
    console.log('üîë API Key already exists in Keychain.');
  }
};

// 3. --- Konfigurasi Instance Axios dengan Interceptor ---

const apiClient = axios.create({
  baseURL: 'https://api.yourecommerce.com/v1', // Ganti dengan URL API Anda
  timeout: 10000, // 10 detik timeout
});

// Request Interceptor: Menambahkan API Key ke setiap request
apiClient.interceptors.request.use(
  async (config) => {
    const apiKey = await ApiKeychainHelper.getApiKey();

    if (!apiKey) {
      console.error('üö® CRITICAL: API Key not found. Aborting request.');
      // Menghentikan request dengan melempar error simulasi 401
      return Promise.reject(new AxiosError('Unauthorized: Missing API Key.', '401'));
    }

    // Tambahkan API Key ke header
    config.headers['X-API-Key'] = apiKey;

    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

export default apiClient;
./context/AuthContext.tsx
==== ./context/AuthContext.tsx ====
import React, { createContext, useState, ReactNode, useContext, useEffect, useCallback } from 'react';
import { Alert } from 'react-native';
import { secureStorage } from '../storage/secureStorage';
import { authService, LoginCredentials } from '../storage/authService';

interface AuthState {
  isAuthenticated: boolean;
  user: any | null;
}

interface AppSettings {
  theme: string;
  notificationsEnabled: boolean;
  language: string;
  isFirstLaunch: boolean;
}

interface AuthContextType {
  // State
  isAuthenticated: boolean;
  user: AuthState['user'];
  loadingAuth: boolean;
  appSettings: AppSettings;
  authError: string | null;
  postLoginRedirect: { route: string; params?: any } | null;
  
  // Setters untuk hydration
  setUser: (user: any | null) => void;
  setToken: (token: string | null) => void;
  setIsAuthenticated: (isAuthenticated: boolean) => void;
  
  // Actions
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: (options?: { clearAll?: boolean; reason?: string }) => Promise<void>;
  updateProfile: (userData: Partial<AuthState['user']>) => void;
  updateSettings: (settings: Partial<AppSettings>) => void;
  clearAllData: () => Promise<void>;
  getStorageInfo: () => Promise<{ hasAccessToken: boolean; hasRefreshToken: boolean }>;
  clearAuthError: () => void;
  setPostLoginRedirect: (redirect: { route: string; params?: any } | null) => void;
  clearPostLoginRedirect: () => void;
}

export const AuthContext = createContext<AuthContextType>({} as AuthContextType);

interface AuthProviderProps {
  children: ReactNode;
}

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [authState, setAuthState] = useState<AuthState>({
    isAuthenticated: false,
    user: null,
  });
  const [loadingAuth, setLoadingAuth] = useState<boolean>(true);
  const [appSettings, setAppSettings] = useState<AppSettings>({
    theme: 'light',
    notificationsEnabled: true,
    language: 'en',
    isFirstLaunch: true,
  });
  const [authError, setAuthError] = useState<string | null>(null);
  const [postLoginRedirect, setPostLoginRedirect] = useState<{ route: string; params?: any } | null>(null);

  // ‚úÖ SETTERS UNTUK HYDRATION
  const handleSetUser = useCallback((user: any | null) => {
    console.log('üë§ Setting user from hydration:', user ? 'User loaded' : 'No user');
    setAuthState(prev => ({ ...prev, user }));
  }, []);

  const handleSetToken = useCallback(async (token: string | null) => {
    console.log('üîê Setting token from hydration:', token ? 'Token loaded' : 'No token');
    // Token akan dihandle oleh authService, kita cukup update auth state
    if (token) {
      setAuthState(prev => ({ ...prev, isAuthenticated: true }));
    } else {
      setAuthState(prev => ({ ...prev, isAuthenticated: false }));
    }
  }, []);

  const handleSetIsAuthenticated = useCallback((isAuthenticated: boolean) => {
    console.log('üîí Setting auth state from hydration:', isAuthenticated);
    setAuthState(prev => ({ ...prev, isAuthenticated }));
  }, []);

  const clearAuthError = () => setAuthError(null);

  // Load initial data pada app startup
  useEffect(() => {
    const loadInitialData = async () => {
      try {
        setLoadingAuth(true);
        setAuthError(null);

        // 1. Validasi Keychain access
        const isKeychainAccessible = await secureStorage.validateKeychainAccess();
        if (!isKeychainAccessible) {
          throw new Error('Keychain is not accessible');
        }

        // 2. Load auth state dari secure storage
        const authState = await authService.getCurrentAuthState();
        
        // 3. Set auth state
        setAuthState({
          isAuthenticated: authState.isAuthenticated,
          user: authState.user,
        });

        // 4. Load app settings (non-sensitive data)
        try {
          const theme = 'light';
          const notificationsEnabled = true;
          const language = 'en';
          const isFirstLaunch = true;

          setAppSettings({
            theme,
            notificationsEnabled,
            language,
            isFirstLaunch,
          });
        } catch (settingsError) {
          console.error('Settings load error:', settingsError);
        }

      } catch (error) {
        console.error('Initial data load error:', error);
        setAuthError('Failed to load application data');
        setAuthState({ isAuthenticated: false, user: null });
      } finally {
        setLoadingAuth(false);
      }
    };

    loadInitialData();
  }, []);

  const login = async (credentials: LoginCredentials): Promise<void> => {
    try {
      setLoadingAuth(true);
      setAuthError(null);

      const authResponse = await authService.login(credentials);
      
      setAuthState({
        isAuthenticated: true,
        user: authResponse.user,
      });

    } catch (error) {
      console.error('Login error:', error);
      setAuthError('Login failed. Please try again.');
      throw error;
    } finally {
      setLoadingAuth(false);
    }
  };

  const logout = async (options?: { clearAll?: boolean; reason?: string }): Promise<void> => {
    try {
      setLoadingAuth(true);
      setAuthError(null);

      await authService.logout();
      
      setAuthState({
        isAuthenticated: false,
        user: null,
      });

      console.log('‚úÖ Logout completed:', options?.reason || 'user_initiated');

    } catch (error) {
      console.error('Logout error:', error);
      setAuthError('Logout failed');
      setAuthState({ isAuthenticated: false, user: null });
    } finally {
      setLoadingAuth(false);
    }
  };

  const clearAllData = async (): Promise<void> => {
    try {
      setLoadingAuth(true);
      await secureStorage.clearAllSecureData();
      
      setAuthState({ isAuthenticated: false, user: null });
      setAppSettings({
        theme: 'light',
        notificationsEnabled: true,
        language: 'en',
        isFirstLaunch: false,
      });

    } catch (error) {
      console.error('Clear all data error:', error);
      setAuthError('Failed to clear data');
      throw error;
    } finally {
      setLoadingAuth(false);
    }
  };

  const updateProfile = (userData: Partial<AuthState['user']>): void => {
    setAuthState(prev => {
      if (!prev.user) return prev;

      const updatedUser = { ...prev.user, ...userData };
      
      authService.updateUserData(updatedUser)
        .catch(error => console.error('Profile update storage error:', error));

      return { ...prev, user: updatedUser };
    });
  };

  const updateSettings = async (settings: Partial<AppSettings>): Promise<void> => {
    try {
      setAppSettings(prev => ({ ...prev, ...settings }));
      console.log('Settings updated (storage pending):', settings);
    } catch (error) {
      console.error('Settings update error:', error);
      setAuthError('Failed to update settings');
      throw error;
    }
  };

  const getStorageInfo = async (): Promise<{ hasAccessToken: boolean; hasRefreshToken: boolean }> => {
    try {
      const info = await secureStorage.getSecureStorageInfo();
      return {
        hasAccessToken: info.hasAccessToken,
        hasRefreshToken: info.hasRefreshToken,
      };
    } catch (error) {
      console.error('Get storage info error:', error);
      return {
        hasAccessToken: false,
        hasRefreshToken: false,
      };
    }
  };

  return (
    <AuthContext.Provider
      value={{
        // State
        isAuthenticated: authState.isAuthenticated,
        user: authState.user,
        loadingAuth,
        appSettings,
        authError,
        postLoginRedirect,
        
        // Setters untuk hydration
        setUser: handleSetUser,
        setToken: handleSetToken,
        setIsAuthenticated: handleSetIsAuthenticated,
        
        // Actions
        login,
        logout,
        updateProfile,
        updateSettings,
        clearAllData,
        getStorageInfo,
        clearAuthError,
        setPostLoginRedirect: (redirect) => {
          setPostLoginRedirect(redirect);
        },
        clearPostLoginRedirect: () => setPostLoginRedirect(null),
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};./context/CartContext.tsx
==== ./context/CartContext.tsx ====
import React, { createContext, useState, useContext, useEffect, useCallback, useRef } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Product, CartItem } from '../types';
import { CartContextType } from '../types/cart';
import { useAuth } from './AuthContext';
import { safeStorage } from '../utils/safeStorage';

// ‚úÖ Define storage keys locally di CartContext
const CART_STORAGE_KEYS = {
  CART_DATA: 'cartData',
  CART_BACKUP: 'cartBackup',
} as const;

// Maximum cart size to prevent storage issues
const MAX_CART_ITEMS = 100;
const MAX_STORAGE_SIZE = 2 * 1024 * 1024; // 2MB limit

// ‚úÖ GUNAKAN TYPE YANG SUDAH DI DEFINISIKAN
const CartContext = createContext<CartContextType>({
  cartItems: [],
  cartItemCount: 0,
  totalPrice: 0,
  isCartLoading: false,
  lastCartError: null,
  setCartItems: () => {},
  addToCart: async () => {},
  updateQuantity: async () => {},
  removeFromCart: async () => {},
  clearCart: async () => {},
  refreshCart: async () => {},
});

export const useCart = () => {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
};

interface CartProviderProps {
  children: React.ReactNode;
}

export const CartProvider: React.FC<CartProviderProps> = ({ children }) => {
  const [cartItems, setCartItems] = useState<CartItem[]>([]);
  const [isCartLoading, setIsCartLoading] = useState(false);
  const [lastCartError, setLastCartError] = useState<string | null>(null);
  const [isSaving, setIsSaving] = useState(false);
  const { user } = useAuth();
  const currentUserIdRef = useRef<string | undefined>(undefined);

  // Calculate derived values
  const cartItemCount = cartItems.reduce((total, item) => total + item.quantity, 0);
  const totalPrice = cartItems.reduce((total, item) => total + (item.product.price * item.quantity), 0);

  // ‚úÖ FIX: Helper to get user-specific storage keys
  const getUserCartStorageKey = useCallback((userId: string | undefined) => 
    userId ? `${CART_STORAGE_KEYS.CART_DATA}_${userId}` : CART_STORAGE_KEYS.CART_DATA, []);

  const getUserCartBackupKey = useCallback((userId: string | undefined) => 
    userId ? `${CART_STORAGE_KEYS.CART_BACKUP}_${userId}` : CART_STORAGE_KEYS.CART_BACKUP, []);

  // ‚úÖ SETTER UNTUK HYDRATION (EXPOSED)
  const handleSetCartItems = useCallback((items: CartItem[]) => {
    console.log('üõí Setting cart items from hydration:', items.length, 'items');
    setCartItems(items);
    setIsCartLoading(false);
    setLastCartError(null);
  }, []);

  // Check storage size before saving
  const checkStorageSize = (data: any): boolean => {
    try {
      const dataSize = JSON.stringify(data).length;
      const isWithinLimit = dataSize < MAX_STORAGE_SIZE;

      if (!isWithinLimit) {
        console.warn(`üìè Storage limit exceeded: ${dataSize} bytes > ${MAX_STORAGE_SIZE} bytes`);
      }

      return isWithinLimit;
    } catch {
      return false;
    }
  };

  // Handle quota exceeded by clearing old data and retrying
  const handleQuotaExceeded = useCallback(async (newCartItems: CartItem[], userId: string | undefined): Promise<void> => {
    try {
      console.log('üîÑ Handling quota exceeded...');
      
      // Strategy 1: Try to save only essential data
      const essentialCart = newCartItems.slice(0, 10);
      
      if (checkStorageSize(essentialCart)) {
        await safeStorage.safeSave(getUserCartStorageKey(userId), {
          items: essentialCart,
          lastUpdated: Date.now(),
          version: '1.0'
        });
        setCartItems(essentialCart);
        setLastCartError('Storage was full. Some items were removed to free up space.');
        return;
      }

      // Strategy 2: Clear everything and save fresh
      await safeStorage.safeRemove(getUserCartStorageKey(userId));
      await safeStorage.safeSave(getUserCartStorageKey(userId), {
        items: newCartItems,
        lastUpdated: Date.now(),
        version: '1.0'
      });
      
      setLastCartError('Storage was cleared and cart has been reset.');
    } catch (retryError: any) {
      console.error('‚ùå Failed to handle quota exceeded:', retryError);
      setLastCartError('Critical storage error. Cart data may be lost.');
    }
  }, [getUserCartStorageKey]);

  // Optimize storage by compressing data
  const handleStorageOptimization = useCallback(async (newCartItems: CartItem[], userId: string | undefined): Promise<void> => {
    try {
      console.log('üîÑ Optimizing storage...');
      
      // Remove old backup data first
      await safeStorage.safeRemove(getUserCartBackupKey(userId));
      
      // Compress data by removing unnecessary fields
      const optimizedCart = newCartItems.map(item => ({
        id: item.id,
        product: {
          id: item.product.id,
          name: item.product.name,
          price: item.product.price,
          image: item.product.image,
        },
        quantity: item.quantity
      }));

      // Limit cart size if needed
      if (optimizedCart.length > 50) {
        console.warn('üì¶ Cart too large, keeping only recent 50 items');
        optimizedCart.splice(0, optimizedCart.length - 50);
      }

      // Try saving optimized data
      await safeStorage.safeSave(getUserCartStorageKey(userId), {
        items: optimizedCart,
        lastUpdated: Date.now(),
        version: '1.0'
      });

      setCartItems(optimizedCart as CartItem[]);
      setLastCartError('Cart optimized for storage limitations.');
      
    } catch (optimizeError: any) {
      console.error('‚ùå Storage optimization failed:', optimizeError);
      await handleQuotaExceeded(newCartItems, userId);
    }
  }, [getUserCartBackupKey, getUserCartStorageKey, handleQuotaExceeded]);

  // Save cart to storage dengan safeStorage
  const saveCartToStorage = useCallback(async (newCartItems: CartItem[], userId: string | undefined): Promise<void> => {
    try {
      const storageKey = getUserCartStorageKey(userId);
      
      // Check storage size
      if (!checkStorageSize(newCartItems)) {
        console.warn('üîÑ Storage size approaching limit, optimizing...');
        await handleStorageOptimization(newCartItems, userId);
        return;
      }

      // Save main cart data dengan safeStorage
      const saveResult = await safeStorage.safeSave(storageKey, {
        items: newCartItems,
        lastUpdated: Date.now(),
        version: '1.0'
      });

      if (!saveResult.success) {
        throw new Error(saveResult.error || 'Failed to save cart');
      }
      
      setLastCartError(null);
      console.log(`üíæ Cart saved successfully for user: ${userId || 'guest'}`);
    } catch (error: any) {
      console.error(`‚ùå Error saving cart for user ${userId || 'guest'}:`, error);
      
      if (error.message?.includes('QUOTA_EXCEEDED') || error.message?.includes('quota')) {
        setLastCartError('Storage is full. Please clear some items from your cart.');
        await handleQuotaExceeded(newCartItems, userId);
      } else {
        setLastCartError('Failed to save cart changes. Please try again.');
      }
      throw error;
    }
  }, [getUserCartStorageKey, handleQuotaExceeded, handleStorageOptimization]);

  // Load cart from storage dengan safeStorage
  const loadCartFromStorage = useCallback(async (userId: string | undefined): Promise<CartItem[]> => {
    try {
      const storageKey = getUserCartStorageKey(userId);
      
      const result = await safeStorage.safeLoad<CartItem[]>(
        storageKey,
        [], // fallback empty array
        { maxRetries: 3, repairAttempts: 2 }
      );
      
      if (result.success && result.data) {
        if (result.wasRepaired) {
          console.log('üîß Cart data was repaired during load');
        }
        return result.data;
      } else {
        console.warn('‚ö†Ô∏è Using fallback cart data due to storage issues');
        return [];
      }
    } catch (error) {
      console.error(`‚ùå Error loading cart for user ${userId || 'guest'}:`, error);
      return [];
    }
  }, [getUserCartStorageKey]);

  // Handle user change and cart switching
  const handleUserChange = useCallback(async () => {
    const currentUserId = user?.id;
    
    if (currentUserIdRef.current === currentUserId) {
      return;
    }

    setIsCartLoading(true);
    try {
      // Save current user's cart before switching
      if (currentUserIdRef.current !== undefined && cartItems.length > 0) {
        await saveCartToStorage(cartItems, currentUserIdRef.current);
      }

      // Load new user's cart
      const newUserCart = await loadCartFromStorage(currentUserId);
      setCartItems(newUserCart);
      currentUserIdRef.current = currentUserId;
      
      console.log(`üîÑ Switched cart for user: ${currentUserId || 'guest'}`);
    } catch (error) {
      console.error('‚ùå Failed to switch user cart:', error);
      setLastCartError('Failed to load cart data');
    } finally {
      setIsCartLoading(false);
    }
  }, [user, cartItems, saveCartToStorage, loadCartFromStorage]);

  // Initialize cart on app start and user change
  useEffect(() => {
    handleUserChange();
  }, [handleUserChange]);

  // ‚úÖ IMPLEMENTASI FUNGSI ADD TO CART
  const addToCart = async (product: Product, quantity: number = 1): Promise<void> => {
    try {
      setIsCartLoading(true);
      setLastCartError(null);

      if (cartItemCount + quantity > MAX_CART_ITEMS) {
        throw new Error(`Cart cannot exceed ${MAX_CART_ITEMS} items`);
      }

      setCartItems(prevItems => {
        const existingItemIndex = prevItems.findIndex(item => item.product.id === product.id);
        let newItems: CartItem[];

        if (existingItemIndex >= 0) {
          // Update existing item quantity
          newItems = prevItems.map((item, index) =>
            index === existingItemIndex
              ? { ...item, quantity: item.quantity + quantity }
              : item
          );
          console.log(`üîÑ Updated quantity for "${product.name}" to ${newItems[existingItemIndex].quantity}`);
        } else {
          // Add new item
          const newCartItem: CartItem = {
            id: `${product.id}-${Date.now()}`,
            product: product,
            quantity: quantity,
          };
          newItems = [...prevItems, newCartItem];
          console.log(`‚ú® Added "${product.name}" to cart`);
        }

        // Auto-save to storage
        saveCartToStorage(newItems, user?.id).catch(error => {
          console.error('Background save failed:', error);
        });

        return newItems;
      });

    } catch (error: any) {
      console.error('‚ùå Error adding to cart:', error);
      setLastCartError(error.message || 'Failed to add item to cart');
      throw error;
    } finally {
      setIsCartLoading(false);
    }
  };

  // ‚úÖ IMPLEMENTASI FUNGSI UPDATE QUANTITY
  const updateQuantity = async (productId: string, quantity: number): Promise<void> => {
    try {
      if (quantity < 0) {
        throw new Error('Quantity cannot be negative');
      }

      if (quantity === 0) {
        await removeFromCart(productId);
        return;
      }

      setCartItems(prevItems => {
        const newItems = prevItems.map(item =>
          item.product.id === productId
            ? { ...item, quantity }
            : item
        ).filter(item => item.quantity > 0);

        console.log(`üìä Updated quantity for product ${productId} to ${quantity}`);

        saveCartToStorage(newItems, user?.id).catch(error => {
          console.error('Background save failed:', error);
        });

        return newItems;
      });

    } catch (error: any) {
      console.error('‚ùå Error updating quantity:', error);
      setLastCartError(error.message || 'Failed to update quantity');
      throw error;
    }
  };

  // ‚úÖ IMPLEMENTASI FUNGSI REMOVE FROM CART
  const removeFromCart = async (productId: string): Promise<void> => {
    try {
      setCartItems(prevItems => {
        const newItems = prevItems.filter(item => item.product.id !== productId);
        
        console.log(`üóëÔ∏è Removed product ${productId} from cart`);

        saveCartToStorage(newItems, user?.id).catch(error => {
          console.error('Background save failed:', error);
        });

        return newItems;
      });
    } catch (error: any) {
      console.error('‚ùå Error removing from cart:', error);
      setLastCartError(error.message || 'Failed to remove item from cart');
      throw error;
    }
  };

  // ‚úÖ IMPLEMENTASI FUNGSI CLEAR CART
  const clearCart = async (): Promise<void> => {
    try {
      const storageKey = getUserCartStorageKey(user?.id);
      const backupKey = getUserCartBackupKey(user?.id);
      
      setCartItems([]);
      
      // Clear storage dengan safeRemove
      await Promise.all([
        safeStorage.safeRemove(storageKey),
        safeStorage.safeRemove(backupKey)
      ]);
      
      setLastCartError(null);
      console.log('üßπ Cart cleared');
    } catch (error: any) {
      console.error('‚ùå Error clearing cart:', error);
      setLastCartError(error.message || 'Failed to clear cart');
      throw error;
    }
  };

  // ‚úÖ IMPLEMENTASI FUNGSI REFRESH CART
  const refreshCart = async (): Promise<void> => {
    try {
      setIsCartLoading(true);
      const savedCart = await loadCartFromStorage(user?.id);
      setCartItems(savedCart);
      setLastCartError(null);
      console.log('üîÑ Cart refreshed from storage');
    } catch (error: any) {
      console.error('‚ùå Error refreshing cart:', error);
      setLastCartError(error.message || 'Failed to refresh cart');
      throw error;
    } finally {
      setIsCartLoading(false);
    }
  };

  // Auto-save dengan safeStorage
  useEffect(() => {
    const autoSave = async () => {
      if (isSaving || cartItems.length === 0 || isCartLoading) {
        return;
      }

      setIsSaving(true);
      try {
        await saveCartToStorage(cartItems, user?.id);
      } catch (error) {
        console.log('üîÑ Auto-save failed (non-critical):', error instanceof Error ? error.message : 'Unknown error');
      } finally {
        setIsSaving(false);
      }
    };

    const timeoutId = setTimeout(autoSave, 2000);
    return () => clearTimeout(timeoutId);
  }, [cartItems, isCartLoading, isSaving, saveCartToStorage, user?.id]);

  const value: CartContextType = {
    // State
    cartItems,
    cartItemCount,
    totalPrice,
    isCartLoading,
    lastCartError,
    
    // Setters untuk hydration
    setCartItems: handleSetCartItems,
    
    // Actions
    addToCart,
    updateQuantity,
    removeFromCart,
    clearCart,
    refreshCart,
  };

  return (
    <CartContext.Provider value={value}>
      {children}
    </CartContext.Provider>
  );
};./context/DrawerLockContext.tsx
==== ./context/DrawerLockContext.tsx ====
// contexts/DrawerLockContext.js
import React, { createContext, useState, ReactNode } from 'react';

interface DrawerLockContextType {
  drawerLockMode: 'unlocked' | 'locked-closed' | 'locked-open';
  setDrawerLockMode: (mode: 'unlocked' | 'locked-closed' | 'locked-open') => void;
}

export const DrawerLockContext = createContext<DrawerLockContextType>({
  drawerLockMode: 'unlocked',
  setDrawerLockMode: () => {},
});

export const DrawerLockProvider = ({ children }: { children: ReactNode }) => {
  const [drawerLockMode, setDrawerLockMode] = useState<'unlocked' | 'locked-closed' | 'locked-open'>('unlocked');

  return (
    <DrawerLockContext.Provider value={{ drawerLockMode, setDrawerLockMode }}>
      {children}
    </DrawerLockContext.Provider>
  );
};./context/InternetContext.tsx
==== ./context/InternetContext.tsx ====
import React, { createContext, useContext, useEffect, useState } from 'react';
import NetInfo, { NetInfoState } from '@react-native-community/netinfo';

interface InternetContextType {
  isInternetReachable: boolean;
  isCheckingConnection: boolean;
}

const InternetContext = createContext<InternetContextType | undefined>(undefined);

export const useInternet = () => {
  const context = useContext(InternetContext);
  if (context === undefined) {
    throw new Error('useInternet must be used within an InternetProvider');
  }
  return context;
};

interface InternetProviderProps {
  children: React.ReactNode;
}

export const InternetProvider: React.FC<InternetProviderProps> = ({ children }) => {
  const [isInternetReachable, setIsInternetReachable] = useState<boolean>(true);
  const [isCheckingConnection, setIsCheckingConnection] = useState<boolean>(true);

  useEffect(() => {
    // Subscribe to network state updates
    const unsubscribe = NetInfo.addEventListener((state: NetInfoState) => {
      console.log('üåê Network state changed:', {
        isConnected: state.isConnected,
        isInternetReachable: state.isInternetReachable,
        type: state.type
      });

      setIsCheckingConnection(false);

      // Handle connection loss
      if (state.isConnected === false || state.isInternetReachable === false) {
        if (isInternetReachable) {
          console.warn('üìµ Koneksi terputus. Menggunakan mode offline.');
          setIsInternetReachable(false);
        }
      } 
      // Handle connection recovery
      else if (state.isConnected === true && state.isInternetReachable === true) {
        if (!isInternetReachable) {
          console.log('‚úÖ Koneksi pulih. Melanjutkan operasi.');
          setIsInternetReachable(true);
        }
      }
    });

    // Initial network check
    const checkInitialConnection = async () => {
      try {
        const state = await NetInfo.fetch();
        console.log('üîç Initial network state:', {
          isConnected: state.isConnected,
          isInternetReachable: state.isInternetReachable
        });
        
        setIsInternetReachable(state.isConnected === true && state.isInternetReachable === true);
        setIsCheckingConnection(false);
      } catch (error) {
        console.error('‚ùå Error checking initial network state:', error);
        setIsCheckingConnection(false);
      }
    };

    checkInitialConnection();

    // Cleanup subscription
    return () => {
      unsubscribe();
    };
  }, [isInternetReachable]);

  const value: InternetContextType = {
    isInternetReachable,
    isCheckingConnection
  };

  return (
    <InternetContext.Provider value={value}>
      {children}
    </InternetContext.Provider>
  );
};./context/SwipeContext.tsx
==== ./context/SwipeContext.tsx ====
// src/context/SwipeContext.tsx
import React, { createContext, useContext, useState, ReactNode } from 'react';

interface SwipeContextType {
  canSwipe: boolean;
  setCanSwipe: (enabled: boolean) => void;
}

const SwipeContext = createContext<SwipeContextType | undefined>(undefined);

interface SwipeProviderProps {
  children: ReactNode;
}

export const SwipeProvider: React.FC<SwipeProviderProps> = ({ children }) => {
  const [canSwipe, setCanSwipe] = useState(false);

  return (
    <SwipeContext.Provider value={{ canSwipe, setCanSwipe }}>
      {children}
    </SwipeContext.Provider>
  );
};

export const useSwipe = (): SwipeContextType => {
  const context = useContext(SwipeContext);
  if (context === undefined) {
    throw new Error('useSwipe must be used within a SwipeProvider');
  }
  return context;
};./context/WishListContext.tsx
==== ./context/WishListContext.tsx ====
import React, { createContext, useState, useContext, useCallback } from 'react';
import { Product } from '../types';

interface WishlistContextType {
  // State
  wishlistItems: Product[];
  
  // Setters untuk hydration
  setWishlistItems: (items: Product[]) => void;
  
  // Actions
  addToWishlist: (product: Product) => void;
  removeFromWishlist: (productId: string) => void;
  isInWishlist: (productId: string) => boolean;
  clearWishlist: () => void;
}

const WishlistContext = createContext<WishlistContextType | undefined>(undefined);

export const useWishlist = () => {
  const context = useContext(WishlistContext);
  if (context === undefined) {
    throw new Error('useWishlist must be used within a WishlistProvider');
  }
  return context;
};

interface WishlistProviderProps {
  children: React.ReactNode;
}

export const WishlistProvider: React.FC<WishlistProviderProps> = ({ children }) => {
  const [wishlistItems, setWishlistItems] = useState<Product[]>([]);

  // ‚úÖ SETTER UNTUK HYDRATION (EXPOSED)
  const handleSetWishlistItems = useCallback((items: Product[]) => {
    console.log('‚ù§Ô∏è Setting wishlist items from hydration:', items.length, 'items');
    setWishlistItems(items);
  }, []);

  const addToWishlist = useCallback((product: Product) => {
    setWishlistItems(prev => {
      if (prev.find(item => item.id === product.id)) {
        return prev; // Already in wishlist
      }
      return [...prev, product];
    });
  }, []);

  const removeFromWishlist = useCallback((productId: string) => {
    setWishlistItems(prev => prev.filter(item => item.id !== productId));
  }, []);

  const isInWishlist = useCallback((productId: string) => {
    return wishlistItems.some(item => item.id === productId);
  }, [wishlistItems]);

  const clearWishlist = useCallback(() => {
    setWishlistItems([]);
  }, []);

  const value: WishlistContextType = {
    // State
    wishlistItems,
    
    // Setters untuk hydration
    setWishlistItems: handleSetWishlistItems,
    
    // Actions
    addToWishlist,
    removeFromWishlist,
    isInWishlist,
    clearWishlist,
  };

  return (
    <WishlistContext.Provider value={value}>
      {children}
    </WishlistContext.Provider>
  );
};./data/initialProducts.ts
==== ./data/initialProducts.ts ====
import { Product } from '../types';

export const initialProducts: Product[] = [
  {
    id: '1',
    name: 'Organic Cotton T-Shirt',
    price: 299000,
    category: 'clothing',
    description: 'Made from 100% organic cotton, perfect for everyday wear. Sustainable and comfortable.',
    image: 'https://images.unsplash.com/photo-1521572163474-6864f9cf17ab?w=400',
    isNew: true,
  },
  {
    id: '2',
    name: 'Bamboo Toothbrush',
    price: 45000,
    category: 'personal-care',
    description: 'Eco-friendly bamboo toothbrush with charcoal bristles. Biodegradable and sustainable.',
    image: 'https://images.unsplash.com/photo-1559056199-641a0ac8b55e?w=400',
    discount: 15,
  },
  {
    id: '3',
    name: 'Reusable Coffee Cup',
    price: 185000,
    category: 'kitchen',
    description: 'Insulated stainless steel reusable coffee cup. Keep your drinks hot or cold for hours.',
    image: 'https://images.unsplash.com/photo-1544787219-7f47ccb76574?w=400',
    isNew: true,
  },
  {
    id: '4',
    name: 'Solar Powered Charger',
    price: 650000,
    category: 'electronics',
    description: 'Portable solar charger for your devices. Harness the power of the sun anywhere.',
    image: 'https://images.unsplash.com/photo-1609592810794-1c0d476d6ca8?w=400',
  },
  {
    id: '5',
    name: 'Hemp Backpack',
    price: 420000,
    category: 'accessories',
    description: 'Durable hemp backpack with laptop compartment. Water-resistant and eco-friendly.',
    image: 'https://images.unsplash.com/photo-1553062407-98eeb64c6a62?w=400',
    discount: 10,
  },
  {
    id: '6',
    name: 'LED Energy Saver Bulb',
    price: 89000,
    category: 'home',
    description: 'Energy efficient LED bulb with long lifespan. Save energy and reduce your carbon footprint.',
    image: 'https://images.unsplash.com/photo-1507473885765-e6ed057f782c?w=400',
    isNew: true,
  },
  {
    id: '7',
    name: 'Recycled Paper Notebook',
    price: 75000,
    category: 'stationery',
    description: 'Eco-friendly notebook made from recycled paper. Perfect for notes and sketches.',
    image: 'https://images.unsplash.com/photo-1512820790803-83ca734da794?w=400',
  },
  {
    id: '8',
    name: 'Wooden Phone Case',
    price: 120000,
    category: 'electronics',
    description: 'Sustainable wooden phone case with natural finish. Biodegradable and stylish.',
    image: 'https://images.unsplash.com/photo-1556656793-08538906a9f8?w=400',
    discount: 20,
  },
  {
    id: '9',
    name: 'Bamboo Cutting Board',
    price: 150000,
    category: 'kitchen',
    description: 'Natural bamboo cutting board. Antibacterial and sustainable kitchen essential.',
    image: 'https://images.unsplash.com/photo-1556909114-4d0d853e5e25?w=400',
    isNew: true,
  },
  {
    id: '10',
    name: 'Organic Soap Collection',
    price: 95000,
    category: 'personal-care',
    description: 'Set of natural organic soaps with essential oils. Gentle on skin and environment.',
    image: 'https://images.unsplash.com/photo-1594736797933-d0c1382d5d44?w=400',
  },
];./hooks/useAnalytics.ts
==== ./hooks/useAnalytics.ts ====
// hooks/useAnalytics.ts - Untuk screen history
import { useState, useRef } from 'react';
import { NavigationState } from '@react-navigation/native';

export const useAnalytics = () => {
  const [screenHistory, setScreenHistory] = useState<string[]>([]);
  const routeNameRef = useRef<string>('');

  const trackNavigation = (state: NavigationState | undefined) => {
    if (!state) return;

    const previousRouteName = routeNameRef.current;
    const currentRouteName = getActiveRouteName(state);

    if (previousRouteName !== currentRouteName) {
      // Update screen history
      setScreenHistory(prev => [...prev, currentRouteName]);
      
      // Log analytics
      console.log(`üìä [ANALYTICS] Navigation Event:`);
      console.log(`   üéØ Current: ${currentRouteName}`);
      console.log(`   üìà History: ${screenHistory.join(' ‚Üí ')}`);
      console.log(`   üïê Timestamp: ${new Date().toLocaleTimeString()}`);
    }

    routeNameRef.current = currentRouteName;
  };

  const getActiveRouteName = (state: NavigationState): string => {
    const route = state.routes[state.index];
    
    if (route.state) {
      return getActiveRouteName(route.state as NavigationState);
    }
    
    return route.name;
  };

  return {
    trackNavigation,
    screenHistory,
    getActiveRouteName,
  };
};./hooks/useDeepLinking.ts
==== ./hooks/useDeepLinking.ts ====
import { useEffect, useState, useCallback } from 'react';
import { NavigationContainerRef } from '@react-navigation/native';
import { DeviceEventEmitter, Platform } from 'react-native';
import deepLinkingHandler from '../utils/deepLinkingHandler';
import { RootStackParamList } from '../types/navigation';
import { DeepLinkCallbacks } from '../utils/deepLinkingHandler';

interface UseDeepLinkingReturn {
  isDeepLinkingReady: boolean;
  processPendingUrl: () => void;
  deepLinkState: {
    isReady: boolean;
    pendingUrl: string | null;
    hasNavigationRef: boolean;
  };
  testAddToCart: (productId?: string) => void;
}

export const useDeepLinking = (
  navigationRef: React.RefObject<NavigationContainerRef<RootStackParamList>>,
  callbacks?: DeepLinkCallbacks
): UseDeepLinkingReturn => {
  const [isDeepLinkingReady, setIsDeepLinkingReady] = useState<boolean>(false);

  useEffect(() => {
    const initDeepLinking = async (): Promise<void> => {
      try {
        // Set navigation reference
        deepLinkingHandler.setNavigationRef(navigationRef.current);

        // Set external callbacks jika provided
        if (callbacks) {
          deepLinkingHandler.setCallbacks(callbacks);
        }

        // Initialize deep linking
        const initialUrl = await deepLinkingHandler.initialize();

        // Setup native event listener untuk Android
        if (Platform.OS === 'android') {
          const subscription = DeviceEventEmitter.addListener(
            'onDeepLink',
            (url: string) => {
              deepLinkingHandler.handleNativeDeepLink(url);
            }
          );
        }

        // Process initial URL jika ada
        if (initialUrl) {
          console.log('üì± Initial URL found:', initialUrl);
          deepLinkingHandler.handleDeepLink(initialUrl);
        }

        setIsDeepLinkingReady(true);
        console.log('‚úÖ useDeepLinking hook initialized');
      } catch (error) {
        console.log('‚ùå Error in useDeepLinking hook:', error);
        setIsDeepLinkingReady(true);
      }
    };

    initDeepLinking();

    // Cleanup
    return () => {
      deepLinkingHandler.cleanup();
    };
  }, [navigationRef, callbacks]);

  const processPendingUrl = useCallback((): void => {
    deepLinkingHandler.processPendingUrl();
  }, []);

  const testAddToCart = useCallback((productId: string = '55'): void => {
    deepLinkingHandler.testAddToCartDeepLink(productId);
  }, []);

  const deepLinkState = deepLinkingHandler.getState();

  return { 
    isDeepLinkingReady, 
    processPendingUrl,
    deepLinkState,
    testAddToCart
  };
};./hooks/useDrawerLock.ts
==== ./hooks/useDrawerLock.ts ====
// hooks/useDrawerLock.ts
import { useNavigationState } from '@react-navigation/native';

export const useDrawerLock = () => {
  // Gunakan try-catch untuk handle error
  try {
    const currentRoute = useNavigationState(state => {
      if (!state) {
        console.log('‚ùå No navigation state available');
        return 'Unknown';
      }
      
      const route = state.routes[state.index];
      
      // Jika ada nested navigator, cek route yang paling dalam
      if (route.state) {
        return getDeepestRoute(route.state);
      }
      
      return route.name;
    });

    // ‚úÖ SCREEN YANG HARUS DI-LOCK (TERLEPAS DARI SETTINGS)
    const lockedScreens = ['ProductDetail', 'CheckoutModal'];
    const shouldLockDrawer = lockedScreens.includes(currentRoute);

    console.log('üîí Current Route:', currentRoute, 'Locked:', shouldLockDrawer);

    return {
      shouldLockDrawer,
      drawerLockMode: shouldLockDrawer ? 'locked-closed' : 'unlocked' as const,
    };
  } catch (error) {
    console.log('‚ö†Ô∏è useDrawerLock error:', error);
    // Fallback jika hook tidak bisa mengakses navigation state
    return {
      shouldLockDrawer: false,
      drawerLockMode: 'unlocked' as const,
    };
  }
};

// Helper function untuk mendapatkan route paling dalam
const getDeepestRoute = (navigationState: any): string => {
  if (navigationState.routes) {
    const route = navigationState.routes[navigationState.index];
    if (route.state) {
      return getDeepestRoute(route.state);
    }
    return route.name;
  }
  return navigationState.routeName || navigationState.name;
};./hooks/useDynamicHeader.ts
==== ./hooks/useDynamicHeader.ts ====
// hooks/useDynamicHeader.ts
import { useFocusEffect } from '@react-navigation/native';
import { useCallback } from 'react';

export const useDynamicHeader = (navigation: any, title: string, focusedTitle?: string) => {
  useFocusEffect(
    useCallback(() => {
      // Set title ketika tab focused
      navigation.setOptions({
        title: focusedTitle || title,
      });

      // Cleanup: kembalikan title ketika tab unfocused
      return () => {
        navigation.setOptions({
          title: title,
        });
      };
    }, [navigation, title, focusedTitle])
  );
};./hooks/useNetInfo.ts
==== ./hooks/useNetInfo.ts ====
import NetInfo from '@react-native-community/netinfo';
import React, { useEffect } from 'react';

export const useNetInfo = () => {
    const [isOnline, setIsOnline] = React.useState(false)
    const [connectionType, setConnectionType] =React.useState('unknown')

    useEffect(() => {
        const ussubscribe = NetInfo.addEventListener(state => {
            const reachable = state.isConnected && state.isInternetReachable
            setIsOnline(reachable!)
            setConnectionType(state.type)
        })

        return () => ussubscribe()
    }, [])

    return { isOnline, connectionType }
}./hooks/useNetworkAwareAction.ts
==== ./hooks/useNetworkAwareAction.ts ====
import { useInternet } from '../context/InternetContext';
import { Alert } from 'react-native';

/**
 * Hook untuk handle action yang membutuhkan koneksi internet
 */
export const useNetworkAwareAction = () => {
  const { isInternetReachable } = useInternet();

  const executeIfOnline = async (
    action: () => Promise<void>,
    options?: {
      showAlert?: boolean;
      alertTitle?: string;
      alertMessage?: string;
    }
  ): Promise<void> => {
    const {
      showAlert = true,
      alertTitle = 'Tidak Terkoneksi',
      alertMessage = 'Anda sedang offline. Silakan periksa koneksi internet Anda.'
    } = options || {};

    if (!isInternetReachable) {
      if (showAlert) {
        Alert.alert(alertTitle, alertMessage);
      }
      throw new Error('NO_INTERNET_CONNECTION');
    }

    try {
      await action();
    } catch (error) {
      // Re-throw the error with proper typing
      if (error instanceof Error) {
        throw error;
      } else if (typeof error === 'string') {
        throw new Error(error);
      } else {
        throw new Error('Unknown error occurred');
      }
    }
  };

  return {
    executeIfOnline,
    isInternetReachable
  };
};./hooks/useProductApi.ts
==== ./hooks/useProductApi.ts ====
import { useState, useEffect, useCallback } from 'react';
import { Product } from '../types';
import productApi from '../services/api/productApi';

interface UseProductApiResult {
  data: Product[] | Product | string[] | null;
  loading: boolean;
  error: string | null;
  refetch: () => void;
}

export const useProductApi = (
  apiCall: () => Promise<any>,
  dependencies: any[] = []
): UseProductApiResult => {
  const [data, setData] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const execute = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const result = await apiCall();
      setData(result);
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [apiCall]);

  useEffect(() => {
    execute();
  }, dependencies);

  return { data, loading, error, refetch: execute };
};

// Specific hooks for common use cases
export const useAllProducts = () => {
  return useProductApi(() => productApi.getAllProducts());
};

export const useProductById = (id: string) => {
  return useProductApi(() => productApi.getProductById(id), [id]);
};

export const useProductsByCategory = (category: string) => {
  return useProductApi(() => productApi.getProductsByCategory(category), [category]);
};

export const useSearchProducts = (query: string) => {
  return useProductApi(() => productApi.searchProducts(query), [query]);
};

export const useCategories = () => {
  return useProductApi(() => productApi.getCategories());
};./routes/AnalyticsNavigationContainer.tsx
==== ./routes/AnalyticsNavigationContainer.tsx ====
// navigation/AnalyticsNavigationContainer.tsx
import React, { useRef } from 'react';
import { NavigationContainer, NavigationState } from '@react-navigation/native';
import { addAnalyticsEvent } from '../screens/dashboard/AnalyticsHistory';

interface AnalyticsNavigationContainerProps {
  children: React.ReactNode;
}

const AnalyticsNavigationContainer: React.FC<AnalyticsNavigationContainerProps> = ({ children }) => {
  const routeNameRef = useRef<string>('');
  const navigationRef = useRef<any>(null);

  const getActiveRouteName = (state: NavigationState): string => {
    const route = state.routes[state.index];
    
    if (route.state) {
      return getActiveRouteName(route.state as NavigationState);
    }
    
    return route.name;
  };

  const onStateChange = (state: NavigationState | undefined) => {
    if (!state) return;

    const previousRouteName = routeNameRef.current;
    const currentRouteName = getActiveRouteName(state);

    if (previousRouteName !== currentRouteName) {
      addAnalyticsEvent(currentRouteName, previousRouteName);
    }

    routeNameRef.current = currentRouteName;
  };

  const onReady = () => {
    const rootState = navigationRef.current?.getRootState();
    if (rootState) {
      routeNameRef.current = getActiveRouteName(rootState);
    }
  };

  return (
    <NavigationContainer
      ref={navigationRef}
      onReady={onReady}
      onStateChange={onStateChange}
    >
      {children}
    </NavigationContainer>
  );
};

export default AnalyticsNavigationContainer;./routes/AuthGuard.tsx
==== ./routes/AuthGuard.tsx ====
import React, { useState, useEffect, ReactNode } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ActivityIndicator } from 'react-native';
import { useNavigation, useRoute, CommonActions } from '@react-navigation/native';
import { useAuth } from '../context/AuthContext'; // ‚úÖ Import useAuth
import { DrawerNavigationProp } from '@react-navigation/drawer'; 
import { RootDrawerParamList } from '../types';

/**
 * AUTH GUARD COMPONENT - UNIVERSAL NAVIGATION SUPPORT
 * Support untuk Stack Navigator DAN Drawer Navigator
 */

type NavigationProp = DrawerNavigationProp<RootDrawerParamList>;

interface AuthGuardProps {
  children: ReactNode;
  fallbackToLogin?: boolean;
}

const AuthGuard: React.FC<AuthGuardProps> = ({ 
  children, 
  fallbackToLogin = false 
}) => {
  // ‚úÖ Gunakan state dari AuthContext sebagai sumber kebenaran
  const { isAuthenticated, loadingAuth, setPostLoginRedirect } = useAuth();
  const navigation = useNavigation<NavigationProp>();
  const route = useRoute();

  useEffect(() => {
    // Jika loading selesai dan user tidak terotentikasi, redirect
    if (!loadingAuth && !isAuthenticated && fallbackToLogin) {
      redirectToLogin();
    }
  }, [isAuthenticated, loadingAuth, fallbackToLogin]);

  /**
   * UNIVERSAL REDIRECT KE LOGIN
   * Work untuk Stack & Drawer navigator
   */
  const redirectToLogin = (): void => {
    // ‚úÖ Simpan rute yang sedang dituju sebelum redirect
    // Ini akan digunakan setelah login berhasil
    console.log(`üîí AuthGuard: User not authenticated. Storing redirect to "${route.name}" and redirecting to Login.`);
    setPostLoginRedirect({
      route: route.name as keyof RootDrawerParamList,
      params: route.params,
    });

    // Method 1: Reset navigation ke Login screen (universal)
    navigation.dispatch(
      CommonActions.reset({
        index: 0,
        routes: [{ name: 'Login' }],
      })
    );
  };

  const handleLoginRedirect = (): void => {
    redirectToLogin();
  };

  // Show loading indicator selama checking
  if (loadingAuth && fallbackToLogin) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#2e7d32" />
        <Text style={styles.loadingText}>Checking authentication...</Text>
      </View>
    );
  }

  // Jika authenticated, render children
  if (isAuthenticated) {
    return <>{children}</>;
  }

  // Jika fallbackToLogin = true, kita sudah redirect, jadi return null
  if (fallbackToLogin) {
    return null;
  }

  // Show UI message jika tidak authenticated
  return (
    <View style={styles.container}>
      <Text style={styles.title}>üîí Authentication Required</Text>
      <Text style={styles.message}>
        You need to be logged in to access this content
      </Text>
      
      <TouchableOpacity 
        style={styles.loginButton}
        onPress={handleLoginRedirect}
      >
        <Text style={styles.loginButtonText}>Go to Login</Text>
      </TouchableOpacity>
      
      <Text style={styles.debugText}>
        Current route: {route.name} | Navigator: {navigation.getState().type}
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
    backgroundColor: '#f8f9fa',
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8f9fa',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 16,
    textAlign: 'center',
  },
  message: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 30,
    lineHeight: 22,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  loginButton: {
    backgroundColor: '#2e7d32',
    paddingHorizontal: 32,
    paddingVertical: 12,
    borderRadius: 8,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
    marginBottom: 12,
  },
  loginButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  retryButton: {
    paddingHorizontal: 32,
    paddingVertical: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#2e7d32',
    marginBottom: 20,
  },
  retryButtonText: {
    color: '#2e7d32',
    fontSize: 14,
    fontWeight: '500',
  },
  debugText: {
    fontSize: 12,
    color: '#999',
    marginTop: 20,
  },
});

export default AuthGuard;./routes/BottomTabsNavigator.tsx
==== ./routes/BottomTabsNavigator.tsx ====
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { BottomTabsParamList } from '../types';
import CategoriesWithTopTabs from './CategoriesWithTopTabs';
import ProfileScreen from '../screens/dashboard/Profile';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';
import HomeScreen from '../screens/dashboard/Home';
import AnalyticsHistoryScreen from '../screens/dashboard/AnalyticsHistory';
import { useAuth } from '../context/AuthContext';
import { Alert } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { DrawerNavigationProp } from '@react-navigation/drawer';
import { RootDrawerParamList } from '../types';

const Tab = createBottomTabNavigator<BottomTabsParamList>();

const BottomTabsNavigator = () => {
  const { isAuthenticated } = useAuth();
  const drawerNavigation = useNavigation<DrawerNavigationProp<RootDrawerParamList>>();

  return (
    <Tab.Navigator
      screenOptions={{
        tabBarActiveTintColor: '#2e7d32',
        tabBarInactiveTintColor: '#666',
        tabBarStyle: {
          backgroundColor: '#ffffff',
          borderTopWidth: 1,
          borderTopColor: '#e0e0e0',
          height: 60,
          paddingBottom: 8,
          paddingTop: 8,
        },
        tabBarLabelStyle: {
          fontSize: 12,
          fontWeight: '500',
        },
        headerShown: false,
      }}
      initialRouteName="CategoriesTopTabs"
    >
      {/* Home Tab - Navigate ke Home screen di Drawer */}
      <Tab.Screen
        name="Home"
        component={HomeScreen} // Tetap butuh component, tapi tidak akan digunakan
        listeners={() => ({
          tabPress: (e) => {
            // Mencegah navigasi default ke HomeScreen di dalam tab
            e.preventDefault();
            // Navigate ke Home screen yang asli di Drawer Navigator
            drawerNavigation.navigate('Home');
          },
        })}
        options={{
          title: 'Home',
          tabBarIcon: ({ color, size }) => (
            <FontAwesome6 name="house" size={size} color={color} iconStyle='solid' />
          ),
        }}
      />

      {/* Categories Tab - Normal behavior */}
      <Tab.Screen
        name="CategoriesTopTabs"
        component={CategoriesWithTopTabs}
        options={{
          title: 'Categories',
          tabBarIcon: ({ color, size }) => (
            <FontAwesome6 name="cube" size={size} color={color} iconStyle='solid'  />
          ),
        }}
      />

      {/* Analytics Tab - Normal behavior */}
      <Tab.Screen
        name="Analytics"
        component={AnalyticsHistoryScreen}
        options={{
          title: 'Analytics',
          tabBarIcon: ({ color, size, focused }) => (
            <FontAwesome6
              name={focused ? "chart-line" : "chart-simple"}
              size={size}
              color={color}
              iconStyle='solid'
            />
          ),
        }}
      />

      {/* Profile Tab dengan kondisi login */}
      <Tab.Screen
        name="Profile"
        component={ProfileScreen}
        listeners={() => ({
          tabPress: (e) => {
            if (!isAuthenticated) {
              // Prevent default navigation ke Profile
              e.preventDefault();
              // Tampilkan alert dan arahkan ke Login di Drawer
              Alert.alert(
                'Login Required',
                'Please login to access your profile',
                [
                  {
                    text: 'Cancel',
                    style: 'cancel',
                  },
                  {
                    text: 'Login',
                    onPress: () => drawerNavigation.navigate('Login'),
                  },
                ]
              );
            }
            // Jika sudah login, biarkan navigasi default berjalan
          },
        })}
        options={{
          title: 'Profile',
          tabBarIcon: ({ color, size }) => (
            <FontAwesome6 name="user" size={size} color={color} />
          ),
        }}
      />
    </Tab.Navigator>
  );
};

export default BottomTabsNavigator;./routes/CategoriesWithTopTabs.tsx
==== ./routes/CategoriesWithTopTabs.tsx ====
import React from 'react';
import { View, StyleSheet } from 'react-native';
import TopTabsNavigator from './TopTabsNavigator';

// This component wraps the Top Tabs with the Bottom Tabs navigation
const CategoriesWithTopTabs = () => {
  return (
    <View style={styles.container}>
      <TopTabsNavigator />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});

export default CategoriesWithTopTabs;./routes/DrawerNavigator.tsx
==== ./routes/DrawerNavigator.tsx ====
import React from 'react';
import { createDrawerNavigator } from '@react-navigation/drawer';
import { RootDrawerParamList } from '../types';
import SettingsScreen from '../screens/settings/Setting';
import LoginScreen from '../screens/auth/Login';
import CustomDrawerContent from '../components/CustomDrawerContent';
import BottomTabsNavigator from './BottomTabsNavigator';
import HomeScreen from '../screens/dashboard/Home';
import { Text, TouchableOpacity, View } from 'react-native';
import { useCart } from '../context/CartContext';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';
import { useSwipe } from '../context/SwipeContext';
import { useDrawerLock } from '../hooks/useDrawerLock';
import ProductDetailScreen from '../screens/dashboard/ProductDetailScreen';
import CheckoutModalScreen from '../screens/dashboard/CheckoutModal';
import CartScreen from '../screens/dashboard/Cart';
import ProductListScreen from '../screens/dashboard/ProductListScreen';
import AnalyticsHistoryScreen from '../screens/dashboard/AnalyticsHistory';
import ProfileScreen from '../screens/dashboard/Profile';
import AuthGuard from './AuthGuard';
import TestErrorScreen from '../screens/auth/TestErrorScreen';


const Drawer = createDrawerNavigator<RootDrawerParamList>();

const DrawerNavigator = () => {
  const { canSwipe } = useSwipe();
  const { shouldLockDrawer, drawerLockMode } = useDrawerLock()
  const { cartItemCount } = useCart();

  return (
    <Drawer.Navigator
      drawerContent={(props) => <CustomDrawerContent {...props} />}
      screenOptions={({ navigation, route }) => {

        const lockedScreens = ['ProductDetail', 'CheckoutModal'];
        const isDrawerLocked = lockedScreens.includes(route.name);


        const drawerLockMode = shouldLockDrawer ? 'locked-closed' : 'unlocked';

        return {
          headerShown: true,
          headerTitle: () => (
            <View style={{ flexDirection: 'row', alignItems: 'center', paddingLeft: 80 }}>
              <FontAwesome6 name="leaf" size={20} color="#2af310ff" iconStyle='solid' style={{ marginRight: 8 }} />
              <Text style={{
                fontSize: 20,
                fontWeight: 'bold',
                color: '#ffffff',
              }}>
                Eco Shop
              </Text>
            </View>
          ),
          headerTitleStyle: {
            fontSize: 20,
            fontWeight: 'bold',
            color: '#ffffff',
            marginLeft: 20,
          },
          headerStyle: {
            backgroundColor: '#2e7d32',
          },
          headerTintColor: '#ffffff',
          headerLeft: () => {
            const isHomeScreen = route.name === 'Home';

            if (isHomeScreen) {
              return (
                <TouchableOpacity
                  style={{ marginLeft: 16 }}
                  onPress={() => navigation.toggleDrawer()}
                >
                  <FontAwesome6 name="bars" size={24} color="#ffffff" iconStyle='solid' />
                </TouchableOpacity>
              );
            } else {
              return (
                <TouchableOpacity
                  style={{ marginLeft: 16 }}
                  onPress={() => navigation.goBack()}
                >
                  <FontAwesome6 name="arrow-left" size={24} color="#ffffff" iconStyle='solid' />
                </TouchableOpacity>
              );
            }
          },
          headerRight: () => (
            <TouchableOpacity
              style={{ marginRight: 16, position: 'relative' }}
                onPress={() => navigation.navigate('Cart')}
              >
                <FontAwesome6 name="cart-shopping" size={24} color="#ffffff" iconStyle='solid' />
                {cartItemCount > 0 && (
                  <View style={{
                    position: 'absolute', right: -8, top: -4, backgroundColor: '#ef4444', borderRadius: 10, width: 20, height: 20, justifyContent: 'center', alignItems: 'center'
                  }}>
                    <Text style={{
                      color: '#ffffff',
                      fontSize: 12,
                      fontWeight: 'bold'
                    }}>
                      {cartItemCount}
                    </Text>
                  </View>
                )}
              </TouchableOpacity>
          ),
          drawerStyle: {
            backgroundColor: '#f0f7f0',
            width: 280,
          },
          drawerLabelStyle: {
            fontSize: 16,
            fontWeight: '500',
            color: '#2e7d32',
          },
          drawerActiveBackgroundColor: '#4caf50',
          drawerActiveTintColor: '#ffffff',
          drawerInactiveTintColor: '#2e7d32',
          swipeEnabled: canSwipe && !isDrawerLocked,
          drawerLockMode: drawerLockMode,
        };
      }}
    >
      <Drawer.Screen
        name="Home"
        component={HomeScreen}
        options={{
          drawerIcon: ({ color, size }) => (
            <FontAwesome6 name="house" size={size} color={color} iconStyle="solid" />
          ),
        }}
      />

      {/* Semua screen lain pake AuthGuard */}
      <Drawer.Screen
        name="CategoriesWithBottomTabs"
        options={{
          drawerIcon: ({ color, size }) => (
            <FontAwesome6 name="cube" size={size} color={color} iconStyle="solid" />
          ),
          title: 'Categories',
          headerShown: true,
        }}
      >
        {() => (
          <AuthGuard fallbackToLogin={true}>
            <BottomTabsNavigator />
          </AuthGuard>
        )}
      </Drawer.Screen>

      <Drawer.Screen
        name="Settings"
        options={{
          drawerIcon: ({ color, size }) => (
            <FontAwesome6 name="gear" size={size} color={color} iconStyle="solid" />
          ),
          title: 'Settings',
        }}
      >
        {() => (
          <AuthGuard fallbackToLogin={true}>
            <SettingsScreen />
          </AuthGuard>
        )}
      </Drawer.Screen>

      <Drawer.Screen
        name="Profile"
        options={{
          drawerIcon: ({ color, size }) => (
            <FontAwesome6 name="user" size={size} color={color} iconStyle="solid" />
          ),
          title: 'üë§ Profile',
        }}
      >
        {() => (
          <AuthGuard fallbackToLogin={true}>
            <ProfileScreen />
          </AuthGuard>
        )}
      </Drawer.Screen>

      <Drawer.Screen
        name="Analytics"
        options={{
          drawerIcon: ({ color, size }) => (
            <FontAwesome6 name="chart-line" size={size} color={color} iconStyle="solid" />
          ),
          title: 'Analytics',
        }}
      >
        {() => (
          <AuthGuard fallbackToLogin={true}>
            <AnalyticsHistoryScreen />
          </AuthGuard>
        )}
      </Drawer.Screen>

      <Drawer.Screen
        name="Login"
        component={LoginScreen}
        options={{
          title: 'üîê Login',
          drawerItemStyle: { display: 'none' },
        }}
      />

      {/* Screens yang disembunyi dari drawer, tapi perlu proteksi */}
      <Drawer.Screen
        name="ProductDetail"
        options={{ title: 'Product Details', drawerItemStyle: { display: 'none' } }}
      >
        {() => (
          <AuthGuard fallbackToLogin={true}>
            <ProductDetailScreen />
          </AuthGuard>
        )}
      </Drawer.Screen>

      <Drawer.Screen
        name="CheckoutModal"
        options={{ title: 'Checkout', drawerItemStyle: { display: 'none' } }}
      >
        {() => (
          <AuthGuard fallbackToLogin={true}>
            <CheckoutModalScreen />
          </AuthGuard>
        )}
      </Drawer.Screen>

      <Drawer.Screen
        name="Cart"
        options={{ title: 'Shopping Cart', drawerItemStyle: { display: 'none' } }}
      >
        {() => (
          <AuthGuard fallbackToLogin={true}>
            <CartScreen />
          </AuthGuard>
        )}
      </Drawer.Screen>

      <Drawer.Screen
        name="ProductList"
        options={{ title: 'All Products', drawerItemStyle: { display: 'none' } }}
      >
        {() => (
          <AuthGuard fallbackToLogin={true}>
            <ProductListScreen />
          </AuthGuard>
        )}
      </Drawer.Screen>

      <Drawer.Screen
        name="TestError"
        component={TestErrorScreen}
        options={{
          title: 'Test Error',
          drawerItemStyle: { display: 'none' }, // Sembunyikan dari drawer
        }}
      />

    </Drawer.Navigator>
  );
};

export default DrawerNavigator;./routes/HomeStackNavigator.tsx
==== ./routes/HomeStackNavigator.tsx ====
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { HomeStackParamList } from '../types';
import HomeScreen from '../screens/dashboard/Home';
import ProductDetailScreen from '../screens/dashboard/ProductDetailScreen';
import ProfileScreen from '../screens/dashboard/Profile';
import LoginScreen from '../screens/auth/Login';
import TestErrorScreen from '../screens/auth/TestErrorScreen';


const Stack = createNativeStackNavigator<HomeStackParamList>();

const HomeStackNavigator = () => {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
      initialRouteName="Home"
    >
      <Stack.Screen
        name="Home"
        component={HomeScreen}
        options={{
          title: 'üåø Eco Shop',
        }}
      />
      <Stack.Screen
        name="ProductDetail"
        component={ProductDetailScreen}
        options={{
          title: 'Product Details',
          headerShown: true,
        }}
      />
      <Stack.Screen
        name="Profile"
        component={ProfileScreen}
        options={{
          title: 'My Profile',
          headerShown: true,
        }}
      />
      <Stack.Screen
        name="Login"
        component={LoginScreen}
        options={{
          title: 'Login',
          headerShown: false,
        }}
      />

      <Stack.Screen
        name="TestError"
        component={TestErrorScreen}
        options={{ title: 'Test Error' }}
      />
    </Stack.Navigator>
  );
};

export default HomeStackNavigator;./routes/index.tsx
==== ./routes/index.tsx ====
import React from 'react';
import DrawerNavigator from './DrawerNavigator'; // Ganti ke DrawerNavigator

const Navigation = () => {
  return (
    // Komponen ini sekarang hanya bertanggung jawab untuk merender navigator utama.
    // NavigationContainer akan dipindahkan ke App.tsx.
    <DrawerNavigator />
  );
};

export default Navigation;./routes/RootNavigator.tsx
==== ./routes/RootNavigator.tsx ====
import { NavigationContainer} from '@react-navigation/native'
import ButtomTabsNavigator from './BottomTabsNavigator'
import TopTabsNavigator from './TopTabsNavigator'
import { SafeAreaProvider } from 'react-native-safe-area-context'
import DrawerNavigator from './DrawerNavigator'

export default function RootNavigator() {
    return (
        <>
        <SafeAreaProvider>
            <NavigationContainer>
                <DrawerNavigator/>
                {/* <TopTabsNavigator/> */}
                {/* <ButtomTabsNavigator/> */}
            </NavigationContainer>
        </SafeAreaProvider>
        </>
    )
}./routes/TopTabsNavigator.tsx
==== ./routes/TopTabsNavigator.tsx ====
import React from 'react';
import { createMaterialTopTabNavigator } from '@react-navigation/material-top-tabs';
import { TopTabsParamList } from '../types';
import PopularScreen from '../screens/categories/Popular';
import NewScreen from '../screens/categories/New';
import DiscountScreen from '../screens/categories/Discount';
import ElectronicsScreen from '../screens/categories/Electronics';
import ClothingScreen from '../screens/categories/Clothing';
import FoodScreen from '../screens/categories/Food';
import AutomotiveScreen from '../screens/categories/Automotive';
import EntertainmentScreen from '../screens/categories/Entertainment';
import BabyScreen from '../screens/categories/Baby';
import AuthGuard from './AuthGuard';

const Tab = createMaterialTopTabNavigator<TopTabsParamList>();

const TopTabsNavigator = () => {
  return (
    <Tab.Navigator
      screenOptions={{
        tabBarScrollEnabled: true,
        tabBarItemStyle: { 
          width: 'auto',
          paddingHorizontal: 16,
        },
        tabBarStyle: {
          backgroundColor: '#f8f9fa',
          elevation: 0,
          shadowOpacity: 0,
        },
        tabBarLabelStyle: {
          fontSize: 14,
          fontWeight: '600',
          textTransform: 'none',
        },
        tabBarIndicatorStyle: {
          backgroundColor: '#2e7d32',
          height: 3,
        },
        tabBarActiveTintColor: '#2e7d32',
        tabBarInactiveTintColor: '#666666',
      }}
    >
      <Tab.Screen name="Popular" component={PopularScreen} />
      <Tab.Screen name="New" component={NewScreen} />
      <Tab.Screen name="Discount" component={DiscountScreen} />
      <Tab.Screen name="Electronics" component={ElectronicsScreen} />
      <Tab.Screen name="Clothing" component={ClothingScreen} />
      <Tab.Screen name="Food" component={FoodScreen} />
      <Tab.Screen name="Automotive" component={AutomotiveScreen} />
      <Tab.Screen name="Entertainment" component={EntertainmentScreen} />
      <Tab.Screen name="Baby">
        {() => <AuthGuard><BabyScreen /></AuthGuard>}
      </Tab.Screen>
    </Tab.Navigator>
  );
};

export default TopTabsNavigator;./routes/WishlistButton.tsx
==== ./routes/WishlistButton.tsx ====
import React from 'react';
import { TouchableOpacity, StyleSheet, View, Alert, GestureResponderEvent } from 'react-native';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';
import { useWishlist } from '../services/wishlist/useWishlist';
import { Product } from '../types';
import { useAuth } from '../context/AuthContext';

interface WishlistButtonProps {
  product: Product;
  size?: number;
  style?: object;
}

const WishlistButton: React.FC<WishlistButtonProps> = ({ product, size = 24, style }) => {
  const { isAuthenticated } = useAuth();
  const { isInWishlist, toggleItem:toggleWishlist } = useWishlist();

  const isWishlisted = isInWishlist(product.id);

  const handlePress = (e: GestureResponderEvent) => {
    e.stopPropagation(); // ‚úÖ Hentikan event agar tidak menyebar ke parent (kartu produk)
    if (!isAuthenticated) {
      Alert.alert('Login Required', 'You need to be logged in to add items to your wishlist.');
      return;
    }
    toggleWishlist(product.id);
  };

  return (
    <TouchableOpacity onPress={handlePress} style={[styles.button, style]}>
      <FontAwesome6
        name={isWishlisted ? "heart" : "heart"}
        size={size}
        color={isWishlisted ? '#ef4444' : '#666'}
        iconStyle='solid' // Gunakan ikon solid jika di-wishlist
      />
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  button: {
    padding: 8,
    borderRadius: 50,
    backgroundColor: 'rgba(255, 255, 255, 0.7)',
    // Shadow untuk iOS
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.41,
    // Elevation untuk Android
    elevation: 2,
  },
});

export default WishlistButton;./screens/auth/Login.tsx
==== ./screens/auth/Login.tsx ====
import React, { useState, useContext } from 'react';
import {
    View,
    Text,
    StyleSheet,
    TextInput,
    TouchableOpacity,
    Alert,
    KeyboardAvoidingView,
    Platform,
    ScrollView,
    ActivityIndicator,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';
import { HomeStackParamList } from '../../types';
import { AuthContext } from '../../context/AuthContext';
import { validateUsername, validatePassword } from '../../utils/validation';

type LoginScreenNavigationProp = NativeStackNavigationProp<HomeStackParamList>;

const LoginScreen = () => {
    const navigation = useNavigation<LoginScreenNavigationProp>();
    const { login, isAuthenticated, loadingAuth, postLoginRedirect, clearPostLoginRedirect } = useContext(AuthContext);

    const [form, setForm] = useState({
        username: '',
        password: '',
    });
    const [errors, setErrors] = useState({
        username: '',
        password: '',
    });
    const [isLoading, setIsLoading] = useState(false);
    const [showPassword, setShowPassword] = useState(false);

    // Jika sudah login, redirect ke Home
    React.useEffect(() => {
        if (isAuthenticated && !loadingAuth) {
            if (postLoginRedirect) {
                console.log('‚úÖ [LOGIN] Authenticated. Redirecting to stored route:', postLoginRedirect);
                const { route, params } = postLoginRedirect;
                // Hapus redirect yang tersimpan agar tidak digunakan lagi
                clearPostLoginRedirect();
                // Arahkan ke tujuan awal
                navigation.navigate(route as any, params);
            } else {
                console.log('‚úÖ [LOGIN] Authenticated. No stored route, redirecting to Home.');
                navigation.reset({
                    index: 0,
                    routes: [{ name: 'Home' }],
                });
            }
        }
    }, [isAuthenticated, loadingAuth, navigation, postLoginRedirect, clearPostLoginRedirect]);

    const handleInputChange = (field: keyof typeof form, value: string) => {
        setForm(prev => ({
            ...prev,
            [field]: value,
        }));

        if (errors[field]) {
            setErrors(prev => ({
                ...prev,
                [field]: '',
            }));
        }
    };

   const validateForm = (): boolean => {
    // Simple validation saja dulu
    const usernameError = form.username ? '' : 'Username is required';
    const passwordError = form.password ? '' : 'Password is required';

    setErrors({
        username: usernameError,
        password: passwordError,
    });

    const isValid = !usernameError && !passwordError;
    console.log('‚úÖ [VALIDATION] Result:', { 
        isValid, 
        username: form.username,
        passwordLength: form.password.length 
    });
    
    return isValid;
};

const handleLogin = async () => {
    if (!validateForm()) {
        console.log('‚ùå [LOGIN] Form validation failed');
        console.log('‚ùå [LOGIN] Current form state:', form); // Debug form state
        return;
    }

    setIsLoading(true);
    console.log('üîê [LOGIN] Starting login process...', {
        username: form.username,
        passwordLength: form.password.length
    });

    try {
        console.log('üìû [LOGIN] Calling AuthContext login...');
        await login({
            username: form.username,
            password: form.password
        });

        console.log('‚úÖ [LOGIN] AuthContext login completed successfully');
        Alert.alert('Success', 'Welcome back to Eco Store!');
        
    } catch (error: any) {
        console.error('‚ùå [LOGIN] Login error details:', error);
        Alert.alert(
            'Login Failed', 
            error.message || 'Invalid username or password. Please try again.'
        );
    } finally { 
        setIsLoading(false);
    }
};
   const handleDemoLogin = async () => {
    console.log('üéØ [DEMO] Starting demo login...');
    
    // 1. Set form state dulu
    const demoCredentials = {
        username: 'emilys',
        password: 'emilyspass'
    };
    
    setForm(demoCredentials);
    console.log('üéØ [DEMO] Form set to:', demoCredentials);

    // 2. Tunggu sebentar biar state ter-update, baru panggil handleLogin
    setTimeout(() => {
        console.log('üéØ [DEMO] Now calling handleLogin...');
        handleLogin();
    }, 200);
};

    // Test langsung dengan DummyJSON API
    const testDirectAPI = async () => {
    console.log('üß™ [TEST] Testing direct DummyJSON API call...');
    
    // Test multiple possible credentials
    const testCredentialsList = [
        { username: 'emilys', password: 'emilyspass' },
        { username: 'kminchelle', password: '0lelplR' }, // Original
        { username: 'atuny0', password: '9uQFF1Lh' },
        { username: 'hbingley1', password: 'CQutx25i8r' }
    ];

    for (const testCredentials of testCredentialsList) {
        try {
            console.log('üì° [TEST] Testing with:', testCredentials);
            
            const response = await fetch('https://dummyjson.com/auth/login', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(testCredentials),
            });

            console.log('üì° [TEST] Response status:', response.status);
            
            const responseText = await response.text();
            console.log('üì° [TEST] Response body:', responseText);

            if (response.ok) {
                const data = JSON.parse(responseText);
                console.log('‚úÖ [TEST] SUCCESS with credentials:', testCredentials.username);
                console.log('‚úÖ [TEST] Token received:', data.token ? 'YES' : 'NO');
                console.log('‚úÖ [TEST] User data:', {
                    id: data.id,
                    username: data.username,
                    email: data.email
                });

                Alert.alert(
                    'API Test SUCCESS', 
                    `Working credentials found!\nUsername: ${testCredentials.username}`
                );
                return; // Stop testing after first success
            } else {
                console.log('‚ùå [TEST] Failed with:', testCredentials.username);
            }
            
        } catch (error: any) {
            console.error('‚ùå [TEST] Error with', testCredentials.username, ':', error.message);
        }
    }

    // If all failed
    console.error('‚ùå [TEST] All test credentials failed');
    Alert.alert('API Test', 'All test credentials failed. The API might be down.');
   };

    const toggleShowPassword = () => {
        setShowPassword(!showPassword);
    };

    if (loadingAuth) {
        return (
            <View style={styles.splashContainer}>
                <ActivityIndicator size="large" color="#2e7d32" />
                <Text style={styles.splashText}>Checking authentication...</Text>
            </View>
        );
    }

    return (
        <KeyboardAvoidingView
            style={styles.container}
            behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        >
            <ScrollView
                contentContainerStyle={styles.scrollContent}
                showsVerticalScrollIndicator={false}
            >
                {/* Header */}
                <View style={styles.header}>
                    <FontAwesome6 name="leaf" size={40} color="#ffffff" iconStyle='solid' />
                    <Text style={styles.headerTitle}>Welcome Back!</Text>
                    <Text style={styles.headerSubtitle}>
                        Sign in to your Eco Store account
                    </Text>
                </View>

                {/* Login Form */}
                <View style={styles.form}>
                    <View style={styles.inputGroup}>
                        <Text style={styles.label}>
                            <FontAwesome6 name="user" size={14} color="#2e7d32" iconStyle='solid' /> Username
                        </Text>
                        <TextInput
                            style={[
                                styles.input,
                                errors.username && styles.inputError
                            ]}
                            value={form.username}
                            onChangeText={(value) => handleInputChange('username', value)}
                            placeholder="Enter your username"
                            placeholderTextColor="#999"
                            autoCapitalize="none"
                            autoComplete="username"
                        />
                        {errors.username ? (
                            <Text style={styles.errorText}>
                                <FontAwesome6 name="circle-exclamation" size={12} color="#ff5722" iconStyle='solid' /> {errors.username}
                            </Text>
                        ) : (
                            <Text style={styles.hintText}>
                                <FontAwesome6 name="circle-info" size={12} color="#999" iconStyle='solid' /> Required for DummyJSON API
                            </Text>
                        )}
                    </View>

                    <View style={styles.inputGroup}>
                        <Text style={styles.label}>
                            <FontAwesome6 name="lock" size={14} color="#2e7d32" iconStyle='solid' /> Password
                        </Text>
                        <View style={styles.passwordContainer}>
                            <TextInput
                                style={[
                                    styles.passwordInput,
                                    errors.password && styles.inputError
                                ]}
                                value={form.password}
                                onChangeText={(value) => handleInputChange('password', value)}
                                placeholder="Enter your password"
                                placeholderTextColor="#999"
                                secureTextEntry={!showPassword}
                                autoCapitalize="none"
                                autoComplete="password"
                            />
                            <TouchableOpacity
                                style={styles.eyeButton}
                                onPress={toggleShowPassword}
                            >
                                <FontAwesome6
                                    name={showPassword ? "eye-slash" : "eye"}
                                    size={16}
                                    color="#666"
                                    iconStyle='solid'
                                />
                            </TouchableOpacity>
                        </View>
                        {errors.password && (
                            <Text style={styles.errorText}>
                                <FontAwesome6 name="circle-exclamation" size={12} color="#ff5722" iconStyle='solid' /> {errors.password}
                            </Text>
                        )}
                    </View>

                    <TouchableOpacity style={styles.forgotPassword}>
                        <Text style={styles.forgotPasswordText}>
                            <FontAwesome6 name="key" size={12} color="#2e7d32" iconStyle='solid' /> Forgot Password?
                        </Text>
                    </TouchableOpacity>

                    <TouchableOpacity
                        style={[
                            styles.loginButton,
                            (isLoading || !form.username || !form.password) && styles.loginButtonDisabled
                        ]}
                        onPress={handleLogin}
                        disabled={isLoading || !form.username || !form.password}
                    >
                        {isLoading ? (
                            <ActivityIndicator color="#ffffff" />
                        ) : (
                            <>
                                <FontAwesome6 name="right-to-bracket" size={16} color="#ffffff" iconStyle='solid' />
                                <Text style={styles.loginButtonText}> Sign In</Text>
                            </>
                        )}
                    </TouchableOpacity>

                    {/* Demo Login Button */}
                    <TouchableOpacity
                        style={styles.demoButton}
                        onPress={handleDemoLogin}
                        disabled={isLoading}
                    >
                        <FontAwesome6 name="user-secret" size={14} color="#4caf50" iconStyle='solid' />
                        <Text style={styles.demoButtonText}> Use Test Credentials</Text>
                    </TouchableOpacity>

                    {/* API Test Button (Debug) */}
                    <TouchableOpacity
                        style={styles.testButton}
                        onPress={testDirectAPI}
                    >
                        <FontAwesome6 name="vial" size={14} color="#ff9800" iconStyle='solid' />
                        <Text style={styles.testButtonText}> Test Direct API</Text>
                    </TouchableOpacity>

                    {/* Test Credentials Info */}
                    <View style={styles.credentialsInfo}>
                        <Text style={styles.credentialsTitle}>Test Credentials:</Text>
                        <Text style={styles.credentialsText}>Username: kminchelle</Text>
                        <Text style={styles.credentialsText}>Password: 0lelplR</Text>
                    </View>
                </View>

                {/* Rest of the component remains the same */}
                <View style={styles.signupSection}>
                    <Text style={styles.signupText}>Don't have an account?</Text>
                    <TouchableOpacity>
                        <Text style={styles.signupLink}>Create one now</Text>
                    </TouchableOpacity>
                </View>

                <View style={styles.benefitsSection}>
                    <Text style={styles.benefitsTitle}>Why create an account?</Text>
                    <View style={styles.benefitsList}>
                        <View style={styles.benefitItem}>
                            <FontAwesome6 name="cart-shopping" size={20} color="#2e7d32" iconStyle='solid' />
                            <Text style={styles.benefitText}>Access full product catalog</Text>
                        </View>
                        <View style={styles.benefitItem}>
                            <FontAwesome6 name="credit-card" size={20} color="#2e7d32" iconStyle='solid' />
                            <Text style={styles.benefitText}>Make purchases securely</Text>
                        </View>
                        <View style={styles.benefitItem}>
                            <FontAwesome6 name="truck-fast" size={20} color="#2e7d32" iconStyle='solid' />
                            <Text style={styles.benefitText}>Track your orders</Text>
                        </View>
                        <View style={styles.benefitItem}>
                            <FontAwesome6 name="star" size={20} color="#2e7d32" iconStyle='solid' />
                            <Text style={styles.benefitText}>Earn rewards points</Text>
                        </View>
                    </View>
                </View>
            </ScrollView>
        </KeyboardAvoidingView>
    );
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#f8f9fa',
    },
    scrollContent: {
        flexGrow: 1,
        paddingBottom: 40,
    },
    header: {
        backgroundColor: '#2e7d32',
        padding: 30,
        paddingTop: 50,
        alignItems: 'center',
    },
    headerTitle: {
        fontSize: 28,
        fontWeight: 'bold',
        color: '#ffffff',
        marginBottom: 8,
        textAlign: 'center',
        marginTop: 12,
    },
    headerSubtitle: {
        fontSize: 16,
        color: '#e8f5e9',
        textAlign: 'center',
        opacity: 0.9,
    },
    form: {
        padding: 24,
    },
    inputGroup: {
        marginBottom: 20,
    },
    label: {
        fontSize: 16,
        fontWeight: '600',
        color: '#2e7d32',
        marginBottom: 8,
    },
    input: {
        backgroundColor: '#ffffff',
        borderWidth: 1,
        borderColor: '#ddd',
        borderRadius: 8,
        padding: 16,
        fontSize: 16,
        color: '#333',
    },
    passwordContainer: {
        flexDirection: 'row',
        alignItems: 'center',
    },
    passwordInput: {
        flex: 1,
        backgroundColor: '#ffffff',
        borderWidth: 1,
        borderColor: '#ddd',
        borderRadius: 8,
        padding: 16,
        fontSize: 16,
        color: '#333',
    },
    eyeButton: {
        position: 'absolute',
        right: 16,
        padding: 4,
    },
    inputError: {
        borderColor: '#ff5722',
    },
    errorText: {
        fontSize: 14,
        color: '#ff5722',
        marginTop: 4,
    },
    hintText: {
        fontSize: 12,
        color: '#999',
        marginTop: 4,
    },
    forgotPassword: {
        alignSelf: 'flex-end',
        marginBottom: 24,
    },
    forgotPasswordText: {
        fontSize: 14,
        color: '#2e7d32',
        fontWeight: '500',
    },
    loginButton: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: '#2e7d32',
        padding: 16,
        borderRadius: 8,
        marginBottom: 12,
        elevation: 2,
        shadowColor: '#000',
        shadowOffset: {
            width: 0,
            height: 2,
        },
        shadowOpacity: 0.1,
        shadowRadius: 3.84,
    },
    loginButtonDisabled: {
        backgroundColor: '#a5d6a7',
        opacity: 0.7,
    },
    loginButtonText: {
        color: '#ffffff',
        fontSize: 16,
        fontWeight: '600',
    },
    demoButton: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: 'transparent',
        borderWidth: 1,
        borderColor: '#4caf50',
        padding: 16,
        borderRadius: 8,
        marginBottom: 16,
    },
    demoButtonText: {
        color: '#4caf50',
        fontSize: 14,
        fontWeight: '500',
    },
    testButton: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: 'transparent',
        borderWidth: 1,
        borderColor: '#ff9800',
        padding: 12,
        borderRadius: 8,
        marginBottom: 16,
    },
    testButtonText: {
        color: '#ff9800',
        fontSize: 12,
        fontWeight: '500',
    },
    credentialsInfo: {
        backgroundColor: '#e8f5e9',
        padding: 12,
        borderRadius: 8,
        borderLeftWidth: 4,
        borderLeftColor: '#2e7d32',
    },
    credentialsTitle: {
        fontSize: 14,
        fontWeight: '600',
        color: '#2e7d32',
        marginBottom: 4,
    },
    credentialsText: {
        fontSize: 12,
        color: '#388e3c',
        fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
    },
    signupSection: {
        flexDirection: 'row',
        justifyContent: 'center',
        alignItems: 'center',
        padding: 20,
        gap: 8,
    },
    signupText: {
        fontSize: 14,
        color: '#666',
    },
    signupLink: {
        fontSize: 14,
        color: '#2e7d32',
        fontWeight: '600',
    },
    benefitsSection: {
        padding: 24,
        paddingTop: 0,
    },
    benefitsTitle: {
        fontSize: 18,
        fontWeight: 'bold',
        color: '#2e7d32',
        marginBottom: 16,
        textAlign: 'center',
    },
    benefitsList: {
        gap: 12,
    },
    benefitItem: {
        flexDirection: 'row',
        alignItems: 'center',
        backgroundColor: '#ffffff',
        padding: 16,
        borderRadius: 8,
        elevation: 1,
        shadowColor: '#000',
        shadowOffset: {
            width: 0,
            height: 1,
        },
        shadowOpacity: 0.1,
        shadowRadius: 2.22,
        gap: 12,
    },
    benefitText: {
        fontSize: 14,
        color: '#333',
        fontWeight: '500',
    },
    splashContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#f8f9fa',
    },
    splashText: {
        marginTop: 16,
        fontSize: 16,
        color: '#2e7d32',
    },
});

export default LoginScreen;./screens/auth/TestErrorScreen.tsx
==== ./screens/auth/TestErrorScreen.tsx ====
import React from 'react';
import { 
  View, Text, TouchableOpacity, StyleSheet, ScrollView 
} from 'react-native';
import { useNavigation } from '@react-navigation/native';

const TestErrorScreen: React.FC = () => {
  const navigation = useNavigation();
  const [testMode, setTestMode] = React.useState<'safe' | 'error'>('safe');

  const goToHome = () => {
    navigation.navigate('Home' as never);
  };

  if (testMode === 'error') {
    console.log('üí• RENDERING ERROR VERSION');
    // VERSION WITH ERROR - untuk test Error Boundary
    const problematicObject: any = null;
    return (
      <View>
        <Text>{problematicObject.nonExistentProperty}</Text>
      </View>
    );
  }

  // SAFE MODE - langsung tampilkan opsi untuk ke Home
  return (
    <ScrollView style={styles.container}>
      <View style={styles.content}>
        <Text style={styles.title}>üß™ Test Error Boundary</Text>
        <Text style={styles.subtitle}>
          Pilih mode yang ingin di-test
        </Text>

        <View style={styles.modeContainer}>
          {/* MODE AMAN - langsung ke Home */}
          <View style={[styles.modeCard, styles.safeCard]}>
            <Text style={styles.modeTitle}>üîí Mode Aman</Text>
            <Text style={styles.modeDescription}>
              Langsung kembali ke Home Screen tanpa error
            </Text>
            <TouchableOpacity 
              style={[styles.button, styles.safeButton]}
              onPress={goToHome}
            >
              <Text style={styles.buttonText}>Ke Home Screen</Text>
            </TouchableOpacity>
          </View>

          {/* MODE ERROR - test Error Boundary */}
          <View style={[styles.modeCard, styles.errorCard]}>
            <Text style={styles.modeTitle}>üö® Mode Error</Text>
            <Text style={styles.modeDescription}>
              Test Error Boundary dengan memicu error
            </Text>
            <TouchableOpacity 
              style={[styles.button, styles.errorButton]}
              onPress={() => setTestMode('error')}
            >
              <Text style={styles.buttonText}>Test Error Boundary</Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.infoBox}>
          <Text style={styles.infoTitle}>Cara Test Error Boundary:</Text>
          <Text style={styles.infoText}>
            1. Pilih "Mode Error"{'\n'}
            2. Error terjadi ‚Üí Error Boundary aktif{'\n'}
            3. Tampil fallback UI dengan tombol{'\n'}
            4. Klik "Mulai Ulang" untuk reset aplikasi{'\n'}
            5. Kembali ke screen ini
          </Text>
        </View>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  content: {
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#2e7d32',
    textAlign: 'center',
    marginBottom: 10,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 30,
  },
  modeContainer: {
    gap: 20,
    marginBottom: 30,
  },
  modeCard: {
    padding: 20,
    borderRadius: 12,
    borderWidth: 2,
    alignItems: 'center',
  },
  safeCard: {
    backgroundColor: '#e8f5e8',
    borderColor: '#2e7d32',
  },
  errorCard: {
    backgroundColor: '#ffebee',
    borderColor: '#d32f2f',
  },
  modeTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  
  modeDescription: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
    marginBottom: 16,
    lineHeight: 20,
  },
  button: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    minWidth: 160,
    alignItems: 'center',
  },
  safeButton: {
    backgroundColor: '#2e7d32',
  },
  errorButton: {
    backgroundColor: '#d32f2f',
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  infoBox: {
    backgroundColor: '#e3f2fd',
    padding: 16,
    borderRadius: 8,
    borderLeftWidth: 4,
    borderLeftColor: '#2196f3',
  },
  infoTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#2196f3',
    marginBottom: 8,
  },
  infoText: {
    fontSize: 14,
    color: '#333',
    lineHeight: 20,
  },
});

export default TestErrorScreen;./screens/categories/Automotive.tsx
==== ./screens/categories/Automotive.tsx ====
import React from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  FlatList,
  Image,
  SafeAreaView,
} from 'react-native';
import { initialProducts } from '../../data/initialProducts';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList } from '../../types';
import WishlistButton from '../../routes/WishlistButton';

export default function Automotive() {
  const automotiveProducts = initialProducts.filter(product =>

    product.category === 'automotive' ||
    product.name.toLowerCase().includes('car') ||
    product.name.toLowerCase().includes('bike') ||
    product.name.toLowerCase().includes('accessories') ||
    product.name.toLowerCase().includes('tools')
  );

  const navigation = useNavigation<NativeStackNavigationProp<HomeStackParamList>>();

  const handleProductPress = (productId: string) => {
    navigation.navigate('ProductDetail', { productId });
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>üöó Otomotif</Text>
      <Text style={styles.subtitle}>
        {automotiveProducts.length} produk otomotif & aksesori
      </Text>
      
      <FlatList
        data={automotiveProducts}
        renderItem={({ item }) => (
          <TouchableOpacity 
            style={styles.productCard}
            onPress={() => handleProductPress(item.id)}
          >
            <Image source={{ uri: item.image }} style={styles.productImage} />
            <View style={styles.productInfo}>
              <Text style={styles.productName} numberOfLines={2}>{item.name}</Text>
              <Text style={styles.productPrice}>${item.price.toLocaleString()}</Text>
              <Text style={styles.productCategory}>{item.category}</Text>
            </View>
          </TouchableOpacity>
        )}
        keyExtractor={(item) => item.id}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.listContent}
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>Belum ada produk otomotif</Text>
          </View>
        }
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#9bf89bff',
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    marginBottom: 20,
  },
  listContent: {
    paddingBottom: 20,
  },
  productCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    marginBottom: 16,
    padding: 12,
    flexDirection: 'row',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
  },
  productImage: {
    width: 80,
    height: 80,
    borderRadius: 8,
  },
  productInfo: {
    flex: 1,
    marginLeft: 12,
    justifyContent: 'center',
  },
  productName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 4,
  },
  productPrice: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 4,
  },
  productCategory: {
    fontSize: 12,
    color: '#666',
    textTransform: 'capitalize',
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 40,
  },
  emptyText: {
    fontSize: 16,
    color: '#4caf50',
    opacity: 0.7,
  },
});
./screens/categories/Baby.tsx
==== ./screens/categories/Baby.tsx ====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  Image,
  SafeAreaView,
  ActivityIndicator,
  Alert,
  TextInput,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList, Product } from '../../types';
import { productApi } from '../../services/api/productApi';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';
import WishlistButton from '../../routes/WishlistButton';

export default function Baby() {
  const navigation = useNavigation<NativeStackNavigationProp<HomeStackParamList>>();
  
  const [babyProducts, setBabyProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [refreshing, setRefreshing] = useState(false);
  const [selectedCategory, setSelectedCategory] = useState<string>('all');

  // Kategori dan keywords untuk produk bayi & anak
  const babyCategories = [
    'all',
    'baby-care',
    'toys',
    'kids-fashion',
    'nursery',
    'feeding'
  ];

  const babyKeywords = [
    'baby', 'kids', 'toy', 'diaper', 'stroller', 'crib', 'pacifier',
    'bottle', 'feeding', 'nursery', 'child', 'infant', 'toddler',
    'play', 'educational', 'safety', 'care', 'bath', 'clothing',
    'onesie', 'bib', 'rattle', 'teether', 'walker', 'car seat'
  ];

  // Kategorisasi produk bayi berdasarkan konten
  const getProductCategory = (product: Product): string => {
    const name = product.name.toLowerCase();
    const desc = product.description.toLowerCase();
    
    if (name.includes('toy') || desc.includes('toy') || name.includes('play')) {
      return 'toys';
    } else if (name.includes('cream') || desc.includes('care') || name.includes('lotion')) {
      return 'baby-care';
    } else if (name.includes('clothing') || desc.includes('wear') || name.includes('onesie')) {
      return 'kids-fashion';
    } else if (name.includes('crib') || desc.includes('nursery') || name.includes('stroller')) {
      return 'nursery';
    } else if (name.includes('bottle') || desc.includes('feeding') || name.includes('food')) {
      return 'feeding';
    }
    
    return 'baby-care';
  };

  useEffect(() => {
    loadBabyProducts();
  }, []);

  const loadBabyProducts = async () => {
    try {
      setLoading(true);
      setError(null);
      
      console.log('üë∂ Loading baby products...');
      
      // Ambil semua produk dari API
      const allProducts = await productApi.getAllProducts();
      
      console.log('üì¶ Total products received:', allProducts.length);
      
      // Filter produk untuk kategori bayi & anak
      const filteredProducts = allProducts.filter(product => 
        isBabyProduct(product)
      );
      
      console.log('üß∏ Baby products found:', filteredProducts.length);
      
      setBabyProducts(filteredProducts);
      
    } catch (err: any) {
      console.error('‚ùå Error loading baby products:', err);
      setError(err.message || 'Failed to load baby products');
      Alert.alert('Error', 'Failed to load baby products');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const isBabyProduct = (product: Product): boolean => {
    const productName = product.name.toLowerCase();
    const productCategory = product.category.toLowerCase();
    const productDescription = product.description.toLowerCase();
    
    // Check jika nama/deskripsi mengandung keyword bayi & anak
    const hasBabyKeyword = babyKeywords.some(keyword =>
      productName.includes(keyword) || productDescription.includes(keyword)
    );
    
    // Untuk DummyJSON, kita akan consider beberapa kategori sebagai produk bayi
    // berdasarkan kesesuaian dengan kebutuhan bayi & anak
    const isSuitableForBaby = 
      productCategory.includes('skincare') && (
        productName.includes('baby') || productDescription.includes('baby')
      ) ||
      productCategory.includes('home-decoration') && (
        productName.includes('nursery') || productDescription.includes('baby')
      ) ||
      productCategory.includes('groceries') && (
        productName.includes('baby') || productDescription.includes('infant')
      );
    
    return hasBabyKeyword || isSuitableForBaby;
  };

  const handleRefresh = () => {
    setRefreshing(true);
    loadBabyProducts();
  };

  const handleProductPress = (productId: string) => {
    navigation.navigate('ProductDetail', { productId });
  };

  const handleSearch = (text: string) => {
    setSearchQuery(text);
  };

  const handleCategoryPress = (category: string) => {
    setSelectedCategory(category);
  };

  // Filter products berdasarkan search query dan kategori
  const filteredProducts = babyProducts.filter(product => {
    const matchesSearch = 
      product.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      product.description.toLowerCase().includes(searchQuery.toLowerCase()) ||
      (product.brand && product.brand.toLowerCase().includes(searchQuery.toLowerCase()));
    
    const matchesCategory = selectedCategory === 'all' || 
      getProductCategory(product) === selectedCategory;
    
    return matchesSearch && matchesCategory;
  });

  const getCategoryDisplayName = (category: string): string => {
    const categoryMap: { [key: string]: string } = {
      'all': 'All',
      'baby-care': 'Baby Care',
      'toys': 'Toys & Play',
      'kids-fashion': "Kids' Fashion",
      'nursery': 'Nursery',
      'feeding': 'Feeding'
    };
    
    return categoryMap[category] || category;
  };

  // Gunakan icon yang benar-benar valid dari FontAwesome6
  const getCategoryIcon = (category: string) => {
    const iconMap: { [key: string]: string } = {
      'all': 'th-large', // Grid icon
      'baby-care': 'heart', // Heart icon
      'toys': 'gamepad', // Gamepad icon
      'kids-fashion': 'shirt', // T-shirt icon
      'nursery': 'home', // Home icon
      'feeding': 'wine-bottle' // Bottle icon
    };
    
    return (iconMap[category] || 'circle') as any;
  };  

  const renderProductItem = ({ item }: { item: Product }) => (
    <TouchableOpacity 
      style={styles.productCard}
      onPress={() => handleProductPress(item.id)}
    >
      <Image 
        source={{ uri: item.image }} 
        style={styles.productImage}
        resizeMode="cover"
      />

      <View style={styles.wishlistButtonContainer}>
        <WishlistButton product={item} size={20} />
      </View>
      
      <View style={styles.productInfo}>
        <Text style={styles.productName} numberOfLines={2}>{item.name}</Text>
        
        {item.brand && (
          <Text style={styles.productBrand}>{item.brand}</Text>
        )}
        
        <Text style={styles.productDescription} numberOfLines={2}>
          {item.description}
        </Text>
        
        <View style={styles.priceContainer}>
          <Text style={styles.productPrice}>${item.price.toLocaleString()}</Text>
          {item.discount && item.discount > 0 && (
            <Text style={styles.discountBadge}>{Math.round(item.discount)}% OFF</Text>
          )}
        </View>
        
        <View style={styles.productMeta}>
          <View style={styles.categoryTag}>
            <FontAwesome6 
              name={getCategoryIcon(getProductCategory(item))} 
              size={10} 
              color="#6b7280" 
            />
            <Text style={styles.productCategory}>
              {getCategoryDisplayName(getProductCategory(item))}
            </Text>
          </View>
          {item.isNew && (
            <View style={styles.newBadge}>
              <Text style={styles.newBadgeText}>NEW</Text>
            </View>
          )}
        </View>
        
        {item.stock !== undefined && (
          <Text style={[
            styles.stockText,
            item.stock < 10 ? styles.lowStock : styles.inStock
          ]}>
            {item.stock > 10 ? 'In Stock' : `Only ${item.stock} left`}
          </Text>
        )}
        
        {/* Safety badge untuk produk bayi */}
        {(item.name.toLowerCase().includes('baby') || item.description.toLowerCase().includes('baby')) && (
          <View style={styles.safetyBadge}>            
            <FontAwesome6 name="shield" size={10} color="#059669" iconStyle='solid' />
            <Text style={styles.safetyText}>Baby Safe</Text>          
          </View>
        )}
      </View>
    </TouchableOpacity>
  );

  const renderCategoryChip = ({ item }: { item: string }) => (
    <TouchableOpacity
      style={[
        styles.categoryChip,
        selectedCategory === item && styles.categoryChipSelected
      ]}
      onPress={() => handleCategoryPress(item)}
    >
      <FontAwesome6 
        name={getCategoryIcon(item)} 
        size={14} 
        color={selectedCategory === item ? '#ffffff' : '#6b7280'} 
      />
      <Text style={[
        styles.categoryChipText,
        selectedCategory === item && styles.categoryChipTextSelected
      ]}>
        {getCategoryDisplayName(item)}
      </Text>
    </TouchableOpacity>
  );

  if (loading && !refreshing) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#f472b6" />
        <Text style={styles.loadingText}>Loading baby products...</Text>
      </View>
    );
  }

  if (error && babyProducts.length === 0) {
    return (
      <View style={styles.errorContainer}>
        <FontAwesome6 name="child" size={50} color="#ef4444" iconStyle='solid' />
        <Text style={styles.errorTitle}>Failed to Load</Text>
        <Text style={styles.errorMessage}>{error}</Text>
        <TouchableOpacity style={styles.retryButton} onPress={loadBabyProducts}>
          <Text style={styles.retryButtonText}>Try Again</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <View>
          <Text style={styles.title}>üë∂ Baby & Kids</Text>
          <Text style={styles.subtitle}>
            Everything for your little one's needs
          </Text>
        </View>
      </View>

      {/* Search Bar */}
      <View style={styles.searchContainer}>
        <Text style={styles.searchIcon}>üîç</Text>
        <TextInput
          style={styles.searchInput}
          placeholder="Search toys, care products, nursery..."
          placeholderTextColor="#9ca3af"
          value={searchQuery}
          onChangeText={handleSearch}
        />
        {searchQuery ? (
          <TouchableOpacity onPress={() => setSearchQuery('')}>
            <Text style={styles.clearIcon}>‚úï</Text>
          </TouchableOpacity>
        ) : null}
      </View>

      {/* Categories */}
      <View style={styles.categoriesSection}>
        <Text style={styles.categoriesTitle}>Categories</Text>
        <FlatList
          data={babyCategories}
          renderItem={renderCategoryChip}
          keyExtractor={(item) => item}
          horizontal
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.categoriesList}
        />
      </View>

      {/* Products List */}
      <FlatList
        data={filteredProducts}
        renderItem={renderProductItem}
        keyExtractor={(item) => item.id}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.listContent}
        refreshing={refreshing}
        onRefresh={handleRefresh}
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyIcon}>üë∂</Text>
            <Text style={styles.emptyTitle}>
              {searchQuery || selectedCategory !== 'all' 
                ? 'No products found' 
                : 'No baby products available'
              }
            </Text>
            <Text style={styles.emptySubtitle}>
              {searchQuery 
                ? 'Try adjusting your search terms'
                : selectedCategory !== 'all'
                ? `No products in ${getCategoryDisplayName(selectedCategory)} category`
                : 'Check back later for new arrivals'
              }
            </Text>
            {(searchQuery || selectedCategory !== 'all') && (
              <TouchableOpacity 
                style={styles.clearFilterButton}
                onPress={() => {
                  setSearchQuery('');
                  setSelectedCategory('all');
                }}
              >
                <Text style={styles.clearFilterText}>Clear Filters</Text>
              </TouchableOpacity>
            )}
          </View>
        }
        ListHeaderComponent={
          filteredProducts.length > 0 ? (
            <View style={styles.resultsInfo}>
              <Text style={styles.resultsText}>
                Showing {filteredProducts.length} of {babyProducts.length} products
                {selectedCategory !== 'all' && ` in ${getCategoryDisplayName(selectedCategory)}`}
              </Text>
              <View style={styles.safetyNotice}>
                <Text style={styles.safetyIcon}>üõ°Ô∏è</Text>
                <Text style={styles.safetyNoticeText}>
                  All products are carefully selected for baby safety
                </Text>
              </View>
            </View>
          ) : null
        }
      />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#9bf89bff',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8fafc',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#6b7280',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8fafc',
    padding: 20,
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#111827',
    marginTop: 16,
    marginBottom: 8,
  },
  errorMessage: {
    fontSize: 16,
    color: '#6b7280',
    textAlign: 'center',
    marginBottom: 24,
  },
  retryButton: {
    backgroundColor: '#f472b6',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  header: {
    padding: 20,
    paddingBottom: 12,
    backgroundColor: '#9bf89bff',
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  title: {
    fontSize: 24,
    fontWeight: '700',
    color: '#111827',
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 14,
    color: '#6b7280',
    fontWeight: '500',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    margin: 16,
    marginTop: 8,
    marginBottom: 8,
    padding: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#e5e7eb',
    gap: 12,
  },
  searchIcon: {
    fontSize: 16,
    color: '#6b7280',
  },
  searchInput: {
    flex: 1,
    fontSize: 16,
    color: '#111827',
  },
  clearIcon: {
    fontSize: 16,
    color: '#6b7280',
  },
  categoriesSection: {
    backgroundColor: '#32a538ff',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  categoriesTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#e8ecf7ff',
    marginBottom: 12,
  },
  categoriesList: {
    gap: 8,
  },
  categoryChip: {
    backgroundColor: '#f3f4f6',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    marginRight: 8,
    borderWidth: 1,
    borderColor: '#e5e7eb',
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  categoryChipSelected: {
    backgroundColor: '#10b981',
    borderColor: '#10b981',
  },
  categoryChipText: {
    fontSize: 14,
    color: '#374151',
    fontWeight: '500',
  },
  categoryChipTextSelected: {
    color: '#ffffff',
    fontWeight: '600',
  },
  listContent: {
    padding: 16,
    paddingTop: 8,
  },
  resultsInfo: {
    marginBottom: 16,
  },
  resultsText: {
    fontSize: 14,
    color: '#6b7280',
    fontWeight: '500',
    marginBottom: 8,
  },
  safetyNotice: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0fdf4',
    padding: 8,
    borderRadius: 6,
    gap: 6,
  },
  safetyIcon: {
    fontSize: 14,
  },
  safetyNoticeText: {
    fontSize: 12,
    color: '#059669',
    fontWeight: '500',
  },
  productCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    marginBottom: 16,
    padding: 16,
    flexDirection: 'row',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
    elevation: 3,
    borderWidth: 1,
    borderColor: '#f3f4f6',
  },
  productImage: {
    width: 80,
    height: 80,
    borderRadius: 8,
  },
  wishlistButtonContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
    zIndex: 1,
  },
  productInfo: {
    flex: 1,
    marginLeft: 12,
  },
  productName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#111827',
    marginBottom: 4,
  },
  productBrand: {
    fontSize: 12,
    color: '#6b7280',
    marginBottom: 4,
    fontWeight: '500',
  },
  productDescription: {
    fontSize: 12,
    color: '#6b7280',
    marginBottom: 8,
    lineHeight: 16,
  },
  priceContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
    gap: 8,
  },
  productPrice: {
    fontSize: 18,
    fontWeight: '700',
    color: '#059669',
  },
  discountBadge: {
    fontSize: 12,
    fontWeight: '600',
    color: '#ffffff',
    backgroundColor: '#ef4444',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 4,
  },
  productMeta: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 4,
  },
  categoryTag: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  productCategory: {
    fontSize: 12,
    color: '#6b7280',
    fontWeight: '500',
  },
  newBadge: {
    backgroundColor: '#f472b6',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 4,
  },
  newBadgeText: {
    fontSize: 10,
    color: '#ffffff',
    fontWeight: '600',
  },
  stockText: {
    fontSize: 12,
    fontWeight: '500',
    marginBottom: 4,
  },
  inStock: {
    color: '#059669',
  },
  lowStock: {
    color: '#ef4444',
  },
  safetyBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0fdf4',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 4,
    alignSelf: 'flex-start',
    gap: 4,
  },
  safetyText: {
    fontSize: 10,
    color: '#059669',
    fontWeight: '600',
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 60,
  },
  emptyIcon: {
    fontSize: 60,
    marginBottom: 16,
  },
  emptyTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#374151',
    marginBottom: 8,
    textAlign: 'center',
  },
  emptySubtitle: {
    fontSize: 14,
    color: '#6b7280',
    textAlign: 'center',
    marginBottom: 20,
  },
  clearFilterButton: {
    backgroundColor: '#f3f4f6',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 6,
  },
  clearFilterText: {
    fontSize: 14,
    color: '#374151',
    fontWeight: '500',
  },
});./screens/categories/Clothing.tsx
==== ./screens/categories/Clothing.tsx ====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  Image,
  SafeAreaView,
  ActivityIndicator,
  Alert,
  TextInput,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList, Product } from '../../types';
import { productApi } from '../../services/api/productApi';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';
import WishlistButton from '../../routes/WishlistButton';

export default function Clothing() {
  const navigation = useNavigation<NativeStackNavigationProp<HomeStackParamList>>();
  
  const [clothingProducts, setClothingProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [refreshing, setRefreshing] = useState(false);
  const [selectedCategory, setSelectedCategory] = useState<string>('all');

  // Kategori fashion dari DummyJSON
  const fashionCategories = [
    'all',
    'tops',
    'womens-dresses',
    'womens-shoes',
    'mens-shirts',
    'mens-shoes',
    'mens-watches',
    'womens-watches',
    'womens-bags',
    'womens-jewellery',
    'sunglasses'
  ];

  // Keywords untuk produk fashion
  const fashionKeywords = [
    'shirt', 'dress', 'jeans', 'jacket', 'pants', 'skirt', 'top',
    'shoes', 'bag', 'jewelry', 'watch', 'sunglasses', 'accessory',
    'fashion', 'clothing', 'apparel', 'wear', 'outfit'
  ];

  useEffect(() => {
    loadClothingProducts();
  }, []);

  const loadClothingProducts = async () => {
    try {
      setLoading(true);
      setError(null);
      
      console.log('üëï Loading clothing products...');
      
      // Ambil semua produk dari API
      const allProducts = await productApi.getAllProducts();
      
      console.log('üì¶ Total products received:', allProducts.length);
      
      // Filter produk untuk kategori fashion/clothing
      const filteredProducts = allProducts.filter(product => 
        isFashionProduct(product)
      );
      
      console.log('üëö Clothing products found:', filteredProducts.length);
      
      setClothingProducts(filteredProducts);
      
    } catch (err: any) {
      console.error('‚ùå Error loading clothing products:', err);
      setError(err.message || 'Failed to load clothing products');
      Alert.alert('Error', 'Failed to load clothing products');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const isFashionProduct = (product: Product): boolean => {
    const productName = product.name.toLowerCase();
    const productCategory = product.category.toLowerCase();
    const productDescription = product.description.toLowerCase();
    
    // Check jika termasuk dalam kategori fashion DummyJSON
    const isFashionCategory = fashionCategories.some(category => 
      productCategory.includes(category) && category !== 'all'
    );
    
    // Check jika nama/deskripsi mengandung keyword fashion
    const hasFashionKeyword = fashionKeywords.some(keyword =>
      productName.includes(keyword) || productDescription.includes(keyword)
    );
    
    return isFashionCategory || hasFashionKeyword;
  };

  const handleRefresh = () => {
    setRefreshing(true);
    loadClothingProducts();
  };

  const handleProductPress = (productId: string) => {
    navigation.navigate('ProductDetail', { productId });
  };

  const handleSearch = (text: string) => {
    setSearchQuery(text);
  };

  const handleCategoryPress = (category: string) => {
    setSelectedCategory(category);
  };

  // Filter products berdasarkan search query dan kategori
  const filteredProducts = clothingProducts.filter(product => {
    const matchesSearch = 
      product.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      product.description.toLowerCase().includes(searchQuery.toLowerCase()) ||
      (product.brand && product.brand.toLowerCase().includes(searchQuery.toLowerCase()));
    
    const matchesCategory = 
      selectedCategory === 'all' || 
      product.category.toLowerCase().includes(selectedCategory);
    
    return matchesSearch && matchesCategory;
  });

  const getCategoryDisplayName = (category: string): string => {
    const categoryMap: { [key: string]: string } = {
      'all': 'All',
      'tops': 'Tops',
      'womens-dresses': 'Dresses',
      'womens-shoes': "Women's Shoes",
      'mens-shirts': "Men's Shirts",
      'mens-shoes': "Men's Shoes",
      'mens-watches': "Men's Watches",
      'womens-watches': "Women's Watches",
      'womens-bags': "Women's Bags",
      'womens-jewellery': 'Jewelry',
      'sunglasses': 'Sunglasses'
    };
    
    return categoryMap[category] || category;
  };

  const renderProductItem = ({ item }: { item: Product }) => (
    <TouchableOpacity 
      style={styles.productCard}
      onPress={() => handleProductPress(item.id)}
    >
      <Image 
        source={{ uri: item.image }} 
        style={styles.productImage}
        resizeMode="cover"
      />

      <View style={styles.wishlistButtonContainer}>
        <WishlistButton product={item} size={20} />
      </View>
      
      <View style={styles.productInfo}>
        <Text style={styles.productName} numberOfLines={2}>{item.name}</Text>
        
        {item.brand && (
          <Text style={styles.productBrand}>{item.brand}</Text>
        )}
        
        <Text style={styles.productDescription} numberOfLines={2}>
          {item.description}
        </Text>
        
        <View style={styles.priceContainer}>
          <Text style={styles.productPrice}>${item.price.toLocaleString()}</Text>
          {item.discount && item.discount > 0 && (
            <Text style={styles.discountBadge}>{Math.round(item.discount)}% OFF</Text>
          )}
        </View>
        
        <View style={styles.productMeta}>
          <Text style={styles.productCategory}>
            {getCategoryDisplayName(item.category)}
          </Text>
          {item.isNew && (
            <View style={styles.newBadge}>
              <Text style={styles.newBadgeText}>NEW</Text>
            </View>
          )}
        </View>
        
        {item.stock !== undefined && (
          <Text style={[
            styles.stockText,
            item.stock < 10 ? styles.lowStock : styles.inStock
          ]}>
            {item.stock > 10 ? 'In Stock' : `Only ${item.stock} left`}
          </Text>
        )}
      </View>
    </TouchableOpacity>
  );

  const renderCategoryChip = ({ item }: { item: string }) => (
    <TouchableOpacity
      style={[
        styles.categoryChip,
        selectedCategory === item && styles.categoryChipSelected
      ]}
      onPress={() => handleCategoryPress(item)}
    >
      <Text style={[
        styles.categoryChipText,
        selectedCategory === item && styles.categoryChipTextSelected
      ]}>
        {getCategoryDisplayName(item)}
      </Text>
    </TouchableOpacity>
  );

  if (loading && !refreshing) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#10b981" />
        <Text style={styles.loadingText}>Loading fashion collection...</Text>
      </View>
    );
  }

  if (error && clothingProducts.length === 0) {
    return (
      <View style={styles.errorContainer}>
        <FontAwesome6 name="shirt" size={50} color="#ef4444" iconStyle='solid' />
        <Text style={styles.errorTitle}>Failed to Load</Text>
        <Text style={styles.errorMessage}>{error}</Text>
        <TouchableOpacity style={styles.retryButton} onPress={loadClothingProducts}>
          <Text style={styles.retryButtonText}>Try Again</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <View>
          <Text style={styles.title}>üëï Fashion & Clothing</Text>
          <Text style={styles.subtitle}>
            Discover the latest trends and styles
          </Text>
        </View>
      </View>

      {/* Search Bar */}
      <View style={styles.searchContainer}>
        <FontAwesome6 name="magnifying-glass" size={16} color="#6b7280" iconStyle='solid' />
        <TextInput
          style={styles.searchInput}
          placeholder="Search dresses, shirts, shoes..."
          placeholderTextColor="#9ca3af"
          value={searchQuery}
          onChangeText={handleSearch}
        />
        {searchQuery ? (
          <TouchableOpacity onPress={() => setSearchQuery('')}>
            <FontAwesome6 name="xmark" size={16} color="#6b7280" iconStyle='solid' />
          </TouchableOpacity>
        ) : null}
      </View>

      {/* Categories */}
      <View style={styles.categoriesSection}>
        <Text style={styles.categoriesTitle}>Categories</Text>
        <FlatList
          data={fashionCategories}
          renderItem={renderCategoryChip}
          keyExtractor={(item) => item}
          horizontal
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.categoriesList}
        />
      </View>

      {/* Products List */}
      <FlatList
        data={filteredProducts}
        renderItem={renderProductItem}
        keyExtractor={(item) => item.id}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.listContent}
        refreshing={refreshing}
        onRefresh={handleRefresh}
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <FontAwesome6 name="shirt" size={60} color="#d1d5db" iconStyle='solid' />
            <Text style={styles.emptyTitle}>
              {searchQuery || selectedCategory !== 'all' 
                ? 'No products found' 
                : 'No clothing products available'
              }
            </Text>
            <Text style={styles.emptySubtitle}>
              {searchQuery 
                ? 'Try adjusting your search terms'
                : selectedCategory !== 'all'
                ? `No products in ${getCategoryDisplayName(selectedCategory)} category`
                : 'Check back later for new arrivals'
              }
            </Text>
            {(searchQuery || selectedCategory !== 'all') && (
              <TouchableOpacity 
                style={styles.clearFilterButton}
                onPress={() => {
                  setSearchQuery('');
                  setSelectedCategory('all');
                }}
              >
                <Text style={styles.clearFilterText}>Clear Filters</Text>
              </TouchableOpacity>
            )}
          </View>
        }
        ListHeaderComponent={
          filteredProducts.length > 0 ? (
            <View style={styles.resultsInfo}>
              <Text style={styles.resultsText}>
                Showing {filteredProducts.length} of {clothingProducts.length} products
                {selectedCategory !== 'all' && ` in ${getCategoryDisplayName(selectedCategory)}`}
              </Text>
            </View>
          ) : null
        }
      />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#9bf89bff',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8fafc',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#6b7280',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8fafc',
    padding: 20,
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#111827',
    marginTop: 16,
    marginBottom: 8,
  },
  errorMessage: {
    fontSize: 16,
    color: '#6b7280',
    textAlign: 'center',
    marginBottom: 24,
  },
  retryButton: {
    backgroundColor: '#10b981',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  header: {
    padding: 20,
    paddingBottom: 12,
    backgroundColor: '#9bf89bff',
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  title: {
    fontSize: 24,
    fontWeight: '700',
    color: '#111827',
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 14,
    color: '#6b7280',
    fontWeight: '500',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    margin: 16,
    marginTop: 8,
    marginBottom: 8,
    padding: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#e5e7eb',
    gap: 12,
  },
  searchInput: {
    flex: 1,
    fontSize: 16,
    color: '#111827',
  },
  categoriesSection: {
    backgroundColor: '#32a538ff',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  categoriesTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#f5f6f8ff',
    marginBottom: 12,
  },
  categoriesList: {
    gap: 8,
  },
  categoryChip: {
    backgroundColor: '#f3f4f6',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    marginRight: 8,
    borderWidth: 1,
    borderColor: '#e5e7eb',
  },
  categoryChipSelected: {
    backgroundColor: '#10b981',
    borderColor: '#10b981',
  },
  categoryChipText: {
    fontSize: 14,
    color: '#374151',
    fontWeight: '500',
  },
  categoryChipTextSelected: {
    color: '#ffffff',
    fontWeight: '600',
  },
  listContent: {
    padding: 16,
    paddingTop: 8,
  },
  resultsInfo: {
    marginBottom: 16,
  },
  resultsText: {
    fontSize: 14,
    color: '#6b7280',
    fontWeight: '500',
  },
  productCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    marginBottom: 16,
    padding: 16,
    flexDirection: 'row',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
    elevation: 3,
    borderWidth: 1,
    borderColor: '#f3f4f6',
  },
  productImage: {
    width: 80,
    height: 80,
    borderRadius: 8,
  },
  wishlistButtonContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
    zIndex: 1,
  },
  productInfo: {
    flex: 1,
    marginLeft: 12,
  },
  productName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#111827',
    marginBottom: 4,
  },
  productBrand: {
    fontSize: 12,
    color: '#6b7280',
    marginBottom: 4,
    fontWeight: '500',
  },
  productDescription: {
    fontSize: 12,
    color: '#6b7280',
    marginBottom: 8,
    lineHeight: 16,
  },
  priceContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
    gap: 8,
  },
  productPrice: {
    fontSize: 18,
    fontWeight: '700',
    color: '#059669',
  },
  discountBadge: {
    fontSize: 12,
    fontWeight: '600',
    color: '#ffffff',
    backgroundColor: '#ef4444',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 4,
  },
  productMeta: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 4,
  },
  productCategory: {
    fontSize: 12,
    color: '#6b7280',
    textTransform: 'capitalize',
    fontWeight: '500',
  },
  newBadge: {
    backgroundColor: '#10b981',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 4,
  },
  newBadgeText: {
    fontSize: 10,
    color: '#ffffff',
    fontWeight: '600',
  },
  stockText: {
    fontSize: 12,
    fontWeight: '500',
  },
  inStock: {
    color: '#059669',
  },
  lowStock: {
    color: '#ef4444',
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 60,
  },
  emptyTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#374151',
    marginTop: 16,
    marginBottom: 8,
  },
  emptySubtitle: {
    fontSize: 14,
    color: '#6b7280',
    textAlign: 'center',
    marginBottom: 20,
  },
  clearFilterButton: {
    backgroundColor: '#f3f4f6',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 6,
  },
  clearFilterText: {
    fontSize: 14,
    color: '#374151',
    fontWeight: '500',
  },
});./screens/categories/Discount.tsx
==== ./screens/categories/Discount.tsx ====
import React, { useState, useCallback, useEffect } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  TouchableOpacity,
  Image,
  RefreshControl,
  Alert,
  ActivityIndicator
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList } from '../../types';
import { productApi } from '../../services/api/productApi';
import { Product } from '../../types';
import WishlistButton from '../../routes/WishlistButton';

type DiscountScreenNavigationProp = NativeStackNavigationProp<HomeStackParamList>;

const DiscountScreen = () => {
  const navigation = useNavigation<DiscountScreenNavigationProp>();

  const [discountProducts, setDiscountProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [refreshing, setRefreshing] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  // Fetch discount products dari API
  const fetchDiscountProducts = async () => {
    try {
      setError(null);
      const allProducts = await productApi.getAllProducts();

      // Filter produk yang memiliki diskon
      // Asumsi: produk diskon memiliki property discount > 0
      const discountedProducts = allProducts.filter(product =>
        product.discount && product.discount > 0
      );

      setDiscountProducts(discountedProducts);
    } catch (err) {
      setError('Failed to load discount products');
      console.error('Error fetching discount products:', err);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // Load data pertama kali
  useEffect(() => {
    fetchDiscountProducts();
  }, []);

  const onRefresh = useCallback(() => {
    setRefreshing(true);
    fetchDiscountProducts();
  }, []);

  const handleProductPress = (productId: string) => {
    navigation.navigate('ProductDetail', { productId });
  };

  const calculateDiscountedPrice = (price: number, discount: number) => {
    return price * (1 - discount / 100);
  };

  // Komponen untuk product item dengan image error handling
  const ProductItem = ({ item }: { item: Product }) => {
    const [imageError, setImageError] = useState(false);

    return (
      <TouchableOpacity
        style={styles.productCard}
        onPress={() => handleProductPress(item.id)}
      >
        {imageError ? (
          <View style={[styles.productImage, styles.placeholderContainer]}>
            <Text style={styles.placeholderText}>üè∑Ô∏è</Text>
            <Text style={styles.placeholderSubtext}>Sale</Text>
          </View>
        ) : (
          <Image
            source={{ uri: item.image }}
            style={styles.productImage}
            resizeMode="cover"
            onError={() => setImageError(true)}
          />
        )}

        <View style={styles.wishlistButtonContainer}>
          <WishlistButton product={item} size={20} />
        </View>

        <View style={styles.productInfo}>
          <Text style={styles.productName} numberOfLines={2}>{item.name}</Text>

          <View style={styles.priceContainer}>
            <Text style={styles.originalPrice}>
              ${item.price.toLocaleString()}
            </Text>
            <Text style={styles.discountedPrice}>
              ${calculateDiscountedPrice(item.price, item.discount || 0).toLocaleString()}
            </Text>
          </View>

          <View style={styles.discountBadge}>
            <Text style={styles.discountBadgeText}>{item.discount}% OFF</Text>
          </View>

          <Text style={styles.productCategory}>{item.category}</Text>

          {item.isNew && (
            <View style={styles.newBadge}>
              <Text style={styles.newBadgeText}>NEW</Text>
            </View>
          )}
        </View>
      </TouchableOpacity>
    );
  };

  // Loading state
  if (loading && !refreshing) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#2e7d32" />
        <Text style={styles.loadingText}>Loading hot deals...</Text>
      </View>
    );
  }

  // Error state
  if (error && !loading) {
    return (
      <View style={styles.centerContainer}>
        <Text style={styles.errorIcon}>‚ùå</Text>
        <Text style={styles.errorTitle}>Oops!</Text>
        <Text style={styles.errorText}>{error}</Text>
        <TouchableOpacity style={styles.retryButton} onPress={fetchDiscountProducts}>
          <Text style={styles.retryButtonText}>Try Again</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>üí∞ Hot Deals</Text>
      <Text style={styles.subtitle}>
        {discountProducts.length} limited time discounts available
      </Text>

      {discountProducts.length === 0 && !loading ? (
        <View style={styles.emptyContainer}>
          <Text style={styles.emptyIcon}>üéØ</Text>
          <Text style={styles.emptyTitle}>No Discounts Available</Text>
          <Text style={styles.emptyText}>
            Check back later for special offers!
          </Text>
          <TouchableOpacity style={styles.retryButton} onPress={fetchDiscountProducts}>
            <Text style={styles.retryButtonText}>Refresh</Text>
          </TouchableOpacity>
        </View>
      ) : (
        <FlatList
          data={discountProducts}
          renderItem={({ item }) => <ProductItem item={item} />}
          keyExtractor={(item) => item.id}
          showsVerticalScrollIndicator={false}
          refreshControl={
            <RefreshControl
              refreshing={refreshing}
              onRefresh={onRefresh}
              colors={['#2e7d32']}
              tintColor={'#2e7d32'}
            />
          }
          contentContainerStyle={styles.listContent}
        />
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#9bf89bff',
    padding: 16,
  },
  centerContainer: {
    flex: 1,
    backgroundColor: '#9bf89bff',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    marginBottom: 20,
  },
  listContent: {
    paddingBottom: 20,
  },
  productCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    marginBottom: 16,
    padding: 12,
    flexDirection: 'row',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
  },
  productImage: {
    width: 100,
    height: 100,
    borderRadius: 8,
  },
   wishlistButtonContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
    zIndex: 1,
  },
  placeholderContainer: {
    backgroundColor: '#f0f0f0',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderStyle: 'dashed',
  },
  placeholderText: {
    fontSize: 24,
    marginBottom: 4,
  },
  placeholderSubtext: {
    fontSize: 12,
    color: '#666',
  },
  productInfo: {
    flex: 1,
    marginLeft: 12,
    justifyContent: 'center',
  },
  productName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  priceContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  originalPrice: {
    fontSize: 14,
    color: '#999',
    textDecorationLine: 'line-through',
    marginRight: 8,
  },
  discountedPrice: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ff5722',
  },
  discountBadge: {
    alignSelf: 'flex-start',
    backgroundColor: '#ff5722',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
    marginBottom: 8,
  },
  discountBadgeText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: 'bold',
  },
  productCategory: {
    fontSize: 12,
    color: '#666',
    textTransform: 'capitalize',
  },
  newBadge: {
    alignSelf: 'flex-start',
    backgroundColor: '#4caf50',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
    marginTop: 4,
  },
  newBadgeText: {
    color: '#ffffff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
  },
  emptyIcon: {
    fontSize: 64,
    marginBottom: 20,
  },
  emptyTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  emptyText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    lineHeight: 22,
    marginBottom: 20,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#2e7d32',
  },
  errorIcon: {
    fontSize: 48,
    marginBottom: 16,
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#d32f2f',
    marginBottom: 8,
  },
  errorText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 20,
    lineHeight: 22,
  },
  retryButton: {
    backgroundColor: '#2e7d32',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

export default DiscountScreen;./screens/categories/Electronics.tsx
==== ./screens/categories/Electronics.tsx ====
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  TouchableOpacity,
  Image,
  ActivityIndicator,
  RefreshControl
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList } from '../../types';
import { productApi } from '../../services/api/productApi';
import { Product } from '../../types';
import WishlistButton from '../../routes/WishlistButton';

type ElectronicsScreenNavigationProp = NativeStackNavigationProp<HomeStackParamList>;

const ElectronicsScreen = () => {
  const navigation = useNavigation<ElectronicsScreenNavigationProp>();

  const [electronicsProducts, setElectronicsProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [refreshing, setRefreshing] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  // Search terms untuk produk elektronik
  const electronicsSearchTerms = [
    'phone', 'smartphone', 'laptop', 'tablet', 'computer',
    'camera', 'headphone', 'earphone', 'watch', 'tv',
    'monitor', 'macbook', 'iphone', 'samsung', 'android',
    'electronic', 'tech', 'gadget', 'wireless', 'bluetooth'
  ];

  // Fetch electronics products menggunakan search
  const fetchElectronicsProducts = async () => {
    try {
      setError(null);
      let allElectronics: Product[] = [];

      // Search untuk setiap term elektronik
      for (const term of electronicsSearchTerms) {
        try {
          const searchResults = await productApi.searchProducts(term);
          allElectronics = [...allElectronics, ...searchResults];
        } catch (searchError) {
          console.log(`Search failed for term: ${term}`);
        }
      }

      // Hapus duplikat berdasarkan product ID
      const uniqueProducts = allElectronics.filter((product, index, self) =>
        index === self.findIndex(p => p.id === product.id)
      );

      console.log(`Found ${uniqueProducts.length} unique electronics products`);
      setElectronicsProducts(uniqueProducts);

    } catch (err) {
      console.error('Error in fetchElectronicsProducts:', err);

      // Fallback: coba ambil semua produk dan filter
      try {
        console.log('Trying fallback method...');
        const allProducts = await productApi.getAllProducts();
        const filteredProducts = allProducts.filter(product => {
          const category = product.category?.toLowerCase() || '';
          const name = product.name?.toLowerCase() || '';
          const description = product.description?.toLowerCase() || '';

          return (
            category.includes('laptop') ||
            category.includes('smartphone') ||
            category.includes('mobile') ||
            category.includes('electronic') ||
            category.includes('computer') ||
            category.includes('tech') ||
            name.includes('iphone') ||
            name.includes('samsung') ||
            name.includes('macbook') ||
            name.includes('laptop') ||
            name.includes('smartphone') ||
            name.includes('tablet') ||
            name.includes('camera') ||
            name.includes('headphone') ||
            name.includes('earphone') ||
            name.includes('watch') ||
            name.includes('tv') ||
            name.includes('monitor') ||
            description.includes('electronic') ||
            description.includes('tech') ||
            description.includes('digital')
          );
        });

        setElectronicsProducts(filteredProducts);
        console.log(`Fallback found ${filteredProducts.length} products`);
      } catch (fallbackError) {
        setError('Failed to load electronics products');
        console.error('Fallback also failed:', fallbackError);
      }
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // Optimized version dengan Promise.all
  const fetchElectronicsProductsOptimized = async () => {
    try {
      setError(null);

      // Gunakan Promise.all untuk search paralel
      const searchPromises = electronicsSearchTerms.map(term =>
        productApi.searchProducts(term).catch(err => {
          console.log(`Search failed for term: ${term}`);
          return []; // Return empty array jika search gagal
        })
      );

      const searchResults = await Promise.all(searchPromises);
      const allElectronics = searchResults.flat();

      // Hapus duplikat
      const uniqueProducts = allElectronics.filter((product, index, self) =>
        index === self.findIndex(p => p.id === product.id)
      );

      console.log(`Found ${uniqueProducts.length} unique electronics products`);
      setElectronicsProducts(uniqueProducts);

    } catch (err) {
      console.error('Error in optimized fetch:', err);
      // Fallback ke method sebelumnya
      await fetchElectronicsProducts();
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // Load data pertama kali
  useEffect(() => {
    fetchElectronicsProductsOptimized();
  }, []);

  const handleRefresh = useCallback(() => {
    setRefreshing(true);
    fetchElectronicsProductsOptimized();
  }, []);

  const handleProductPress = (productId: string) => {
    navigation.navigate('ProductDetail', { productId });
  };

  // Hitung harga diskon
  const calculateDiscountedPrice = (price: number, discount?: number) => {
    if (!discount) return price;
    return Math.round(price * (1 - discount / 100));
  };

  // Komponen untuk product item dengan image error handling
  const ProductItem = ({ item }: { item: Product }) => {
    const [imageError, setImageError] = useState(false);

    return (
      <TouchableOpacity
        style={styles.productCard}
        onPress={() => handleProductPress(item.id)}
      >
        {imageError ? (
          <View style={[styles.productImage, styles.placeholderContainer]}>
            <Text style={styles.placeholderText}>üì±</Text>
            <Text style={styles.placeholderSubtext}>Tech</Text>
          </View>
        ) : (
          <Image
            source={{ uri: item.image }}
            style={styles.productImage}
            resizeMode="cover"
            onError={() => setImageError(true)}
          />
        )}
        <View style={styles.wishlistButtonContainer}>
          <WishlistButton product={item} size={20} />
        </View>
        <View style={styles.productInfo}>
          <Text style={styles.productName} numberOfLines={2}>{item.name}</Text>

          {/* Harga dengan diskon */}
          {item.discount && item.discount > 0 ? (
            <View style={styles.priceContainer}>
              <Text style={styles.originalPrice}>
                ${item.price.toLocaleString()}
              </Text>
              <Text style={styles.discountedPrice}>
                ${calculateDiscountedPrice(item.price, item.discount).toLocaleString()}
              </Text>
            </View>
          ) : (
            <Text style={styles.productPrice}>${item.price.toLocaleString()}</Text>
          )}

          <Text style={styles.productCategory}>{item.category}</Text>

          <View style={styles.badgeContainerLeft}>
            {/* Badge untuk produk baru */}
            {item.isNew && (
              <View style={[styles.badge, styles.newBadge]}>
                <Text style={styles.badgeText}>NEW</Text>
              </View>
            )}

            {/* Badge untuk produk diskon */}
            {item.discount && item.discount > 0 && (
              <View style={[styles.badge, styles.discountBadge]}>
                <Text style={styles.badgeText}>{Math.round(item.discount)}% OFF</Text>
              </View>
            )}
          </View>
        </View>
      </TouchableOpacity>
    );
  };

  // Loading state
  if (loading && !refreshing) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#2e7d32" />
        <Text style={styles.loadingText}>Loading electronics products...</Text>
        <Text style={styles.loadingSubtext}>Searching for phones, laptops, and gadgets</Text>
      </View>
    );
  }

  // Error state
  if (error && !loading) {
    return (
      <View style={styles.centerContainer}>
        <Text style={styles.errorIcon}>üì±</Text>
        <Text style={styles.errorTitle}>Connection Issue</Text>
        <Text style={styles.errorText}>{error}</Text>
        <TouchableOpacity style={styles.retryButton} onPress={fetchElectronicsProductsOptimized}>
          <Text style={styles.retryButtonText}>Try Again</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>üì± Electronics</Text>
      <Text style={styles.subtitle}>
        {electronicsProducts.length > 0
          ? `${electronicsProducts.length} smart gadgets available`
          : 'Searching for electronics products...'
        }
      </Text>

      <FlatList
        data={electronicsProducts}
        renderItem={({ item }) => <ProductItem item={item} />}
        keyExtractor={(item) => item.id}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={[
          styles.listContent,
          electronicsProducts.length === 0 && styles.emptyListContent
        ]}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={['#2e7d32']}
            tintColor={'#2e7d32'}
          />
        }
        ListEmptyComponent={
          !loading && !error ? (
            <View style={styles.emptyContainer}>
              <Text style={styles.emptyIcon}>üîå</Text>
              <Text style={styles.emptyTitle}>No Electronics Found</Text>
              <Text style={styles.emptyText}>
                We searched for phones, laptops, tablets, and other gadgets but couldn't find any electronics products.
              </Text>
              <TouchableOpacity style={styles.retryButton} onPress={fetchElectronicsProductsOptimized}>
                <Text style={styles.retryButtonText}>Search Again</Text>
              </TouchableOpacity>
            </View>
          ) : null
        }
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#9bf89bff',
    padding: 16,
  },
  centerContainer: {
    flex: 1,
    backgroundColor: '#9bf89bff',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    marginBottom: 20,
  },
  listContent: {
    paddingBottom: 20,
  },
  emptyListContent: {
    flexGrow: 1,
  },
  productCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    marginBottom: 16,
    padding: 12,
    elevation: 2,
    flexDirection: 'row',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
  },
  productImage: {
    width: 80,
    height: 80,
    borderRadius: 8,
  },
   wishlistButtonContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
    zIndex: 1,
  },
  placeholderContainer: {
    backgroundColor: '#f0f0f0',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderStyle: 'dashed',
  },
  placeholderText: {
    fontSize: 20,
    marginBottom: 4,
  },
  placeholderSubtext: {
    fontSize: 10,
    color: '#666',
  },
  productInfo: {
    flex: 1,
    marginLeft: 12,
    justifyContent: 'center',
  },
  productName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 6,
  },
  productPrice: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 4,
  },
  priceContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  originalPrice: {
    fontSize: 14,
    color: '#999',
    textDecorationLine: 'line-through',
    marginRight: 8,
  },
  discountedPrice: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ff5722',
  },
  productCategory: {
    fontSize: 12,
    color: '#666',
    textTransform: 'capitalize',
    marginBottom: 6,
  },
  badgeContainerLeft: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 6,
  },
  badge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
  },
  badgeText: {
    color: '#ffffff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  newBadge: {
    backgroundColor: '#4caf50',
  },
  discountBadge: {
    backgroundColor: '#ff5722',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
  },
  emptyIcon: {
    fontSize: 64,
    marginBottom: 20,
  },
  emptyTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  emptyText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    lineHeight: 22,
    marginBottom: 20,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#2e7d32',
    textAlign: 'center',
  },
  loadingSubtext: {
    marginTop: 8,
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
  },
  errorIcon: {
    fontSize: 48,
    marginBottom: 16,
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#d32f2f',
    marginBottom: 8,
  },
  errorText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 20,
    lineHeight: 22,
  },
  retryButton: {
    backgroundColor: '#2e7d32',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
    minWidth: 120,
    alignItems: 'center',
  },
  retryButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

export default ElectronicsScreen;./screens/categories/Entertainment.tsx
==== ./screens/categories/Entertainment.tsx ====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  Image,
  SafeAreaView,
  ActivityIndicator,
  Alert,
  TextInput,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList, Product } from '../../types';
import { productApi } from '../../services/api/productApi';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';
import WishlistButton from '../../routes/WishlistButton';


export default function Entertainment() {
  const navigation = useNavigation<NativeStackNavigationProp<HomeStackParamList>>();
  
  const [entertainmentProducts, setEntertainmentProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [refreshing, setRefreshing] = useState(false);

  // Filter untuk kategori entertainment
  const entertainmentCategories = [
    'smartphones',
    'laptops',
    'fragrances',
    'skincare',
    'groceries',
    'home-decoration',
    'furniture',
    'tops',
    'womens-dresses',
    'womens-shoes',
    'mens-shirts',
    'mens-shoes',
    'mens-watches',
    'womens-watches',
    'womens-bags',
    'womens-jewellery',
    'sunglasses',
    'automotive',
    'motorcycle',
    'lighting'
  ];

  // Keywords untuk produk entertainment
  const entertainmentKeywords = [
    'game', 'music', 'movie', 'book', 'tv', 'audio', 'speaker', 
    'headphone', 'camera', 'gaming', 'entertainment', 'media',
    'video', 'streaming', 'console', 'playstation', 'xbox', 'nintendo'
  ];

  useEffect(() => {
    loadEntertainmentProducts();
  }, []);

  const loadEntertainmentProducts = async () => {
    try {
      setLoading(true);
      setError(null);
      
      console.log('üéÆ Loading entertainment products...');
      
      // Ambil semua produk dari API
      const allProducts = await productApi.getAllProducts();
      
      console.log('üì¶ Total products received:', allProducts.length);
      
      // Filter produk untuk kategori entertainment
      const filteredProducts = allProducts.filter(product => 
        isEntertainmentProduct(product)
      );
      
      console.log('üéØ Entertainment products found:', filteredProducts.length);
      
      setEntertainmentProducts(filteredProducts);
      
    } catch (err: any) {
      console.error('‚ùå Error loading entertainment products:', err);
      setError(err.message || 'Failed to load entertainment products');
      Alert.alert('Error', 'Failed to load entertainment products');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const isEntertainmentProduct = (product: Product): boolean => {
    const productName = product.name.toLowerCase();
    const productCategory = product.category.toLowerCase();
    const productDescription = product.description.toLowerCase();
    
    // Check jika termasuk dalam kategori entertainment
    const isEntertainmentCategory = 
      productCategory.includes('electronics') ||
      productCategory.includes('music') ||
      productCategory.includes('games') ||
      productCategory.includes('books') ||
      productCategory.includes('movies');
    
    // Check jika nama/deskripsi mengandung keyword entertainment
    const hasEntertainmentKeyword = entertainmentKeywords.some(keyword =>
      productName.includes(keyword) || productDescription.includes(keyword)
    );
    
    // Khusus untuk DummyJSON, kita akan consider beberapa kategori sebagai entertainment
    const isDummyJSONEntertainment = 
      productCategory.includes('smartphones') ||
      productCategory.includes('laptops') ||
      productCategory.includes('fragrances') || // Consider some as entertainment/lifestyle
      productCategory.includes('home-decoration') ||
      productCategory.includes('lighting');
    
    return isEntertainmentCategory || hasEntertainmentKeyword || isDummyJSONEntertainment;
  };

  const handleRefresh = () => {
    setRefreshing(true);
    loadEntertainmentProducts();
  };

  const handleProductPress = (productId: string) => {
    navigation.navigate('ProductDetail', { productId });
  };

  const handleSearch = (text: string) => {
    setSearchQuery(text);
  };

  // Filter products berdasarkan search query
  const filteredProducts = entertainmentProducts.filter(product =>
    product.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    product.description.toLowerCase().includes(searchQuery.toLowerCase()) ||
    product.category.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const renderProductItem = ({ item }: { item: Product }) => (
    <TouchableOpacity 
      style={styles.productCard}
      onPress={() => handleProductPress(item.id)}
    >
      <Image 
        source={{ uri: item.image }} 
        style={styles.productImage}
        resizeMode="cover"
      />

      <View style={styles.wishlistButtonContainer}>
        <WishlistButton product={item} size={20} />
      </View>
      
      <View style={styles.productInfo}>
        <Text style={styles.productName} numberOfLines={2}>{item.name}</Text>
        
        {item.brand && (
          <Text style={styles.productBrand}>{item.brand}</Text>
        )}
        
        <Text style={styles.productDescription} numberOfLines={2}>
          {item.description}
        </Text>
        
        <View style={styles.priceContainer}>
          <Text style={styles.productPrice}>${item.price.toLocaleString()}</Text>
          {item.discount && item.discount > 0 && (
            <Text style={styles.discountBadge}>{item.discount}% OFF</Text>
          )}
        </View>
        
        <View style={styles.productMeta}>
          <Text style={styles.productCategory}>{item.category}</Text>
          {item.isNew && (
            <View style={styles.newBadge}>
              <Text style={styles.newBadgeText}>NEW</Text>
            </View>
          )}
        </View>
        
        {item.stock !== undefined && (
          <Text style={[
            styles.stockText,
            item.stock < 10 ? styles.lowStock : styles.inStock
          ]}>
            {item.stock > 10 ? 'In Stock' : `Only ${item.stock} left`}
          </Text>
        )}
      </View>
    </TouchableOpacity>
  );

  if (loading && !refreshing) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#10b981" />
        <Text style={styles.loadingText}>Loading entertainment products...</Text>
      </View>
    );
  }

  if (error && entertainmentProducts.length === 0) {
    return (
      <View style={styles.errorContainer}>
        <FontAwesome6 name="triangle-exclamation" size={50} color="#ef4444" iconStyle='solid' />
        <Text style={styles.errorTitle}>Failed to Load</Text>
        <Text style={styles.errorMessage}>{error}</Text>
        <TouchableOpacity style={styles.retryButton} onPress={loadEntertainmentProducts}>
          <Text style={styles.retryButtonText}>Try Again</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <View>
          <Text style={styles.title}>üéÆ Entertainment & Electronics</Text>
          <Text style={styles.subtitle}>
            {filteredProducts.length} products found
          </Text>
        </View>
      </View>

      {/* Search Bar */}
      <View style={styles.searchContainer}>
        <FontAwesome6 name="magnifying-glass" size={16} color="#6b7280" iconStyle='solid'/>
        <TextInput
          style={styles.searchInput}
          placeholder="Search games, electronics, music..."
          placeholderTextColor="#9ca3af"
          value={searchQuery}
          onChangeText={handleSearch}
        />
        {searchQuery ? (
          <TouchableOpacity onPress={() => setSearchQuery('')}>
            <FontAwesome6 name="xmark" size={16} color="#6b7280" iconStyle='solid' />
          </TouchableOpacity>
        ) : null}
      </View>

      {/* Products List */}
      <FlatList
        data={filteredProducts}
        renderItem={renderProductItem}
        keyExtractor={(item) => item.id}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.listContent}
        refreshing={refreshing}
        onRefresh={handleRefresh}
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <FontAwesome6 name="gamepad" size={60} color="#d1d5db" iconStyle='solid' />
            <Text style={styles.emptyTitle}>
              {searchQuery ? 'No products found' : 'No entertainment products'}
            </Text>
            <Text style={styles.emptySubtitle}>
              {searchQuery 
                ? 'Try adjusting your search terms'
                : 'Check back later for new arrivals'
              }
            </Text>
            {searchQuery && (
              <TouchableOpacity 
                style={styles.clearSearchButton}
                onPress={() => setSearchQuery('')}
              >
                <Text style={styles.clearSearchText}>Clear Search</Text>
              </TouchableOpacity>
            )}
          </View>
        }
        ListHeaderComponent={
          filteredProducts.length > 0 ? (
            <View style={styles.resultsInfo}>
              <Text style={styles.resultsText}>
                Showing {filteredProducts.length} of {entertainmentProducts.length} products
              </Text>
            </View>
          ) : null
        }
      />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#9bf89bff',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8fafc',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#6b7280',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8fafc',
    padding: 20,
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#111827',
    marginTop: 16,
    marginBottom: 8,
  },
  errorMessage: {
    fontSize: 16,
    color: '#6b7280',
    textAlign: 'center',
    marginBottom: 24,
  },
  retryButton: {
    backgroundColor: '#10b981',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  header: {
    padding: 20,
    paddingBottom: 12,
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  title: {
    fontSize: 24,
    fontWeight: '700',
    color: '#111827',
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 14,
    color: '#6b7280',
    fontWeight: '500',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    margin: 16,
    marginTop: 8,
    padding: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#e5e7eb',
    gap: 12,
  },
  searchInput: {
    flex: 1,
    fontSize: 16,
    color: '#111827',
  },
  listContent: {
    padding: 16,
    paddingTop: 8,
  },
  resultsInfo: {
    marginBottom: 16,
  },
  resultsText: {
    fontSize: 14,
    color: '#6b7280',
    fontWeight: '500',
  },
  productCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    marginBottom: 16,
    padding: 16,
    flexDirection: 'row',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
    elevation: 3,
    borderWidth: 1,
    borderColor: '#f3f4f6',
  },
  productImage: {
    width: 80,
    height: 80,
    borderRadius: 8,
  },
  wishlistButtonContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
    zIndex: 1,
  },
  productInfo: {
    flex: 1,
    marginLeft: 12,
  },
  productName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#111827',
    marginBottom: 4,
  },
  productBrand: {
    fontSize: 12,
    color: '#6b7280',
    marginBottom: 4,
    fontWeight: '500',
  },
  productDescription: {
    fontSize: 12,
    color: '#6b7280',
    marginBottom: 8,
    lineHeight: 16,
  },
  priceContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
    gap: 8,
  },
  productPrice: {
    fontSize: 18,
    fontWeight: '700',
    color: '#059669',
  },
  discountBadge: {
    fontSize: 12,
    fontWeight: '600',
    color: '#ffffff',
    backgroundColor: '#ef4444',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 4,
  },
  productMeta: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 4,
  },
  productCategory: {
    fontSize: 12,
    color: '#6b7280',
    textTransform: 'capitalize',
    fontWeight: '500',
  },
  newBadge: {
    backgroundColor: '#10b981',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 4,
  },
  newBadgeText: {
    fontSize: 10,
    color: '#ffffff',
    fontWeight: '600',
  },
  stockText: {
    fontSize: 12,
    fontWeight: '500',
  },
  inStock: {
    color: '#059669',
  },
  lowStock: {
    color: '#ef4444',
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 60,
  },
  emptyTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#374151',
    marginTop: 16,
    marginBottom: 8,
  },
  emptySubtitle: {
    fontSize: 14,
    color: '#6b7280',
    textAlign: 'center',
    marginBottom: 20,
  },
  clearSearchButton: {
    backgroundColor: '#f3f4f6',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 6,
  },
  clearSearchText: {
    fontSize: 14,
    color: '#374151',
    fontWeight: '500',
  },
});./screens/categories/Food.tsx
==== ./screens/categories/Food.tsx ====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  Image,
  ActivityIndicator,
  RefreshControl,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList } from '../../types';
import { productApi } from '../../services/api/productApi';
import { Product } from '../../types';
import WishlistButton from '../../routes/WishlistButton';

type FoodScreenNavigationProp = NativeStackNavigationProp<HomeStackParamList>;

export default function Food() {
  const navigation = useNavigation<FoodScreenNavigationProp>();
  const [foodProducts, setFoodProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [refreshing, setRefreshing] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const fetchFoodProducts = async () => {
    try {
      setError(null);
      const allProducts = await productApi.getAllProducts();

      // Filter produk makanan
      const filteredProducts = allProducts.filter(product =>
        product.category === 'food' ||
        product.name.toLowerCase().includes('organic') ||
        product.name.toLowerCase().includes('coffee') ||
        product.name.toLowerCase().includes('tea') ||
        product.name.toLowerCase().includes('snack') ||
        product.category.toLowerCase().includes('food') ||
        product.category.toLowerCase().includes('beverage')
      );

      setFoodProducts(filteredProducts);
    } catch (err) {
      setError('Gagal memuat produk makanan');
      console.error('Error fetching food products:', err);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  useEffect(() => {
    fetchFoodProducts();
  }, []);

  const handleRefresh = () => {
    setRefreshing(true);
    fetchFoodProducts();
  };

  const handleProductPress = (productId: string) => {
    navigation.navigate('ProductDetail', { productId });
  };

  // Komponen untuk product item dengan image error handling
  const ProductItem = ({ item }: { item: Product }) => {
    const [imageError, setImageError] = useState(false);

    return (
      <TouchableOpacity
        style={styles.productCard}
        onPress={() => handleProductPress(item.id)}
      >
        {imageError ? (
          <View style={[styles.productImage, styles.placeholderContainer]}>
            <Text style={styles.placeholderText}>üì∑</Text>
            <Text style={styles.placeholderSubtext}>No Image</Text>
          </View>
        ) : (
          <Image
            source={{ uri: item.image }}
            style={styles.productImage}
            resizeMode="cover"
            onError={() => setImageError(true)}
          />
        )}
        <View style={styles.wishlistButtonContainer}>
          <WishlistButton product={item} size={20} />
        </View>
        <View style={styles.productInfo}>
          <Text style={styles.productName} numberOfLines={2}>{item.name}</Text>
          <Text style={styles.productPrice}>${item.price.toLocaleString()}</Text>
          <Text style={styles.productCategory}>{item.category}</Text>
          {item.isNew && (
            <View style={styles.newBadge}>
              <Text style={styles.newBadgeText}>NEW</Text>
            </View>
          )}
        </View>
      </TouchableOpacity>
    );
  };

  // Loading state
  if (loading && !refreshing) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#2e7d32" />
        <Text style={styles.loadingText}>Memuat produk makanan...</Text>
      </View>
    );
  }

  // Error state
  if (error && !loading) {
    return (
      <View style={styles.centerContainer}>
        <Text style={styles.errorIcon}>‚ùå</Text>
        <Text style={styles.errorTitle}>Oops!</Text>
        <Text style={styles.errorText}>{error}</Text>
        <TouchableOpacity style={styles.retryButton} onPress={fetchFoodProducts}>
          <Text style={styles.retryButtonText}>Coba Lagi</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>üçé Makanan</Text>
      <Text style={styles.subtitle}>
        {foodProducts.length} produk makanan sehat & organik
      </Text>

      <FlatList
        data={foodProducts}
        renderItem={({ item }) => <ProductItem item={item} />}
        keyExtractor={(item) => item.id}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={['#2e7d32']}
            tintColor={'#2e7d32'}
          />
        }
        ListEmptyComponent={
          !loading && !error ? (
            <View style={styles.emptyContainer}>
              <Text style={styles.emptyIcon}>üçé</Text>
              <Text style={styles.emptyTitle}>Belum Ada Produk Makanan</Text>
              <Text style={styles.emptyText}>
                Produk makanan akan segera tersedia!
              </Text>
            </View>
          ) : null
        }
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#9bf89bff',
    padding: 16,
  },
  centerContainer: {
    flex: 1,
    backgroundColor: '#9bf89bff',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 20,
  },
  listContent: {
    paddingBottom: 20,
  },
  productCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    marginBottom: 16,
    padding: 12,
    flexDirection: 'row',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
  },
  productImage: {
    width: 80,
    height: 80,
    borderRadius: 8,
  },
  wishlistButtonContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
    zIndex: 1,
  },
  placeholderContainer: {
    backgroundColor: '#f0f0f0',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderStyle: 'dashed',
  },
  placeholderText: {
    fontSize: 20,
    marginBottom: 4,
  },
  placeholderSubtext: {
    fontSize: 10,
    color: '#666',
  },
  productInfo: {
    flex: 1,
    marginLeft: 12,
    justifyContent: 'center',
  },
  productName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 4,
  },
  productPrice: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 4,
  },
  productCategory: {
    fontSize: 12,
    color: '#666',
    textTransform: 'capitalize',
  },
  newBadge: {
    alignSelf: 'flex-start',
    backgroundColor: '#4caf50',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
    marginTop: 4,
  },
  newBadgeText: {
    color: '#ffffff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 40,
  },
  emptyIcon: {
    fontSize: 48,
    marginBottom: 16,
  },
  emptyTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  emptyText: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#2e7d32',
  },
  errorIcon: {
    fontSize: 48,
    marginBottom: 16,
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#d32f2f',
    marginBottom: 8,
  },
  errorText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 20,
    lineHeight: 22,
  },
  retryButton: {
    backgroundColor: '#2e7d32',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});./screens/categories/New.tsx
==== ./screens/categories/New.tsx ====
import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  FlatList, 
  StyleSheet, 
  TouchableOpacity, 
  Image,
  ActivityIndicator,
  RefreshControl 
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList } from '../../types';
import { productApi } from '../../services/api/productApi';
import { Product } from '../../types';
import WishlistButton from '../../routes/WishlistButton';

type NewScreenNavigationProp = NativeStackNavigationProp<HomeStackParamList>;

const NewScreen = () => {
  const navigation = useNavigation<NewScreenNavigationProp>();
  const [newProducts, setNewProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [refreshing, setRefreshing] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  // Fungsi untuk mengambil data produk baru
  const fetchNewProducts = async () => {
    try {
      setError(null);
      let products: Product[];
      
      // Coba ambil dari endpoint khusus produk baru
      try {
        products = await productApi.getNewProducts();
      } catch (apiError) {
        // Jika endpoint khusus tidak ada, ambil semua dan filter
        console.log('Using fallback method for new products');
        const allProducts = await productApi.getAllProducts();
        products = allProducts.filter(product => product.isNew);
      }
      
      setNewProducts(products);
    } catch (err) {
      setError('Failed to load new products');
      console.error('Error fetching new products:', err);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // Load data pertama kali
  useEffect(() => {
    fetchNewProducts();
  }, []);

  // Handle refresh
  const handleRefresh = () => {
    setRefreshing(true);
    fetchNewProducts();
  };

  const handleProductPress = (productId: string) => {
    navigation.navigate('ProductDetail', { productId });
  };

  const renderProductItem = ({ item }: { item: Product }) => (
    <TouchableOpacity 
      style={styles.productCard}
      onPress={() => handleProductPress(item.id)}
    >
      <Image 
        source={{ uri: item.image }} 
        style={styles.productImage} 
        resizeMode="cover" 
      />

      <View style={styles.wishlistButtonContainer}>
        <WishlistButton product={item} size={20} />
      </View>

      <View style={styles.productInfo}>
        <Text style={styles.productName} numberOfLines={2}>{item.name}</Text>
        <Text style={styles.productPrice}>${item.price.toLocaleString()}</Text>
        <Text style={styles.productCategory}>{item.category}</Text>
        {item.rating && (
          <Text style={styles.productRating}>‚≠ê {item.rating}</Text>
        )}
      </View>
      <View style={styles.badgeContainer}>
        <View style={[styles.badge, styles.newBadge]}>
          <Text style={styles.badgeText}>NEW</Text>
        </View>
      </View>
    </TouchableOpacity>
  );

  // Loading state
  if (loading && !refreshing) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#2e7d32" />
        <Text style={styles.loadingText}>Loading new arrivals...</Text>
      </View>
    );
  }

  // Error state
  if (error && !loading) {
    return (
      <View style={styles.centerContainer}>
        <Text style={styles.errorIcon}>‚ùå</Text>
        <Text style={styles.errorTitle}>Oops!</Text>
        <Text style={styles.errorText}>{error}</Text>
        <TouchableOpacity style={styles.retryButton} onPress={fetchNewProducts}>
          <Text style={styles.retryButtonText}>Try Again</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>üÜï New Arrivals</Text>
      <Text style={styles.subtitle}>Fresh products just for you</Text>
      
      <FlatList
        data={newProducts}
        renderItem={renderProductItem}
        keyExtractor={(item) => item.id}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={['#2e7d32']}
            tintColor={'#2e7d32'}
          />
        }
        ListEmptyComponent={
          !loading && !error ? (
            <View style={styles.emptyContainer}>
              <Text style={styles.emptyIcon}>üì¶</Text>
              <Text style={styles.emptyTitle}>No New Products</Text>
              <Text style={styles.emptyText}>
                Check back later for new arrivals!
              </Text>
            </View>
          ) : null
        }
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#9bf89bff',
    padding: 16,
  },
  centerContainer: {
    flex: 1,
    backgroundColor: '#9bf89bff',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    marginBottom: 20,
  },
  listContent: {
    paddingBottom: 20,
  },
  productCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    marginBottom: 16,
    padding: 12,
    elevation: 2,
    flexDirection: 'row',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
  },
  productImage: {
    width: 80,
    height: 80,
    borderRadius: 8,
  },
  wishlistButtonContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
    zIndex: 1,
  },
  productInfo: {
    flex: 1,
    marginLeft: 12,
    justifyContent: 'center',
  },
  productName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 4,
  },
  productPrice: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 4,
  },
  productCategory: {
    fontSize: 12,
    color: '#666',
    textTransform: 'capitalize',
    marginBottom: 2,
  },
  productRating: {
    fontSize: 12,
    color: '#666',
  },
  newBadge: {
    backgroundColor: '#4caf50',
  },
  badgeContainer: {
    position: 'absolute',
    top: 8,
    left: 8,
    zIndex: 1,
  },
  badge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
  },
  badgeText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: 'bold',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
  },
  emptyIcon: {
    fontSize: 64,
    marginBottom: 20,
  },
  emptyTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  emptyText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    lineHeight: 22,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#2e7d32',
  },
  errorIcon: {
    fontSize: 48,
    marginBottom: 16,
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#d32f2f',
    marginBottom: 8,
  },
  errorText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 20,
    lineHeight: 22,
  },
  retryButton: {
    backgroundColor: '#2e7d32',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

export default NewScreen;./screens/categories/Popular.tsx
==== ./screens/categories/Popular.tsx ====
// src/screens/PopularScreen.tsx
import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  FlatList, 
  StyleSheet, 
  TouchableOpacity, 
  Image, 
  ActivityIndicator,
  Alert,
  RefreshControl 
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList, Product } from '../../types'; // ‚úÖ Path yang benar
import { useDynamicHeader } from '../../hooks/useDynamicHeader';
import { productApi } from '../../services/api/productApi';
import WishlistButton from '../../routes/WishlistButton';

type PopularScreenNavigationProp = NativeStackNavigationProp<HomeStackParamList>;

const PopularScreen = () => {
  const navigation = useNavigation<PopularScreenNavigationProp>();
  const [popularProducts, setPopularProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  useDynamicHeader(
    navigation, 
    'Jelajahi Produk',
    'Product ter Populer!'
  );

  // Fetch popular products using productApi
  const fetchPopularProducts = async () => {
    try {
      const products = await productApi.getPopularProducts(12);
      setPopularProducts(products);
    } catch (error: any) {
      console.error('Error in PopularScreen:', error);
      Alert.alert('Error', error.message || 'Failed to load popular products');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const onRefresh = () => {
    setRefreshing(true);
    fetchPopularProducts();
  };

  useEffect(() => {
    fetchPopularProducts();
  }, []);

  const handleProductPress = (productId: string) => {
    navigation.navigate('ProductDetail', { productId });
  };

  const formatPrice = (price: number) => {
    return `$${price.toFixed(2)}`;
  };

  const calculateDiscountPrice = (price: number, discount?: number) => {
    if (!discount) return price;
    return price - (price * discount / 100);
  };

  const renderProductItem = ({ item }: { item: Product }) => (
    <TouchableOpacity 
      style={styles.productCard}
      onPress={() => handleProductPress(item.id)}
    >
      <Image source={{ uri: item.image }} style={styles.productImage} />

      <View style={styles.wishlistButtonContainer}>
        <WishlistButton product={item} size={20} />
      </View>

      <View style={styles.badgeContainer}>
        {item.isNew && (
          <View style={[styles.badge, styles.newBadge]}>
            <Text style={styles.badgeText}>NEW</Text>
          </View>
        )}
        {item.discount && item.discount > 0 && (
          <View style={[styles.badge, styles.discountBadge]}>
            <Text style={styles.badgeText}>-{Math.round(item.discount)}% OFF</Text>
          </View>
        )}
      </View>

      <View style={styles.productInfo}>
        <Text style={styles.productName} numberOfLines={2}>{item.name}</Text>
        <Text style={styles.productCategory}>{item.category}</Text>
        
        <View style={styles.priceContainer}>
          {item.discount && item.discount > 0 ? (
            <>
              <Text style={styles.originalPrice}>
                {formatPrice(item.price)}
              </Text>
              <Text style={styles.discountPrice}>
                {formatPrice(calculateDiscountPrice(item.price, item.discount))}
              </Text>
            </>
          ) : (
            <Text style={styles.normalPrice}>
              {formatPrice(item.price)}
            </Text>
          )}
        </View>

        <Text style={styles.productDescription} numberOfLines={2}>
          {item.description}
        </Text>
      </View>
    </TouchableOpacity>
  );

  if (loading && !refreshing) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#2e7d32" />
        <Text style={styles.loadingText}>Loading popular products...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>üî• Popular Products</Text>
      <Text style={styles.subtitle}>Most loved by our customers</Text>
      
      <FlatList
        data={popularProducts}
        renderItem={renderProductItem}
        keyExtractor={(item) => item.id}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={['#2e7d32']}
          />
        }
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>No popular products found</Text>
            <Text style={styles.emptySubtext}>
              Check back later for trending items
            </Text>
          </View>
        }
      />
    </View>
  );
};

// Styles remain the same...
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#9bf89bff',
    padding: 16,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#9bf89bff',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#2e7d32',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    marginBottom: 20,
  },
  listContent: {
    paddingBottom: 20,
  },
  productCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    marginBottom: 16,
    padding: 12,
    flexDirection: 'row',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
    position: 'relative',
  },
  productImage: {
    width: 80,
    height: 80,
    borderRadius: 8,
  },
  wishlistButtonContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
    zIndex: 1,
  },
  badgeContainer: {
    position: 'absolute',
    top: 8,
    left: 8,
    gap: 6,
    alignItems: 'flex-start',
    zIndex: 1,
  },
  badge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
  },
  badgeText: {
    color: '#ffffff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  newBadge: {
    backgroundColor: '#4caf50',
  },
  productInfo: {
    flex: 1,
    marginLeft: 12,
    justifyContent: 'center',
  },
  productName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 4,
  },
  productCategory: {
    fontSize: 12,
    color: '#666',
    textTransform: 'capitalize',
    marginBottom: 6,
  },
  priceContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
  },
  originalPrice: {
    fontSize: 14,
    color: '#999',
    textDecorationLine: 'line-through',
    marginRight: 8,
  },
  discountPrice: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2e7d32',
  },
  normalPrice: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2e7d32',
  },
  productDescription: {
    fontSize: 12,
    color: '#888',
    lineHeight: 16,
  },
  discountBadge: {
    backgroundColor: '#ff4444',
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  emptyText: {
    fontSize: 18,
    color: '#666',
    fontWeight: '600',
    marginBottom: 8,
  },
  emptySubtext: {
    fontSize: 14,
    color: '#999',
    textAlign: 'center',
  },
});

export default PopularScreen;./screens/dashboard/AnalyticsHistory.tsx
==== ./screens/dashboard/AnalyticsHistory.tsx ====
// screens/AnalyticsHistoryScreen.tsx
import React, { useState, useEffect } from 'react';
import {
    View,
    Text,
    StyleSheet,
    ScrollView,
    TouchableOpacity,
    RefreshControl,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';

// Simpan data analytics global (bisa diganti dengan AsyncStorage/Context)
let analyticsHistory: Array<{
    id: string;
    timestamp: string;
    currentRoute: string;
    previousRoute?: string;
    type: 'navigation';
}> = [];

// Fungsi untuk menambah data analytics
export const addAnalyticsEvent = (currentRoute: string, previousRoute?: string) => {
    const newEvent = {
        id: Date.now().toString(),
        timestamp: new Date().toLocaleTimeString(),
        currentRoute,
        previousRoute,
        type: 'navigation' as const,
    };

    analyticsHistory.unshift(newEvent); // Tambah di awal array

    // Simpan maksimal 100 events
    if (analyticsHistory.length > 100) {
        analyticsHistory = analyticsHistory.slice(0, 100);
    }

    return newEvent;
};

// Fungsi untuk mendapatkan analytics history
export const getAnalyticsHistory = () => {
    return [...analyticsHistory]; // Return copy
};

const AnalyticsHistoryScreen = () => {
    const navigation = useNavigation();
    const [history, setHistory] = useState(analyticsHistory);
    const [refreshing, setRefreshing] = useState(false);

    const onRefresh = () => {
        setRefreshing(true);
        setHistory([...analyticsHistory]);
        setRefreshing(false);
    };

    // Auto refresh ketika screen focus
    useEffect(() => {
        const unsubscribe = navigation.addListener('focus', () => {
            setHistory([...analyticsHistory]);
        });

        return unsubscribe;
    }, [navigation]);

    const clearHistory = () => {
        analyticsHistory = [];
        setHistory([]);
    };

    const getRouteIcon = (routeName: string) => {
        const icons: { [key: string]: string } = {
            Home: 'house',
            ProductDetail: 'box',
            CheckoutModal: 'credit-card',
            Categories: 'grid',
            Profile: 'user',
            Settings: 'gear',
            Login: 'right-to-bracket',
            Popular: 'fire',
            New: 'star',
            Discount: 'tag',
            Analytics: 'chart-line',
            AnalyticsHistory: 'chart-simple',
            History: 'clock-rotate-left',
            Favorites: 'heart',
        };
        return icons[routeName] || 'map';
    };

    return (
        <View style={styles.container}>
            <ScrollView
                style={styles.scrollView}
                contentContainerStyle={styles.scrollViewContent}
                refreshControl={
                    <RefreshControl
                        refreshing={refreshing}
                        onRefresh={onRefresh}
                        colors={['#2e7d32']}
                    />
                }
            >
            {/* Header */}
            <View style={styles.header}>
                <Text style={styles.headerTitle}>üìä Analytics History</Text>
                <TouchableOpacity
                    style={styles.clearButton}
                    onPress={clearHistory}
                >
                    <FontAwesome6 name="trash" size={16} color="#ffffff" iconStyle='solid' />
                </TouchableOpacity>
            </View>

            {/* Stats Summary */}
            <View style={styles.statsContainer}>
                <View style={styles.statItem}>
                    <Text style={styles.statNumber}>{history.length}</Text>
                    <Text style={styles.statLabel}>Total Events</Text>
                </View>
                <View style={styles.statItem}>
                    <Text style={styles.statNumber}>
                        {new Set(history.map(item => item.currentRoute)).size}
                    </Text>
                    <Text style={styles.statLabel}>Unique Screens</Text>
                </View>
            </View>

            {/* History List */}

                {history.length === 0 ? (
                    <View style={styles.emptyState}>
                        <FontAwesome6 name="chart-line" size={48} color="#ccc" iconStyle='solid' />
                        <Text style={styles.emptyText}>No analytics data yet</Text>
                        <Text style={styles.emptySubtext}>
                            Navigate through the app to see analytics events
                        </Text>
                    </View>
                ) : (
                    history.map((event) => (
                        <View key={event.id} style={styles.eventItem}>
                            <View style={styles.eventIcon}>
                                <FontAwesome6
                                    name={getRouteIcon(event.currentRoute) as any}
                                    size={16}
                                    color="#ec6a43ff"
                                    iconStyle='solid'
                                />
                            </View>

                            <View style={styles.eventContent}>
                                <Text style={styles.eventRoute}>{event.currentRoute}</Text>

                                {event.previousRoute && (
                                    <Text style={styles.eventPrevious}>
                                        From: {event.previousRoute}
                                    </Text>
                                )}

                                <Text style={styles.eventTime}>{event.timestamp}</Text>
                            </View>

                            <View style={styles.eventType}>
                                <Text style={styles.eventTypeText}>{event.type}</Text>
                            </View>
                        </View>
                    ))
                )}
            </ScrollView>
        </View>
    );
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#9bf89bff',
    },
    header: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        backgroundColor: '#2e7d32',
        padding: 20,
        paddingTop: 20,
    },
    backButton: {
        padding: 8,
    },
    headerTitle: {
        fontSize: 20,
        fontWeight: 'bold',
        color: '#ffffff',
    },
     scrollView: {
        flex: 1,
    },
    scrollViewContent: {
        flexGrow: 1,
    },
    clearButton: {
        padding: 8,
        backgroundColor: 'rgba(255,255,255,0.2)',
        borderRadius: 8,
    },
    statsContainer: {
        flexDirection: 'row',
        backgroundColor: '#ffffff',
        padding: 20,
        margin: 16,
        borderRadius: 16,
        elevation: 2,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
    },
    statItem: {
        flex: 1,
        alignItems: 'center',
    },
    statNumber: {
        fontSize: 24,
        fontWeight: 'bold',
        color: '#2e7d32',
        marginBottom: 4,
    },
    statLabel: {
        fontSize: 12,
        color: '#666',
        fontWeight: '500',
    },
    listContainer: {
        flex: 1,
        padding: 16,
    },
    emptyState: {
        alignItems: 'center',
        justifyContent: 'center',
        padding: 40,
    },
    emptyText: {
        fontSize: 18,
        color: '#666',
        fontWeight: '600',
        marginTop: 16,
        marginBottom: 8,
    },
    emptySubtext: {
        fontSize: 14,
        color: '#999',
        textAlign: 'center',
        lineHeight: 20,
    },
    eventItem: {
        flexDirection: 'row',
        alignItems: 'center',
        backgroundColor: '#ffffff',
        padding: 16,
        borderRadius: 12,
        marginBottom: 12,
        elevation: 1,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.1,
        shadowRadius: 2,
    },
    eventIcon: {
        width: 32,
        height: 32,
        borderRadius: 16,
        backgroundColor: '#e8f5e9',
        justifyContent: 'center',
        alignItems: 'center',
        marginRight: 12,
    },
    eventContent: {
        flex: 1,
    },
    eventRoute: {
        fontSize: 16,
        fontWeight: 'bold',
        color: '#2e7d32',
        marginBottom: 4,
    },
    eventPrevious: {
        fontSize: 12,
        color: '#666',
        marginBottom: 2,
    },
    eventTime: {
        fontSize: 11,
        color: '#999',
    },
    eventType: {
        backgroundColor: '#f0f7f0',
        paddingHorizontal: 8,
        paddingVertical: 4,
        borderRadius: 6,
    },
    eventTypeText: {
        fontSize: 10,
        color: '#4caf50',
        fontWeight: 'bold',
        textTransform: 'uppercase',
    },
});

export default AnalyticsHistoryScreen;./screens/dashboard/Cart.tsx
==== ./screens/dashboard/Cart.tsx ====
import React, { useState, useEffect } from 'react';
import {
    View,
    Text,
    StyleSheet,
    ScrollView,
    TouchableOpacity,
    Image,
    Alert,
    TextInput,
    ActivityIndicator,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList, Product } from '../../types';
import { useCart } from '../../context/CartContext';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';
import { useAuth } from '../../context/AuthContext';
import NetInfo from '@react-native-community/netinfo';

type CartScreenNavigationProp = NativeStackNavigationProp<HomeStackParamList, 'Cart'>;

const CartScreen = () => {
    const navigation = useNavigation<CartScreenNavigationProp>();
    const { user } = useAuth();
    const {
        cartItems,
        updateQuantity,
        removeFromCart,
        clearCart,
        cartItemCount,
        totalPrice,
        refreshCart,
        isCartLoading,
        lastCartError
    } = useCart();
    const [loading, setLoading] = useState(false);
    const [couponCode, setCouponCode] = useState('');
    const [appliedCoupon, setAppliedCoupon] = useState(false);
    const [pollingCount, setPollingCount] = useState(0);
    const [lastUpdate, setLastUpdate] = useState<string>('Just now');
    const [connectionType, setConnectionType] = useState<string | null>(null);

    // ‚úÖ Effect untuk handle cart errors
    useEffect(() => {
        if (lastCartError) {
            Alert.alert(
                'Cart Error',
                lastCartError,
                [
                    { 
                        text: 'Clear Cart', 
                        onPress: () => handleClearCart(),
                        style: 'destructive'
                    },
                    { 
                        text: 'Retry', 
                        onPress: () => handleRefreshCart()
                    },
                    { 
                        text: 'Ignore', 
                        style: 'cancel' 
                    }
                ]
            );
        }
    }, [lastCartError]);

    // ‚úÖ POLLING IMPLEMENTATION dengan optimasi bandwidth
    useEffect(() => {
        let intervalId: NodeJS.Timeout;

        const startPolling = () => {
            console.log('üîÑ Starting cart polling...');
            intervalId = setInterval(async () => {
                try {
                    console.log('üì° Polling cart data...');
                    await refreshCart(); // Panggil API untuk refresh data cart
                    setPollingCount(prev => prev + 1);
                    setLastUpdate(new Date().toLocaleTimeString());

                    console.log('‚úÖ Cart data updated via polling');
                } catch (error) {
                    console.error('‚ùå Polling error:', error);
                }
            }, 15000); // Poll setiap 15 detik
        };

        const stopPolling = () => {
            console.log('üõë Stopping cart polling');
            if (intervalId) {
                clearInterval(intervalId);
            }
        };

        // Subscribe to network info changes
        const unsubscribeNetInfo = NetInfo.addEventListener(state => {
            const newConnectionType = state.type;
            setConnectionType(newConnectionType);

            console.log('üåê Connection type changed:', newConnectionType);

            // ‚úÖ OPTIMASI BANDWIDTH: Hentikan polling jika jaringan seluler
            if (newConnectionType === 'cellular') {
                console.log('üì± Cellular network detected - stopping polling to save data');
                stopPolling();
            } else if (newConnectionType === 'wifi' || newConnectionType === 'unknown') {
                console.log('üì∂ WiFi or unknown network - starting polling');
                stopPolling(); // Stop dulu untuk menghindari duplicate intervals
                startPolling();
            }
        });

        // Start polling initially
        startPolling();

        // Cleanup function
        return () => {
            console.log('üßπ Cleaning up polling interval');
            stopPolling();
            unsubscribeNetInfo();
        };
    }, [refreshCart]);

    // ‚úÖ Optimized quantity update dengan error handling
    const handleUpdateQuantity = async (productId: string, newQuantity: number) => {
        try {
            await updateQuantity(productId, newQuantity);
        } catch (error: any) {
            Alert.alert('Update Failed', error.message || 'Failed to update quantity');
        }
    };

    // ‚úÖ Optimized remove item dengan error handling
    const handleRemoveItem = async (itemId: string) => {
        Alert.alert(
            'Remove Item',
            'Are you sure you want to remove this item from your cart?',
            [
                { text: 'Cancel', style: 'cancel' },
                {
                    text: 'Remove',
                    style: 'destructive',
                    onPress: async () => {
                        try {
                            await removeFromCart(itemId);
                        } catch (error: any) {
                            Alert.alert('Remove Failed', error.message || 'Failed to remove item');
                        }
                    }
                }
            ]
        );
    };

    // ‚úÖ Handle clear cart dengan confirmation
    const handleClearCart = async () => {
        Alert.alert(
            'Clear Cart',
            'Are you sure you want to clear your entire cart?',
            [
                { text: 'Cancel', style: 'cancel' },
                {
                    text: 'Clear All',
                    style: 'destructive',
                    onPress: async () => {
                        try {
                            await clearCart();
                            Alert.alert('Success', 'Cart cleared successfully');
                        } catch (error: any) {
                            Alert.alert('Clear Failed', error.message || 'Failed to clear cart');
                        }
                    }
                }
            ]
        );
    };

    // ‚úÖ Function untuk manual refresh dengan error handling
    const handleManualRefresh = async () => {
        if (connectionType === 'cellular') {
            Alert.alert(
                'Data Saving Mode',
                'Polling is disabled on cellular network to save your data. Please connect to WiFi for automatic updates.',
                [{ text: 'OK' }]
            );
            return;
        }

        setLoading(true);
        try {
            await refreshCart();
            setLastUpdate(new Date().toLocaleTimeString());
            Alert.alert('Success', 'Cart updated successfully!');
        } catch (error) {
            Alert.alert('Error', 'Failed to refresh cart');
        } finally {
            setLoading(false);
        }
    };

    // ‚úÖ Refresh cart function dengan error handling
    const handleRefreshCart = async () => {
        try {
            setLoading(true);
            await refreshCart();
            setLastUpdate(new Date().toLocaleTimeString());
        } catch (error: any) {
            Alert.alert('Refresh Failed', error.message || 'Failed to refresh cart');
        } finally {
            setLoading(false);
        }
    };

    const applyCoupon = () => {
        if (!couponCode.trim()) {
            Alert.alert('Error', 'Please enter a coupon code');
            return;
        }

        // Simulasi coupon validation
        const validCoupons = ['SAVE10', 'WELCOME15', 'SUMMER20'];
        if (validCoupons.includes(couponCode.toUpperCase())) {
            setAppliedCoupon(true);
            Alert.alert('Success', 'Coupon applied successfully!');
        } else {
            Alert.alert('Invalid Coupon', 'The coupon code you entered is invalid.');
        }
    };

    const getSubtotal = () => {
        return totalPrice;
    };

    const getDiscount = () => {
        if (!appliedCoupon) return 0;
        return getSubtotal() * 0.1; // 10% discount
    };

    const getShippingFee = () => {
        return getSubtotal() > 100 ? 0 : 9.99; // Free shipping over $100
    };

    const getTax = () => {
        return (getSubtotal() - getDiscount()) * 0.0825; // 8.25% tax
    };

    const getTotal = () => {
        return getSubtotal() - getDiscount() + getShippingFee() + getTax();
    };

    const proceedToCheckout = () => {
        if (cartItems.length === 0) {
            Alert.alert('Empty Cart', 'Your cart is empty. Add some items before checkout.');
            return;
        }

        // Navigate to checkout with all cart items
        navigation.navigate('CheckoutModal', {
            cartItems,
            subtotal: getSubtotal(),
            discount: getDiscount(),
            shippingFee: getShippingFee(),
            tax: getTax(),
            total: getTotal()
        });
    };

    const continueShopping = () => {
        navigation.goBack();
    };

    // ‚úÖ Tampilkan status error banner
    const renderErrorBanner = () => {
        if (!lastCartError) return null;

        return (
            <View style={styles.errorBanner}>
                <FontAwesome6 name="triangle-exclamation" size={16} color="#ffffff" iconStyle='solid' />
                <Text style={styles.errorBannerText}>{lastCartError}</Text>
                <TouchableOpacity 
                    onPress={handleRefreshCart}
                    style={styles.retryButtonSmall}
                >
                    <Text style={styles.retryButtonText}>Retry</Text>
                </TouchableOpacity>
            </View>
        );
    };

    // ‚úÖ Tampilkan status polling dan koneksi
    const renderPollingStatus = () => (
        <View style={styles.pollingStatus}>
            <View style={styles.statusRow}>
                <Text style={styles.statusLabel}>Auto-refresh:</Text>
                <View style={[
                    styles.statusIndicator,
                    connectionType === 'cellular' ? styles.statusDisabled : styles.statusActive
                ]}>
                    <Text style={styles.statusText}>
                        {connectionType === 'cellular' ? 'Disabled (Cellular)' : 'Active'}
                    </Text>
                </View>
            </View>
            <View style={styles.statusRow}>
                <Text style={styles.statusLabel}>Last updated:</Text>
                <Text style={styles.statusValue}>{lastUpdate}</Text>
            </View>
            {connectionType === 'cellular' && (
                <TouchableOpacity style={styles.manualRefreshButton} onPress={handleManualRefresh}>
                    <FontAwesome6 name="rotate" size={14} color="#ffffff" iconStyle='solid' />
                    <Text style={styles.manualRefreshText}>Refresh Now</Text>
                </TouchableOpacity>
            )}
        </View>
    );

    // ‚úÖ Loading state untuk cart operations
    if (isCartLoading && cartItems.length === 0) {
        return (
            <View style={styles.loadingContainer}>
                <ActivityIndicator size="large" color="#10b981" />
                <Text style={styles.loadingText}>Loading your cart...</Text>
            </View>
        );
    }

    return (
        <View style={styles.container}>
            {/* Header dengan status polling dan error indicator */}
            <View style={styles.header}>
                <View style={styles.headerMain}>
                    <View style={styles.headerTitleContainer}>
                        <Text style={styles.headerTitle}>Shopping Cart</Text>
                        {lastCartError && (
                            <TouchableOpacity 
                                style={styles.errorIndicator}
                                onPress={handleRefreshCart}
                            >
                                <FontAwesome6 name="triangle-exclamation" size={16} color="#ffffff" iconStyle='solid' />
                            </TouchableOpacity>
                        )}
                    </View>
                    {cartItems.length > 0 && (
                        <TouchableOpacity 
                            style={styles.clearCartButton}
                            onPress={handleClearCart}
                        >
                            <FontAwesome6 name="broom" size={16} color="#ef4444" iconStyle='solid' />
                            <Text style={styles.clearCartText}>Clear</Text>
                        </TouchableOpacity>
                    )}
                </View>
                {renderPollingStatus()}
            </View>

            {/* Error Banner */}
            {renderErrorBanner()}

            <ScrollView
                style={styles.content}
                showsVerticalScrollIndicator={false}
                refreshControl={
                    <RefreshControl
                        refreshing={loading}
                        onRefresh={handleRefreshCart}
                        colors={['#10b981']}
                        tintColor="#10b981"
                    />
                }
            >
                {cartItems.length === 0 ? (
                    // Empty Cart State
                    <View style={styles.emptyContainer}>
                        <FontAwesome6 name="cart-shopping" size={80} color="#d1d5db" iconStyle='solid' />
                        <Text style={styles.emptyTitle}>Your cart is empty</Text>
                        <Text style={styles.emptySubtitle}>
                            Browse our products and add items to your cart
                        </Text>
                        <TouchableOpacity
                            style={styles.shopButton}
                            onPress={continueShopping}
                        >
                            <Text style={styles.shopButtonText}>Start Shopping</Text>
                        </TouchableOpacity>
                    </View>
                ) : (
                    // Cart Items
                    <>
                        {/* Cart Items List */}
                        <View style={styles.cartItemsSection}>
                            <View style={styles.sectionHeader}>
                                <Text style={styles.sectionTitle}>
                                    Cart Items ({cartItemCount})
                                </Text>
                                {isCartLoading && (
                                    <ActivityIndicator size="small" color="#10b981" />
                                )}
                            </View>
                            {cartItems.map((item) => (
                                <View key={item.id} style={styles.cartItem}>
                                    <Image
                                        source={{ uri: item.product.image }}
                                        style={styles.productImage}
                                    />
                                    <View style={styles.itemDetails}>
                                        <Text style={styles.productName} numberOfLines={2}>
                                            {item.product.name}
                                        </Text>
                                        {item.product.brand && (
                                            <Text style={styles.productBrand}>
                                                {item.product.brand}
                                            </Text>
                                        )}
                                        <Text style={styles.productPrice}>
                                            ${item.product.price.toLocaleString()}
                                        </Text>

                                        {/* Quantity Controls */}
                                        <View style={styles.quantityContainer}>
                                            <TouchableOpacity
                                                style={[
                                                    styles.quantityButton,
                                                    item.quantity <= 1 && styles.quantityButtonDisabled
                                                ]}
                                                onPress={() => handleUpdateQuantity(item.product.id, item.quantity - 1)}
                                                disabled={item.quantity <= 1 || isCartLoading}
                                            >
                                                <FontAwesome6 
                                                    name="minus" 
                                                    size={12} 
                                                    color={item.quantity <= 1 ? '#9ca3af' : '#374151'} 
                                                    iconStyle='solid' 
                                                />
                                            </TouchableOpacity>
                                            <Text style={styles.quantityText}>{item.quantity}</Text>
                                            <TouchableOpacity
                                                style={[
                                                    styles.quantityButton,
                                                    item.quantity >= (item.product.stock || 10) && styles.quantityButtonDisabled
                                                ]}
                                                onPress={() => handleUpdateQuantity(item.product.id, item.quantity + 1)}
                                                disabled={item.quantity >= (item.product.stock || 10) || isCartLoading}
                                            >
                                                <FontAwesome6 
                                                    name="plus" 
                                                    size={12} 
                                                    color={item.quantity >= (item.product.stock || 10) ? '#9ca3af' : '#374151'} 
                                                    iconStyle='solid' 
                                                />
                                            </TouchableOpacity>
                                        </View>
                                    </View>

                                    {/* Item Total & Remove */}
                                    <View style={styles.itemActions}>
                                        <Text style={styles.itemTotal}>
                                            ${(item.product.price * item.quantity).toLocaleString()}
                                        </Text>
                                        <TouchableOpacity
                                            style={styles.removeButton}
                                            onPress={() => handleRemoveItem(item.product.id)}
                                            disabled={isCartLoading}
                                        >
                                            <FontAwesome6 name="trash" size={16} color="#ef4444" iconStyle='solid' />
                                        </TouchableOpacity>
                                    </View>
                                </View>
                            ))}
                        </View>

                        {/* Coupon Section */}
                        <View style={styles.section}>
                            <Text style={styles.sectionTitle}>Have a coupon?</Text>
                            <View style={styles.couponContainer}>
                                <TextInput
                                    style={styles.couponInput}
                                    placeholder="Enter coupon code"
                                    value={couponCode}
                                    onChangeText={setCouponCode}
                                    editable={!appliedCoupon && !isCartLoading}
                                    placeholderTextColor="#999"
                                />
                                <TouchableOpacity
                                    style={[
                                        styles.couponButton,
                                        appliedCoupon && styles.couponButtonApplied,
                                        isCartLoading && styles.buttonDisabled
                                    ]}
                                    onPress={appliedCoupon ? () => setAppliedCoupon(false) : applyCoupon}
                                    disabled={isCartLoading}
                                >
                                    <Text style={styles.couponButtonText}>
                                        {appliedCoupon ? 'Applied' : 'Apply'}
                                    </Text>
                                </TouchableOpacity>
                            </View>
                        </View>

                        {/* Order Summary */}
                        <View style={styles.section}>
                            <Text style={styles.sectionTitle}>Order Summary</Text>
                            <View style={styles.summary}>
                                <View style={styles.summaryRow}>
                                    <Text style={styles.summaryLabel}>Subtotal</Text>
                                    <Text style={styles.summaryValue}>
                                        ${getSubtotal().toFixed(2)}
                                    </Text>
                                </View>

                                {appliedCoupon && (
                                    <View style={styles.summaryRow}>
                                        <Text style={[styles.summaryLabel, styles.discountText]}>
                                            Discount (10%)
                                        </Text>
                                        <Text style={[styles.summaryValue, styles.discountText]}>
                                            -${getDiscount().toFixed(2)}
                                        </Text>
                                    </View>
                                )}

                                <View style={styles.summaryRow}>
                                    <Text style={styles.summaryLabel}>Shipping</Text>
                                    <Text style={styles.summaryValue}>
                                        {getShippingFee() === 0 ? 'FREE' : `$${getShippingFee().toFixed(2)}`}
                                    </Text>
                                </View>

                                <View style={styles.summaryRow}>
                                    <Text style={styles.summaryLabel}>Tax</Text>
                                    <Text style={styles.summaryValue}>
                                        ${getTax().toFixed(2)}
                                    </Text>
                                </View>

                                <View style={[styles.summaryRow, styles.totalRow]}>
                                    <Text style={styles.totalLabel}>Total</Text>
                                    <Text style={styles.totalValue}>
                                        ${getTotal().toFixed(2)}
                                    </Text>
                                </View>

                                {getShippingFee() === 0 && (
                                    <Text style={styles.freeShippingText}>
                                        üéâ You qualify for free shipping!
                                    </Text>
                                )}
                            </View>
                        </View>

                        {/* Security Badge */}
                        <View style={styles.securitySection}>
                            <FontAwesome6 name="shield" size={16} color="#10b981" iconStyle='solid' />
                            <Text style={styles.securityText}>
                                Secure checkout ‚Ä¢ Your information is safe
                            </Text>
                        </View>
                    </>
                )}
            </ScrollView>

            {/* Checkout Button */}
            {cartItems.length > 0 && (
                <View style={styles.footer}>
                    <TouchableOpacity
                        style={[
                            styles.checkoutButton,
                            isCartLoading && styles.buttonDisabled
                        ]}
                        onPress={proceedToCheckout}
                        disabled={isCartLoading}
                    >
                        <View style={styles.checkoutInfo}>
                            <Text style={styles.checkoutText}>
                                {isCartLoading ? 'Processing...' : 'Proceed to Checkout'}
                            </Text>
                            <Text style={styles.checkoutTotal}>${getTotal().toFixed(2)}</Text>
                        </View>
                        {!isCartLoading && (
                            <FontAwesome6 name="arrow-right" size={16} color="#ffffff" iconStyle='solid' />
                        )}
                    </TouchableOpacity>
                </View>
            )}
        </View>
    );
};

// Tambahkan RefreshControl import
import { RefreshControl } from 'react-native';

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#9bf89bff',
    },
    loadingContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#f8fafc',
    },
    loadingText: {
        marginTop: 16,
        fontSize: 16,
        color: '#6b7280',
    },
    header: {
        padding: 20,
        paddingTop: 20,
        backgroundColor: '#9bf89bff',
        borderBottomWidth: 1,
        borderBottomColor: '#e5e7eb',
    },
    headerMain: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        marginBottom: 12,
    },
    headerTitleContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: 8,
    },
    headerTitle: {
        fontSize: 20,
        fontWeight: '700',
        color: '#111827',
    },
    errorIndicator: {
        backgroundColor: '#ef4444',
        width: 24,
        height: 24,
        borderRadius: 12,
        justifyContent: 'center',
        alignItems: 'center',
    },
    clearCartButton: {
        flexDirection: 'row',
        alignItems: 'center',
        backgroundColor: '#fef2f2',
        paddingHorizontal: 12,
        paddingVertical: 6,
        borderRadius: 6,
        gap: 4,
    },
    clearCartText: {
        color: '#ef4444',
        fontSize: 12,
        fontWeight: '600',
    },
    errorBanner: {
        backgroundColor: '#ef4444',
        flexDirection: 'row',
        alignItems: 'center',
        padding: 12,
        margin: 16,
        borderRadius: 8,
        gap: 8,
    },
    errorBannerText: {
        color: '#ffffff',
        fontSize: 14,
        flex: 1,
        fontWeight: '500',
    },
    retryButtonSmall: {
        backgroundColor: 'rgba(255,255,255,0.3)',
        paddingHorizontal: 12,
        paddingVertical: 6,
        borderRadius: 4,
    },
    retryButtonText: {
        color: '#ffffff',
        fontSize: 12,
        fontWeight: '600',
    },
    pollingStatus: {
        backgroundColor: '#3fa34cff',
        padding: 12,
        borderRadius: 8,
        borderWidth: 1,
        borderColor: '#e5e7eb',
    },
    statusRow: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 6,
    },
    statusLabel: {
        fontSize: 12,
        color: '#e8f7e7ff',
        fontWeight: '500',
    },
    statusIndicator: {
        paddingHorizontal: 8,
        paddingVertical: 4,
        borderRadius: 12,
    },
    statusActive: {
        backgroundColor: '#d1fae5',
    },
    statusDisabled: {
        backgroundColor: '#fef3c7',
    },
    statusText: {
        fontSize: 10,
        fontWeight: '600',
    },
    statusValue: {
        fontSize: 12,
        color: '#374151',
        fontWeight: '500',
    },
    manualRefreshButton: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: '#10b981',
        padding: 8,
        borderRadius: 6,
        gap: 6,
        marginTop: 4,
    },
    manualRefreshText: {
        color: '#ffffff',
        fontSize: 12,
        fontWeight: '600',
    },
    content: {
        flex: 1,
        padding: 16,
    },
    emptyContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        paddingVertical: 100,
    },
    emptyTitle: {
        fontSize: 24,
        fontWeight: '700',
        color: '#374151',
        marginTop: 24,
        marginBottom: 8,
    },
    emptySubtitle: {
        fontSize: 16,
        color: '#6b7280',
        textAlign: 'center',
        marginBottom: 32,
    },
    shopButton: {
        backgroundColor: '#10b981',
        paddingHorizontal: 32,
        paddingVertical: 16,
        borderRadius: 12,
    },
    shopButtonText: {
        color: '#ffffff',
        fontSize: 16,
        fontWeight: '600',
    },
    section: {
        backgroundColor: '#ffffff',
        padding: 20,
        borderRadius: 12,
        marginBottom: 16,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.05,
        shadowRadius: 3,
        elevation: 2,
        borderWidth: 1,
        borderColor: '#f3f4f6',
    },
    cartItemsSection: {
        backgroundColor: '#ffffff',
        padding: 20,
        borderRadius: 12,
        marginBottom: 16,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.05,
        shadowRadius: 3,
        elevation: 2,
        borderWidth: 1,
        borderColor: '#f3f4f6',
    },
    sectionHeader: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 16,
    },
    sectionTitle: {
        fontSize: 18,
        fontWeight: '600',
        color: '#111827',
    },
    cartItem: {
        flexDirection: 'row',
        alignItems: 'center',
        padding: 16,
        backgroundColor: '#f8fafc',
        borderRadius: 8,
        marginBottom: 12,
        borderWidth: 1,
        borderColor: '#e5e7eb',
    },
    productImage: {
        width: 60,
        height: 60,
        borderRadius: 8,
        marginRight: 12,
    },
    itemDetails: {
        flex: 1,
    },
    productName: {
        fontSize: 16,
        fontWeight: '600',
        color: '#111827',
        marginBottom: 4,
    },
    productBrand: {
        fontSize: 12,
        color: '#6b7280',
        marginBottom: 4,
    },
    productPrice: {
        fontSize: 16,
        fontWeight: '700',
        color: '#059669',
        marginBottom: 8,
    },
    quantityContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        backgroundColor: '#ffffff',
        borderWidth: 1,
        borderColor: '#d1d5db',
        borderRadius: 6,
        padding: 4,
        alignSelf: 'flex-start',
    },
    quantityButton: {
        width: 24,
        height: 24,
        borderRadius: 4,
        backgroundColor: '#f9fafb',
        justifyContent: 'center',
        alignItems: 'center',
    },
    quantityButtonDisabled: {
        backgroundColor: '#f3f4f6',
    },
    quantityText: {
        fontSize: 14,
        fontWeight: '600',
        color: '#374151',
        marginHorizontal: 12,
        minWidth: 20,
        textAlign: 'center',
    },
    itemActions: {
        alignItems: 'flex-end',
        gap: 8,
    },
    itemTotal: {
        fontSize: 16,
        fontWeight: '700',
        color: '#111827',
    },
    removeButton: {
        padding: 6,
        borderRadius: 6,
        backgroundColor: '#fef2f2',
    },
    couponContainer: {
        flexDirection: 'row',
        gap: 12,
    },
    couponInput: {
        flex: 1,
        backgroundColor: '#ffffff',
        borderWidth: 1,
        borderColor: '#d1d5db',
        borderRadius: 8,
        padding: 12,
        fontSize: 16,
        color: '#111827',
    },
    couponButton: {
        backgroundColor: '#10b981',
        paddingHorizontal: 20,
        paddingVertical: 12,
        borderRadius: 8,
        justifyContent: 'center',
    },
    couponButtonApplied: {
        backgroundColor: '#059669',
    },
    buttonDisabled: {
        backgroundColor: '#9ca3af',
        opacity: 0.6,
    },
    couponButtonText: {
        color: '#ffffff',
        fontSize: 14,
        fontWeight: '600',
    },
    summary: {
        gap: 12,
    },
    summaryRow: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        paddingVertical: 4,
    },
    summaryLabel: {
        fontSize: 16,
        color: '#6b7280',
        fontWeight: '500',
    },
    summaryValue: {
        fontSize: 16,
        color: '#374151',
        fontWeight: '500',
    },
    discountText: {
        color: '#ef4444',
    },
    totalRow: {
        paddingTop: 12,
        borderTopWidth: 1,
        borderTopColor: '#e5e7eb',
        marginTop: 4,
    },
    totalLabel: {
        fontSize: 18,
        fontWeight: '600',
        color: '#111827',
    },
    totalValue: {
        fontSize: 18,
        fontWeight: '700',
        color: '#059669',
    },
    freeShippingText: {
        fontSize: 14,
        color: '#10b981',
        fontWeight: '600',
        textAlign: 'center',
        marginTop: 8,
    },
    securitySection: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        padding: 16,
        gap: 8,
    },
    securityText: {
        fontSize: 14,
        color: '#6b7280',
        fontWeight: '500',
    },
    footer: {
        padding: 16,
        backgroundColor: '#ffffff',
        borderTopWidth: 1,
        borderTopColor: '#e5e7eb',
        shadowColor: '#000',
        shadowOffset: { width: 0, height: -2 },
        shadowOpacity: 0.1,
        shadowRadius: 8,
        elevation: 8,
    },
    checkoutButton: {
        backgroundColor: '#10b981',
        padding: 16,
        borderRadius: 12,
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        shadowColor: '#10b981',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.3,
        shadowRadius: 8,
        elevation: 6,
    },
    checkoutInfo: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: 8,
    },
    checkoutText: {
        color: '#ffffff',
        fontSize: 16,
        fontWeight: '600',
    },
    checkoutTotal: {
        color: '#ffffff',
        fontSize: 18,
        fontWeight: '700',
    },
});

export default CartScreen;./screens/dashboard/CheckoutModal.tsx
==== ./screens/dashboard/CheckoutModal.tsx ====
import React, { useState } from 'react';
import {
    View,
    Text,
    StyleSheet,
    ScrollView,
    TouchableOpacity,
    Image,
    TextInput,
    Alert,
    Modal,
    KeyboardAvoidingView,
    Platform,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList, CartItem, Product } from '../../types';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';

type ModalCheckoutNavigationProp = NativeStackNavigationProp<HomeStackParamList, 'CheckoutModal'>;

// Mock Axios Interceptor (dalam aplikasi nyata, ini akan di setup di file terpisah)
const setupAxiosInterceptor = () => {
  // Simulasi interceptor yang akan menangkap error 400
  return {
    intercept: (callback: (errors: FormErrors) => void) => {
      // Dalam implementasi nyata, ini akan menjadi axios.interceptors.response.use()
      console.log('üõ°Ô∏è Axios Response Interceptor configured');
    }
  };
};

// Type untuk form errors
interface FormErrors {
  firstName?: string;
  lastName?: string;
  email?: string;
  phone?: string;
  addressLine1?: string;
  addressLine2?: string;
  city?: string;
  state?: string;
  postalCode?: string;
  country?: string;
  cardNumber?: string;
  expiryDate?: string;
  cvv?: string;
  cardholderName?: string;
  general?: string;
}

const CheckoutModalScreen = () => {
    const navigation = useNavigation<ModalCheckoutNavigationProp>();
    const route = useRoute();

    type ShippingMethod = 'standard' | 'express' | 'priority';
    type PaymentMethod = 'credit_card' | 'paypal' | 'apple_pay';

    const [shippingMethod, setShippingMethod] = useState<ShippingMethod>('standard');
    const [isProcessing, setIsProcessing] = useState(false);
    const [paymentMethod, setPaymentMethod] = useState<PaymentMethod>('credit_card');

    // State untuk form data dengan validasi lebih lengkap
    const [formData, setFormData] = useState({
        // Shipping Information
        firstName: '',
        lastName: '',
        email: '',
        phone: '',

        // Address Information
        addressLine1: '',
        addressLine2: '',
        city: '',
        state: '',
        postalCode: '',
        country: 'United States',

        // Payment Information (untuk credit card)
        cardNumber: '',
        expiryDate: '',
        cvv: '',
        cardholderName: '',
    });

    // State untuk form errors dari server
    const [formErrors, setFormErrors] = useState<FormErrors>({});

    // Terima data dari route. Tipe sudah dijamin oleh HomeStackParamList.
    const { cartItems, subtotal = 0, discount = 0, shippingFee = 0, tax = 0, total = 0 } = (route.params as HomeStackParamList['CheckoutModal']) || {};

    const [checkoutItems, setCheckoutItems] = useState<CartItem[]>(cartItems || []);

    // Setup Axios Interceptor ketika komponen mount
    React.useEffect(() => {
        const interceptor = setupAxiosInterceptor();
        interceptor.intercept((errors: FormErrors) => {
            console.log('üî¥ Server validation errors:', errors);
            setFormErrors(errors);
            setIsProcessing(false);
        });
    }, []);

    const getShippingFee = (): number => {
        const fees: Record<ShippingMethod, number> = {
            standard: 4.99,
            express: 14.99,
            priority: 24.99
        };
        return fees[shippingMethod];
    };

    const getShippingTime = (): string => {
        const times: Record<ShippingMethod, string> = {
            standard: '5-7 business days',
            express: '2-3 business days',
            priority: '1-2 business days'
        };
        return times[shippingMethod];
    };

    // Validasi form yang lebih komprehensif
    const isFormValid =
        formData.firstName.trim() &&
        formData.lastName.trim() &&
        formData.email.trim() &&
        /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email) && // Email validation
        formData.phone.trim() &&
        formData.addressLine1.trim() &&
        formData.city.trim() &&
        formData.state.trim() &&
        formData.postalCode.trim() &&
        (paymentMethod !== 'credit_card' || (
            formData.cardNumber.replace(/\s/g, '').length === 16 &&
            formData.expiryDate.trim() &&
            formData.cvv.trim() &&
            formData.cardholderName.trim()
        ));

    const handleQuantityChange = (change: number) => {
        // Fungsi ini hanya relevan jika checkout dari 1 produk
        if (checkoutItems.length === 1) {
            const item = checkoutItems[0];
            const newQuantity = item.quantity + change;
            if (newQuantity >= 1 && newQuantity <= (item.product.stock || 10)) {
                const updatedItems = [{ ...item, quantity: newQuantity }];
                setCheckoutItems(updatedItems);
            }
        }
    };    

    const formatCardNumber = (text: string) => {
        const cleaned = text.replace(/\s/g, '').replace(/\D/g, '');
        const formatted = cleaned.replace(/(\d{4})/g, '$1 ').trim();
        return formatted.slice(0, 19); // 16 digits + 3 spaces
    };

    const formatExpiryDate = (text: string) => {
        const cleaned = text.replace(/\D/g, '');
        if (cleaned.length >= 2) {
            return cleaned.slice(0, 2) + '/' + cleaned.slice(2, 4);
        }
        return cleaned;
    };

    // Simulasi API call yang mungkin return error 400
    const mockApiCall = async (): Promise<{ success: boolean; errors?: any }> => {
        return new Promise((resolve) => {
            setTimeout(() => {
                // Simulasi server validation error
                const hasError = Math.random() > 0.7; // 30% chance of error untuk testing
                
                if (hasError) {
                    resolve({
                        success: false,
                        errors: {
                            firstName: !formData.firstName ? 'First name is required' : undefined,
                            email: !formData.email ? 'Email is required' : 
                                  !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email) ? 'Invalid email format' : undefined,
                            addressLine1: !formData.addressLine1 ? 'Address is required' : undefined,
                            city: !formData.city ? 'City is required' : undefined,
                            postalCode: !formData.postalCode ? 'Postal code is required' : 
                                       formData.postalCode.length < 5 ? 'Postal code must be at least 5 characters' : undefined,
                            cardNumber: paymentMethod === 'credit_card' && !formData.cardNumber ? 'Card number is required' : undefined,
                        }
                    });
                } else {
                    resolve({ success: true });
                }
            }, 2000);
        });
    };

    const handleCheckout = async () => {
        if (!isFormValid) {
            Alert.alert('Incomplete Information', 'Please fill in all required fields correctly.');
            return;
        }

        setIsProcessing(true);
        setFormErrors({}); // Clear previous errors

        try {
            // Simulasi API call yang mungkin return validation errors
            const result = await mockApiCall();

            if (!result.success && result.errors) {
                // Simulasi Axios Interceptor menangkap error 400
                console.log('üîÑ Interceptor capturing 400 error:', result.errors);
                setFormErrors(result.errors);
                setIsProcessing(false);
                return;
            }

            // Jika sukses, lanjutkan dengan order confirmation
            await new Promise(resolve => setTimeout(resolve, 1000));

            setIsProcessing(false);
            Alert.alert(
                'üéâ Order Confirmed!',
                `Thank you for your purchase of ${checkoutItems.length} item(s)!\n\nTotal: $${total.toFixed(2)}\n\nA confirmation email has been sent to ${formData.email}`,
                [
                    {
                        text: 'Continue Shopping',
                        onPress: () => navigation.goBack(),
                    },
                ]
            );
        } catch (error) {
            setIsProcessing(false);
            Alert.alert('Payment Failed', 'There was an issue processing your payment. Please try again.');
        }
    };

    const handleClose = () => {
        if (isProcessing) return;
        Alert.alert(
            'Leave Checkout?',
            'Your progress will be lost if you leave this page.',
            [
                { text: 'Stay', style: 'cancel' },
                { text: 'Leave', onPress: () => navigation.goBack() }
            ]
        );
    };

    const updateFormData = (field: keyof typeof formData, value: string) => {
        let formattedValue = value;

        if (field === 'cardNumber') {
            formattedValue = formatCardNumber(value);
        } else if (field === 'expiryDate') {
            formattedValue = formatExpiryDate(value);
        } else if (field === 'phone') {
            formattedValue = value.replace(/\D/g, '').slice(0, 15);
        }

        setFormData(prev => ({
            ...prev,
            [field]: formattedValue
        }));

        // Clear error when user starts typing
        if (formErrors[field as keyof FormErrors]) {
            setFormErrors(prev => ({
                ...prev,
                [field]: undefined
            }));
        }
    };

    const InputField = ({
        label,
        field,
        placeholder,
        keyboardType = 'default',
        required = false,
        secureTextEntry = false
    }: {
        label: string;
        field: keyof typeof formData;
        placeholder: string;
        keyboardType?: any;
        required?: boolean;
        secureTextEntry?: boolean;
    }) => {
        const error = formErrors[field as keyof FormErrors];
        
        return (
            <View style={styles.inputGroup}>
                <Text style={styles.inputLabel}>
                    {label} {required && <Text style={styles.required}>*</Text>}
                </Text>
                <TextInput
                    style={[
                        styles.textInput,
                        (!formData[field] && required) && styles.inputError,
                        error && styles.inputError
                    ]}
                    placeholder={placeholder}
                    placeholderTextColor="#8a8a8a"
                    value={formData[field]}
                    onChangeText={(value) => updateFormData(field, value)}
                    keyboardType={keyboardType}
                    secureTextEntry={secureTextEntry}
                    autoCapitalize={field === 'email' ? 'none' : 'words'}
                />
                {error && (
                    <Text style={styles.errorText}>{error}</Text>
                )}
            </View>
        );
    };

    return (
        <Modal
            animationType="slide"
            presentationStyle="pageSheet"
            visible={true}
            onRequestClose={handleClose}
        >
            <KeyboardAvoidingView
                style={styles.container}
                behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
            >
                {/* Professional Header */}
                <View style={styles.header}>
                    <View style={styles.headerContent}>
                        <Text style={styles.headerTitle}>Checkout</Text>
                        <Text style={styles.headerSubtitle}>Complete your purchase</Text>
                    </View>
                    <TouchableOpacity
                        style={styles.closeButton}
                        onPress={handleClose}
                        disabled={isProcessing}
                    >
                        <FontAwesome6 name="xmark" size={20} color="#6b7280" iconStyle='solid' />
                    </TouchableOpacity>
                </View>

                <ScrollView
                    style={styles.content}
                    showsVerticalScrollIndicator={false}
                    contentContainerStyle={styles.scrollContent}
                >
                    {/* Progress Steps */}
                    <View style={styles.progressSteps}>
                        <View style={[styles.step, styles.stepActive]}>
                            <View style={styles.stepNumberActive}>
                                <Text style={styles.stepNumberText}>1</Text>
                            </View>
                            <Text style={styles.stepTextActive}>Shipping</Text>
                        </View>
                        <View style={styles.stepDivider} />
                        <View style={[styles.step, styles.stepActive]}>
                            <View style={styles.stepNumberActive}>
                                <Text style={styles.stepNumberText}>2</Text>
                            </View>
                            <Text style={styles.stepTextActive}>Payment</Text>
                        </View>
                        <View style={styles.stepDivider} />
                        <View style={styles.step}>
                            <View style={styles.stepNumber}>
                                <Text style={styles.stepNumberText}>3</Text>
                            </View>
                            <Text style={styles.stepText}>Review</Text>
                        </View>
                    </View>

                    {/* Server Validation Error Banner */}
                    {formErrors.general && (
                        <View style={styles.serverErrorBanner}>
                            <FontAwesome6 name="triangle-exclamation" size={16} color="#ffffff" iconStyle='solid' />
                            <Text style={styles.serverErrorText}>
                                Please check the form for errors
                            </Text>
                        </View>
                    )}

                    {/* Product Summary Card */}
                    <View style={styles.section}>
                        <Text style={styles.sectionTitle}>Order Summary</Text>
                        {checkoutItems.map((item) => (
                            <View key={item.id} style={styles.productCard}>
                                <Image
                                    source={{ uri: item.product.image || item.product.thumbnail }}
                                    style={styles.productImage}
                                />
                                <View style={styles.productDetails}>
                                    <Text style={styles.productName} numberOfLines={2}>
                                        {item.product.name}
                                    </Text>
                                    <Text style={styles.productCategory}>{item.product.category}</Text>
                                    <Text style={styles.productPrice}>
                                        ${item.product.price.toLocaleString()}
                                    </Text>

                                    {/* Quantity Controls (hanya jika 1 item) */}
                                    <View style={styles.quantitySection}>
                                        <Text style={styles.quantityLabel}>Quantity:</Text>
                                        {checkoutItems.length === 1 ? (
                                            <View style={styles.quantityControls}>
                                                <TouchableOpacity
                                                    style={[styles.quantityButton, item.quantity <= 1 && styles.quantityButtonDisabled]}
                                                    onPress={() => handleQuantityChange(-1)}
                                                    disabled={item.quantity <= 1}
                                                >
                                                    <FontAwesome6 name="minus" size={14} color={item.quantity <= 1 ? '#9ca3af' : '#374151'} iconStyle='solid' />
                                                </TouchableOpacity>
                                                <Text style={styles.quantityText}>{item.quantity}</Text>
                                                <TouchableOpacity
                                                    style={[styles.quantityButton, item.quantity >= (item.product.stock || 10) && styles.quantityButtonDisabled]}
                                                    onPress={() => handleQuantityChange(1)}
                                                    disabled={item.quantity >= (item.product.stock || 10)}
                                                >
                                                    <FontAwesome6 name="plus" size={14} color={item.quantity >= (item.product.stock || 10) ? '#9ca3af' : '#374151'} iconStyle='solid' />
                                                </TouchableOpacity>
                                            </View>
                                        ) : (
                                            <Text style={styles.quantityTextStatic}>{item.quantity}</Text>
                                        )}
                                    </View>
                                </View>
                            </View>
                        ))}
                    </View>

                    {/* Contact Information */}
                    <View style={styles.section}>
                        <Text style={styles.sectionTitle}>Contact Information</Text>
                        <View style={styles.rowInput}>
                            <View style={[styles.inputGroup, { flex: 1 }]}>
                                <InputField
                                    label="First Name"
                                    field="firstName"
                                    placeholder="John"
                                    required
                                />
                            </View>
                            <View style={[styles.inputGroup, { flex: 1 }]}>
                                <InputField
                                    label="Last Name"
                                    field="lastName"
                                    placeholder="Doe"
                                    required
                                />
                            </View>
                        </View>

                        <InputField
                            label="Email Address"
                            field="email"
                            placeholder="john.doe@example.com"
                            keyboardType="email-address"
                            required
                        />

                        <InputField
                            label="Phone Number"
                            field="phone"
                            placeholder="(555) 123-4567"
                            keyboardType="phone-pad"
                            required
                        />
                    </View>

                    {/* Shipping Address */}
                    <View style={styles.section}>
                        <Text style={styles.sectionTitle}>Shipping Address</Text>

                        <InputField
                            label="Address Line 1"
                            field="addressLine1"
                            placeholder="Street address, P.O. box"
                            required
                        />

                        <InputField
                            label="Address Line 2"
                            field="addressLine2"
                            placeholder="Apartment, suite, unit, building, floor, etc."
                        />

                        <View style={styles.rowInput}>
                            <View style={[styles.inputGroup, { flex: 2 }]}>
                                <InputField
                                    label="City"
                                    field="city"
                                    placeholder="City"
                                    required
                                />
                            </View>
                            <View style={[styles.inputGroup, { flex: 1 }]}>
                                <InputField
                                    label="State"
                                    field="state"
                                    placeholder="State"
                                    required
                                />
                            </View>
                        </View>

                        <View style={styles.rowInput}>
                            <View style={[styles.inputGroup, { flex: 1 }]}>
                                <InputField
                                    label="Postal Code"
                                    field="postalCode"
                                    placeholder="ZIP code"
                                    keyboardType="numeric"
                                    required
                                />
                            </View>
                            <View style={[styles.inputGroup, { flex: 2 }]}>
                                <InputField
                                    label="Country"
                                    field="country"
                                    placeholder="Country"
                                />
                            </View>
                        </View>
                    </View>

                    {/* Shipping Method */}
                    <View style={styles.section}>
                        <Text style={styles.sectionTitle}>Shipping Method</Text>

                        {(['standard', 'express', 'priority'] as ShippingMethod[]).map((method) => (
                            <TouchableOpacity
                                key={method}
                                style={[
                                    styles.shippingOption,
                                    shippingMethod === method && styles.shippingOptionSelected
                                ]}
                                onPress={() => setShippingMethod(method)}
                            >
                                <View style={styles.shippingRadio}>
                                    <View style={[
                                        styles.radioCircle,
                                        shippingMethod === method && styles.radioCircleSelected
                                    ]}>
                                        {shippingMethod === method && <View style={styles.radioInner} />}
                                    </View>
                                </View>
                                <View style={styles.shippingInfo}>
                                    <Text style={[
                                        styles.shippingName,
                                        shippingMethod === method && styles.shippingNameSelected
                                    ]}>
                                        {method.charAt(0).toUpperCase() + method.slice(1)} Shipping
                                    </Text>
                                    <Text style={[
                                        styles.shippingDetails,
                                        shippingMethod === method && styles.shippingDetailsSelected
                                    ]}>
                                        {getShippingTime()}
                                    </Text>
                                </View>
                                <Text style={[
                                    styles.shippingPrice,
                                    shippingMethod === method && styles.shippingPriceSelected
                                ]}>
                                    ${getShippingFee().toFixed(2)}
                                </Text>
                            </TouchableOpacity>
                        ))}
                    </View>

                    {/* Payment Method */}
                    <View style={styles.section}>
                        <Text style={styles.sectionTitle}>Payment Method</Text>

                        {/* Credit Card Option */}
                        <TouchableOpacity
                            style={[
                                styles.paymentOption,
                                paymentMethod === 'credit_card' && styles.paymentOptionSelected
                            ]}
                            onPress={() => setPaymentMethod('credit_card')}
                        >
                            <View style={styles.paymentRadio}>
                                <View style={[
                                    styles.radioCircle,
                                    paymentMethod === 'credit_card' && styles.radioCircleSelected
                                ]}>
                                    {paymentMethod === 'credit_card' && <View style={styles.radioInner} />}
                                </View>
                            </View>
                            <View style={styles.paymentIconContainer}>
                                <FontAwesome6
                                    name="credit-card"
                                    size={20}
                                    color={paymentMethod === 'credit_card' ? '#ffffff' : '#6b7280'}
                                />
                            </View>
                            <Text style={[
                                styles.paymentText,
                                paymentMethod === 'credit_card' && styles.paymentTextSelected
                            ]}>
                                Credit Card
                            </Text>
                        </TouchableOpacity>

                        {/* PayPal Option */}
                        <TouchableOpacity
                            style={[
                                styles.paymentOption,
                                paymentMethod === 'paypal' && styles.paymentOptionSelected
                            ]}
                            onPress={() => setPaymentMethod('paypal')}
                        >
                            <View style={styles.paymentRadio}>
                                <View style={[
                                    styles.radioCircle,
                                    paymentMethod === 'paypal' && styles.radioCircleSelected
                                ]}>
                                    {paymentMethod === 'paypal' && <View style={styles.radioInner} />}
                                </View>
                            </View>
                            <View style={styles.paymentIconContainer}>
                                <FontAwesome6
                                    name="paypal"
                                    size={20}
                                    color={paymentMethod === 'paypal' ? '#ffffff' : '#6b7280'}
                                    iconStyle='brand'
                                />
                            </View>
                            <Text style={[
                                styles.paymentText,
                                paymentMethod === 'paypal' && styles.paymentTextSelected
                            ]}>
                                PayPal
                            </Text>
                        </TouchableOpacity>

                        {/* Apple Pay Option */}
                        <TouchableOpacity
                            style={[
                                styles.paymentOption,
                                paymentMethod === 'apple_pay' && styles.paymentOptionSelected
                            ]}
                            onPress={() => setPaymentMethod('apple_pay')}
                        >
                            <View style={styles.paymentRadio}>
                                <View style={[
                                    styles.radioCircle,
                                    paymentMethod === 'apple_pay' && styles.radioCircleSelected
                                ]}>
                                    {paymentMethod === 'apple_pay' && <View style={styles.radioInner} />}
                                </View>
                            </View>
                            <View style={styles.paymentIconContainer}>
                                <FontAwesome6
                                    name="apple"
                                    size={20}
                                    color={paymentMethod === 'apple_pay' ? '#ffffff' : '#6b7280'}
                                    iconStyle='brand'
                                />
                            </View>
                            <Text style={[
                                styles.paymentText,
                                paymentMethod === 'apple_pay' && styles.paymentTextSelected
                            ]}>
                                Apple Pay
                            </Text>
                        </TouchableOpacity>

                        {/* Credit Card Details */}
                        {paymentMethod === 'credit_card' && (
                            <View style={styles.cardDetails}>
                                <InputField
                                    label="Cardholder Name"
                                    field="cardholderName"
                                    placeholder="John Doe"
                                    required
                                />

                                <InputField
                                    label="Card Number"
                                    field="cardNumber"
                                    placeholder="1234 5678 9012 3456"
                                    keyboardType="numeric"
                                    required
                                />

                                <View style={styles.rowInput}>
                                    <View style={[styles.inputGroup, { flex: 2 }]}>
                                        <InputField
                                            label="Expiry Date"
                                            field="expiryDate"
                                            placeholder="MM/YY"
                                            keyboardType="numeric"
                                            required
                                        />
                                    </View>
                                    <View style={[styles.inputGroup, { flex: 1 }]}>
                                        <InputField
                                            label="CVV"
                                            field="cvv"
                                            placeholder="123"
                                            keyboardType="numeric"
                                            secureTextEntry
                                            required
                                        />
                                    </View>
                                </View>
                            </View>
                        )}
                    </View>

                    {/* Order Summary */}
                    <View style={styles.section}>
                        <Text style={styles.sectionTitle}>Order Total</Text>
                        <View style={styles.orderSummary}>
                            <View style={styles.summaryRow}>
                                <Text style={styles.summaryLabel}>Subtotal ({checkoutItems.reduce((sum, i) => sum + i.quantity, 0)} items)</Text>
                                <Text style={styles.summaryValue}>${subtotal.toFixed(2)}</Text>
                            </View>
                            <View style={styles.summaryRow}>
                                <Text style={styles.summaryLabel}>Shipping</Text>
                                <Text style={styles.summaryValue}>${shippingFee.toFixed(2)}</Text>
                            </View>
                            <View style={styles.summaryRow}>
                                <Text style={styles.summaryLabel}>Tax</Text>
                                <Text style={styles.summaryValue}>${tax.toFixed(2)}</Text>
                            </View>
                            <View style={[styles.summaryRow, styles.totalRow]}>
                                <Text style={styles.totalLabel}>Total</Text>
                                <Text style={styles.totalValue}>${total.toFixed(2)}</Text>
                            </View>
                        </View>
                    </View>

                    {/* Security Badge */}
                    <View style={styles.securitySection}>
                        <FontAwesome6 name="shield" size={16} color="#10b981" iconStyle='solid' />
                        <Text style={styles.securityText}>
                            Your payment information is secure and encrypted
                        </Text>
                    </View>
                </ScrollView>

                {/* Fixed Footer */}
                <View style={styles.footer}>
                    <View style={styles.footerContent}>
                        <View style={styles.totalContainer}>
                            <Text style={styles.footerTotalLabel}>Total Amount</Text>
                            <Text style={styles.footerTotalValue}>${total.toFixed(2)}</Text>
                        </View>
                        <TouchableOpacity
                            style={[
                                styles.checkoutButton,
                                (isProcessing || !isFormValid) && styles.checkoutButtonDisabled
                            ]}
                            onPress={handleCheckout}
                            disabled={isProcessing || !isFormValid}
                        >
                            {isProcessing ? (
                                <>
                                    <FontAwesome6 name="spinner" size={16} color="#ffffff" iconStyle='solid' />
                                    <Text style={styles.checkoutButtonText}> Processing Payment...</Text>
                                </>
                            ) : (
                                <>
                                    <FontAwesome6 name="lock" size={16} color="#ffffff" iconStyle='solid' />
                                    <Text style={styles.checkoutButtonText}> Pay ${total.toFixed(2)}</Text>
                                </>
                            )}
                        </TouchableOpacity>
                    </View>
                </View>
            </KeyboardAvoidingView>
        </Modal>
    );
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor:'#9bf89bff',
    },
    header: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'flex-start',
        padding: 24,
        paddingTop: Platform.OS === 'ios' ? 60 : 24,
        backgroundColor: '#ffffff',
        borderBottomWidth: 1,
        borderBottomColor: '#e5e7eb',
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.05,
        shadowRadius: 3,
        elevation: 3,
    },
    headerContent: {
        flex: 1,
    },
    headerTitle: {
        fontSize: 24,
        fontWeight: '700',
        color: '#111827',
        marginBottom: 4,
    },
    headerSubtitle: {
        fontSize: 14,
        color: '#6b7280',
        fontWeight: '500',
    },
    closeButton: {
        padding: 8,
        borderRadius: 8,
        backgroundColor: '#f3f4f6',
    },
    content: {
        flex: 1,
    },
    scrollContent: {
        padding: 16,
        paddingBottom: 120,
    },
    progressSteps: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        marginBottom: 24,
        paddingHorizontal: 20,
    },
    step: {
        alignItems: 'center',
        flex: 1,
    },
    stepActive: {
        // Active step styles
    },
    stepNumber: {
        width: 32,
        height: 32,
        borderRadius: 16,
        backgroundColor: '#f3f4f6',
        justifyContent: 'center',
        alignItems: 'center',
        marginBottom: 8,
    },
    stepNumberActive: {
        backgroundColor: '#10b981',
    },
    stepNumberText: {
        fontSize: 14,
        fontWeight: '600',
        color: '#9ca3af',
    },
    stepText: {
        fontSize: 12,
        color: '#9ca3af',
        fontWeight: '500',
    },
    stepTextActive: {
        color: '#10b981',
        fontWeight: '600',
    },
    stepDivider: {
        flex: 1,
        height: 2,
        backgroundColor: '#e5e7eb',
        marginHorizontal: 8,
        marginBottom: 20,
    },
    // Server Error Styles
    serverErrorBanner: {
        backgroundColor: '#dc2626',
        flexDirection: 'row',
        alignItems: 'center',
        padding: 12,
        borderRadius: 8,
        marginBottom: 16,
        gap: 8,
    },
    serverErrorText: {
        color: '#ffffff',
        fontSize: 14,
        fontWeight: '500',
    },
    errorText: {
        color: '#dc2626',
        fontSize: 12,
        marginTop: 4,
        fontWeight: '500',
    },
    section: {
        backgroundColor: '#ffffff',
        padding: 20,
        borderRadius: 12,
        marginBottom: 16,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.05,
        shadowRadius: 3,
        elevation: 2,
        borderWidth: 1,
        borderColor: '#f3f4f6',
    },
    sectionTitle: {
        fontSize: 18,
        fontWeight: '600',
        color: '#111827',
        marginBottom: 16,
    },
    productCard: {
        flexDirection: 'row',
        alignItems: 'center',
        padding: 16,
        backgroundColor: '#f8fafc',
        borderRadius: 8,
        borderWidth: 1,
        borderColor: '#e5e7eb',
    },
    productImage: {
        width: 80,
        height: 80,
        borderRadius: 8,
        marginRight: 16,
    },
    productDetails: {
        flex: 1,
    },
    productName: {
        fontSize: 16,
        fontWeight: '600',
        color: '#111827',
        marginBottom: 4,
    },
    productCategory: {
        fontSize: 14,
        color: '#6b7280',
        marginBottom: 8,
    },
    productPrice: {
        fontSize: 18,
        fontWeight: '700',
        color: '#059669',
        marginBottom: 12,
    },
    quantitySection: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
    },
    quantityLabel: {
        fontSize: 14,
        color: '#6b7280',
        fontWeight: '500',
    },
    quantityControls: {
        flexDirection: 'row',
        alignItems: 'center',
        backgroundColor: '#ffffff',
        borderWidth: 1,
        borderColor: '#d1d5db',
        borderRadius: 8,
        padding: 4,
    },
    quantityButton: {
        width: 32,
        height: 32,
        borderRadius: 6,
        backgroundColor: '#f9fafb',
        justifyContent: 'center',
        alignItems: 'center',
    },
    quantityButtonDisabled: {
        backgroundColor: '#f3f4f6',
    },
    quantityText: {
        fontSize: 14,
        fontWeight: '600',
        color: '#374151',
        marginHorizontal: 16,
        minWidth: 20,
        textAlign: 'center',
    },
    quantityTextStatic: {
        fontSize: 14,
        fontWeight: '600',
        color: '#374151',
    },
    inputGroup: {
        marginBottom: 16,
    },
    inputLabel: {
        fontSize: 14,
        fontWeight: '600',
        color: '#374151',
        marginBottom: 8,
    },
    required: {
        color: '#ef4444',
    },
    textInput: {
        backgroundColor: '#ffffff',
        borderWidth: 1,
        borderColor: '#d1d5db',
        borderRadius: 8,
        padding: 12,
        fontSize: 16,
        color: '#111827',
        fontWeight: '500',
    },
    inputError: {
        borderColor: '#dc2626',
    },
    rowInput: {
        flexDirection: 'row',
        gap: 12,
    },
    shippingOption: {
        flexDirection: 'row',
        alignItems: 'center',
        padding: 16,
        borderRadius: 8,
        borderWidth: 1,
        borderColor: '#d1d5db',
        backgroundColor: '#ffffff',
        marginBottom: 8,
    },
    shippingOptionSelected: {
        borderColor: '#10b981',
        backgroundColor: '#f0fdf4',
    },
    shippingRadio: {
        marginRight: 12,
    },
    radioCircle: {
        width: 20,
        height: 20,
        borderRadius: 10,
        borderWidth: 2,
        borderColor: '#d1d5db',
        justifyContent: 'center',
        alignItems: 'center',
    },
    radioCircleSelected: {
        borderColor: '#10b981',
        backgroundColor: '#10b981',
    },
    radioInner: {
        width: 8,
        height: 8,
        borderRadius: 4,
        backgroundColor: '#ffffff',
    },
    shippingInfo: {
        flex: 1,
    },
    shippingName: {
        fontSize: 16,
        color: '#374151',
        fontWeight: '500',
        marginBottom: 4,
    },
    shippingNameSelected: {
        color: '#065f46',
        fontWeight: '600',
    },
    shippingDetails: {
        fontSize: 14,
        color: '#6b7280',
    },
    shippingDetailsSelected: {
        color: '#047857',
    },
    shippingPrice: {
        fontSize: 16,
        color: '#374151',
        fontWeight: '600',
    },
    shippingPriceSelected: {
        color: '#065f46',
    },
    paymentOption: {
        flexDirection: 'row',
        alignItems: 'center',
        padding: 16,
        borderRadius: 8,
        borderWidth: 1,
        borderColor: '#d1d5db',
        backgroundColor: '#ffffff',
        marginBottom: 8,
    },
    paymentOptionSelected: {
        borderColor: '#10b981',
        backgroundColor: '#f0fdf4',
    },
    paymentRadio: {
        marginRight: 12,
    },
    paymentIconContainer: {
        marginRight: 12,
        width: 40,
        height: 40,
        borderRadius: 8,
        backgroundColor: '#f8fafc',
        justifyContent: 'center',
        alignItems: 'center',
    },
    paymentText: {
        fontSize: 16,
        color: '#374151',
        fontWeight: '500',
    },
    paymentTextSelected: {
        color: '#065f46',
        fontWeight: '600',
    },
    cardDetails: {
        marginTop: 16,
        padding: 16,
        backgroundColor: '#f8fafc',
        borderRadius: 8,
        borderWidth: 1,
        borderColor: '#e5e7eb',
    },
    orderSummary: {
        gap: 12,
    },
    summaryRow: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        paddingVertical: 4,
    },
    summaryLabel: {
        fontSize: 16,
        color: '#6b7280',
        fontWeight: '500',
    },
    summaryValue: {
        fontSize: 16,
        color: '#374151',
        fontWeight: '500',
    },
    totalRow: {
        paddingTop: 12,
        borderTopWidth: 1,
        borderTopColor: '#e5e7eb',
        marginTop: 4,
    },
    totalLabel: {
        fontSize: 18,
        fontWeight: '600',
        color: '#111827',
    },
    totalValue: {
        fontSize: 18,
        fontWeight: '700',
        color: '#059669',
    },
    securitySection: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        padding: 16,
        gap: 8,
    },
    securityText: {
        fontSize: 14,
        color: '#6b7280',
        fontWeight: '500',
    },
    footer: {
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        backgroundColor: '#ffffff',
        borderTopWidth: 1,
        borderTopColor: '#e5e7eb',
        padding: 16,
        paddingBottom: Platform.OS === 'ios' ? 34 : 16,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: -2 },
        shadowOpacity: 0.1,
        shadowRadius: 8,
        elevation: 8,
    },
    footerContent: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: 16,
    },
    totalContainer: {
        flex: 1,
    },
    footerTotalLabel: {
        fontSize: 14,
        color: '#6b7280',
        fontWeight: '500',
        marginBottom: 2,
    },
    footerTotalValue: {
        fontSize: 20,
        fontWeight: '700',
        color: '#059669',
    },
    checkoutButton: {
        flex: 2,
        backgroundColor: '#059669',
        padding: 16,
        borderRadius: 12,
        alignItems: 'center',
        flexDirection: 'row',
        justifyContent: 'center',
        shadowColor: '#059669',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.3,
        shadowRadius: 8,
        elevation: 6,
    },
    checkoutButtonDisabled: {
        backgroundColor: '#9ca3af',
        shadowOpacity: 0,
        elevation: 0,
    },
    checkoutButtonText: {
        color: '#ffffff',
        fontSize: 16,
        fontWeight: '600',
        marginLeft: 8,
    },
});

export default CheckoutModalScreen;./screens/dashboard/Home.tsx
==== ./screens/dashboard/Home.tsx ====
import React, { useContext, useState, useCallback, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Image,
  Alert,
  RefreshControl,
  ActivityIndicator,
} from 'react-native';
import { useNavigation, DrawerActions } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList } from '../../types';
import { AuthContext } from '../../context/AuthContext';
import { productApi } from '../../services/api/productApi';
import { Product } from '../../types';
import NetInfo from '@react-native-community/netinfo';

type HomeScreenNavigationProp = NativeStackNavigationProp<HomeStackParamList>;

const HomeScreen = () => {
  const navigation = useNavigation<HomeScreenNavigationProp>();
  const { isAuthenticated, user, logout } = useContext(AuthContext);

  const [isRefreshing, setRefreshing] = useState(false);
  const [featuredProducts, setFeaturedProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isOnline, setIsOnline] = useState<boolean | null>(true);
  const [isNetworkLoading, setNetworkLoading] = useState(false);

  // Fetch featured products dari API
  const fetchFeaturedProducts = useCallback(async () => {
    try {
      setError(null);
      // Cek network sebelum fetch
      const netState = await NetInfo.fetch();
      if (!netState.isConnected) {
        setError('No internet connection');
        setIsOnline(false);
        return;
      }

      setIsOnline(true);
      // Ambil produk populer dari API
      const popularProducts = await productApi.getPopularProducts(4);
      setFeaturedProducts(popularProducts);
    } catch (err) {
      // Cek jika error karena network
      const netState = await NetInfo.fetch();
      if (!netState.isConnected) {
        setError('No internet connection');
        setIsOnline(false);
      } else {
        setError('Failed to load featured products');
        console.error('Error fetching featured products:', err);
      }
    } finally {
      setLoading(false);
    }
  }, []);

  // Handle ketika network kembali online
  const handleNetworkOnline = useCallback(() => {
    setNetworkLoading(true);
    setError(null);
    
    // Simulate network delay 2-3 detik
    const delay = Math.random() * 1000 + 2000; // Random antara 2000-3000ms
    
    setTimeout(() => {
      fetchFeaturedProducts().finally(() => {
        setNetworkLoading(false);
      });
    }, delay);
  }, [fetchFeaturedProducts]);

  // Check network connection
  useEffect(() => {
    const unsubscribe = NetInfo.addEventListener(state => {
      const wasOffline = !isOnline;
      const nowOnline = state.isConnected && state.isInternetReachable;
      
      setIsOnline(nowOnline);
      
      // Jika network berubah dari offline ke online, trigger loading dengan delay
      if (wasOffline && nowOnline) {
        handleNetworkOnline();
      }
    });

    return () => unsubscribe();
  }, [isOnline, handleNetworkOnline]);

  const onRefresh = useCallback(() => {
    setRefreshing(true);
    fetchFeaturedProducts().finally(() => {
      setRefreshing(false);
    });
  }, [fetchFeaturedProducts]);

  // Handle product press dengan kondisi login
  const handleProductPress = (product: Product) => {
    if (!isAuthenticated) {
      Alert.alert(
        'Login Required',
        'Please login to view product details',
        [
          {
            text: 'Cancel',
            style: 'cancel',
          },
          {
            text: 'Login',
            onPress: () => navigation.navigate('Login'),
          },
        ]
      );
      return;
    }
    // Jika sudah login, navigasi ke detail product
    navigation.navigate('ProductDetail', { productId: product.id });
  };

  const handleExploreCategories = () => {
    if (!isAuthenticated) {
      Alert.alert(
        'Login Required',
        'Please login to explore categories',
        [
          {
            text: 'Cancel',
            style: 'cancel',
          },
          {
            text: 'Login',
            onPress: () => navigation.navigate('Login'),
          },
        ]
      );
      return;
    }
    navigation.dispatch(DrawerActions.jumpTo('CategoriesWithBottomTabs'));
  };

  const handleExploreAllProducts = () => {
    navigation.navigate('ProductList');
  };

  const handleLogin = () => {
    navigation.navigate('Login');
  };

  // Load featured products pertama kali
  useEffect(() => {
    fetchFeaturedProducts();
  }, [fetchFeaturedProducts]);

  useEffect(() => {
    if (isAuthenticated && navigation.canGoBack()) {
      navigation.navigate('Home');
    }
  }, [isAuthenticated, navigation]);

  // Network status indicator component
  const NetworkStatus = () => (
    <View style={[
      styles.networkStatus, 
      isOnline ? styles.networkOnline : styles.networkOffline
    ]}>
      <Text style={styles.networkStatusText}>
        {isOnline ? 'üü¢ Online' : 'üî¥ Offline'}
      </Text>
      {isNetworkLoading && (
        <View style={styles.networkLoading}>
          <ActivityIndicator size="small" color="#ffffff" />
          <Text style={styles.networkLoadingText}>Reconnecting...</Text>
        </View>
      )}
    </View>
  );

  // Component untuk loading state dengan animasi network
  const renderLoading = () => (
    <View style={styles.loadingContainer}>
      <ActivityIndicator size="large" color="#2e7d32" />
      <Text style={styles.loadingText}>
        {isNetworkLoading ? 'Reconnecting to network...' : 'Loading featured products...'}
      </Text>
      {isNetworkLoading && (
        <Text style={styles.loadingSubtext}>
          Please wait while we sync the latest products
        </Text>
      )}
    </View>
  );

  // Component untuk error state dengan network info
  const renderError = () => (
    <View style={styles.errorContainer}>
      <Text style={styles.errorIcon}>
        {!isOnline ? 'üì∂' : '‚ùå'}
      </Text>
      <Text style={styles.errorTitle}>
        {!isOnline ? 'No Internet Connection' : 'Failed to Load'}
      </Text>
      <Text style={styles.errorText}>
        {!isOnline 
          ? 'Please check your internet connection and try again'
          : error
        }
      </Text>
      
      {!isOnline ? (
        <View style={styles.offlineActions}>
          <Text style={styles.offlineText}>
            We'll automatically retry when you're back online
          </Text>
          <TouchableOpacity 
            style={[styles.retryButton, styles.offlineButton]} 
            onPress={() => {
              setNetworkLoading(true);
              setTimeout(() => {
                fetchFeaturedProducts().finally(() => setNetworkLoading(false));
              }, 2500);
            }}
            disabled={isNetworkLoading}
          >
            {isNetworkLoading ? (
              <ActivityIndicator size="small" color="#ffffff" />
            ) : (
              <Text style={styles.retryButtonText}>Try Now</Text>
            )}
          </TouchableOpacity>
        </View>
      ) : (
        <TouchableOpacity style={styles.retryButton} onPress={fetchFeaturedProducts}>
          <Text style={styles.retryButtonText}>Try Again</Text>
        </TouchableOpacity>
      )}
    </View>
  );

  return (
    <ScrollView
      style={styles.container}
      showsVerticalScrollIndicator={false}
      refreshControl={
        <RefreshControl
          refreshing={isRefreshing}
          onRefresh={onRefresh}
          colors={['#2e7d32']}
          tintColor="#2e7d32"
        />
      }
    >
      {/* Network Status Banner */}
      <NetworkStatus />

      {/* Hero Section */}
      <View style={styles.heroSection}>
        <Text style={styles.heroTitle}>
          {isAuthenticated ? `Welcome, ${user?.name || 'User'}! üå±` : 'Welcome to Eco Store! üå±'}
        </Text>
        <Text style={styles.heroSubtitle}>
          Discover sustainable and eco-friendly products that care for our planet
        </Text>
        
        {!isAuthenticated ? (
          <View style={styles.loginPrompt}>
            <Text style={styles.loginText}>
              Please login to explore our full catalog and make purchases
            </Text>
            <TouchableOpacity style={styles.loginButton} onPress={handleLogin}>
              <Text style={styles.loginButtonText}>Login to Get Started</Text>
            </TouchableOpacity>
          </View>
        ) : (
          <View style={styles.welcomePrompt}>
            <Text style={styles.welcomeText}>
              Ready to explore eco-friendly products?
            </Text>
            <TouchableOpacity 
              style={styles.exploreButton} 
              onPress={handleExploreCategories}
            >
              <Text style={styles.exploreButtonText}>Explore Products</Text>
            </TouchableOpacity>
          </View>
        )}
      </View>

      {/* Featured Products Section */}
      <View style={styles.section}>
        <View style={styles.sectionHeader}>
          <Text style={styles.sectionTitle}>Featured Eco Products</Text>
          <View style={styles.headerRight}>
            <Text style={styles.refreshHint}>‚Üì Pull down to refresh</Text>
          </View>
        </View>
        <Text style={styles.sectionSubtitle}>
          Handpicked sustainable products just for you
        </Text>

        <TouchableOpacity
          style={styles.categoriesButton}
          onPress={handleExploreAllProducts}
        >
          <Text style={styles.categoriesButtonText}>
            Lihat Semua Produk
          </Text>
        </TouchableOpacity>

        {/* Network Loading State */}
        {isNetworkLoading && renderLoading()}

        {/* Loading State */}
        {loading && !isRefreshing && !isNetworkLoading && renderLoading()}

        {/* Error State */}
        {error && !loading && !isNetworkLoading && renderError()}

        {/* Products Grid */}
        {!loading && !error && !isNetworkLoading && (
          <View style={styles.productsGrid}>
            {featuredProducts.map((product) => (
              <TouchableOpacity
                key={product.id}
                style={styles.productCard}
                onPress={() => handleProductPress(product)}
              >
                <Image 
                  source={{ uri: product.image }} 
                  style={styles.productImage} 
                  resizeMode="cover"
                />
                <View style={styles.productInfo}>
                  <Text style={styles.productName} numberOfLines={2}>
                    {product.name}
                  </Text>
                  <Text style={styles.productPrice}>${product.price.toLocaleString()}</Text>
                  
                  {/* Badge Container */}
                  <View style={styles.badgeContainer}>
                    {product.isNew && (
                      <View style={styles.newBadge}>
                        <Text style={styles.newBadgeText}>NEW</Text>
                      </View>
                    )}
                    {product.discount && product.discount > 0 && (
                      <View style={styles.discountBadge}>
                        <Text style={styles.discountBadgeText}>{product.discount}% OFF</Text>
                      </View>
                    )}
                  </View>

                  {!isAuthenticated && (
                    <Text style={styles.loginHint}>Login to view details</Text>
                  )}
                </View>
              </TouchableOpacity>
            ))}
          </View>
        )}

        {/* Empty State */}
        {!loading && !error && !isNetworkLoading && featuredProducts.length === 0 && (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyIcon}>üì¶</Text>
            <Text style={styles.emptyTitle}>No Featured Products</Text>
            <Text style={styles.emptyText}>
              Check back later for featured eco products!
            </Text>
          </View>
        )}
      </View>

      {/* Categories Preview */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Explore Categories</Text>
        <Text style={styles.sectionSubtitle}>
          Discover products by category
        </Text>

        <TouchableOpacity
          style={styles.categoriesButton}
          onPress={handleExploreCategories}
        >
          <Text style={styles.categoriesButtonText}>
            {isAuthenticated ? 'Browse All Categories' : 'Login to Browse Categories'}
          </Text>
        </TouchableOpacity>

        <View style={styles.categoriesGrid}>
          <View style={styles.categoryItem}>
            <Text style={styles.categoryIcon}>üì±</Text>
            <Text style={styles.categoryName}>Electronics</Text>
          </View>
          <View style={styles.categoryItem}>
            <Text style={styles.categoryIcon}>üëï</Text>
            <Text style={styles.categoryName}>Clothing</Text>
          </View>
          <View style={styles.categoryItem}>
            <Text style={styles.categoryIcon}>üçé</Text>
            <Text style={styles.categoryName}>Food</Text>
          </View>
          <View style={styles.categoryItem}>
            <Text style={styles.categoryIcon}>üöó</Text>
            <Text style={styles.categoryName}>Automotive</Text>
          </View>
        </View>
      </View>

      {/* Benefits Section */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Why Choose Eco Store?</Text>
        <View style={styles.benefitsList}>
          <View style={styles.benefitItem}>
            <Text style={styles.benefitIcon}>üåç</Text>
            <View style={styles.benefitText}>
              <Text style={styles.benefitTitle}>Eco-Friendly</Text>
              <Text style={styles.benefitDescription}>
                All products are sustainable and environmentally conscious
              </Text>
            </View>
          </View>
          <View style={styles.benefitItem}>
            <Text style={styles.benefitIcon}>üíö</Text>
            <View style={styles.benefitText}>
              <Text style={styles.benefitTitle}>Ethical Sourcing</Text>
              <Text style={styles.benefitDescription}>
                Products sourced from responsible and ethical suppliers
              </Text>
            </View>
          </View>
          <View style={styles.benefitItem}>
            <Text style={styles.benefitIcon}>üöö</Text>
            <View style={styles.benefitText}>
              <Text style={styles.benefitTitle}>Fast Delivery</Text>
              <Text style={styles.benefitDescription}>
                Quick and carbon-neutral delivery options
              </Text>
            </View>
          </View>
        </View>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#9bf89bff',
  },
  // Network Status Styles
  networkStatus: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  networkOnline: {
    backgroundColor: '#4caf50',
  },
  networkOffline: {
    backgroundColor: '#f44336',
  },
  networkStatusText: {
    color: '#ffffff',
    fontWeight: '600',
    fontSize: 14,
  },
  networkLoading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  networkLoadingText: {
    color: '#ffffff',
    fontSize: 12,
    opacity: 0.9,
  },
  heroSection: {
    backgroundColor: '#2e7d32',
    padding: 30,
    paddingTop: 50,
    alignItems: 'center',
  },
  heroTitle: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 12,
    textAlign: 'center',
  },
  heroSubtitle: {
    fontSize: 16,
    color: '#e8f5e9',
    textAlign: 'center',
    lineHeight: 22,
    opacity: 0.9,
    marginBottom: 20,
  },
  loginPrompt: {
    backgroundColor: 'rgba(255, 255, 255, 0.15)',
    padding: 20,
    borderRadius: 12,
    alignItems: 'center',
    width: '100%',
  },
  welcomePrompt: {
    backgroundColor: 'rgba(255, 255, 255, 0.15)',
    padding: 20,
    borderRadius: 12,
    alignItems: 'center',
    width: '100%',
  },
  loginText: {
    fontSize: 14,
    color: '#e8f5e9',
    textAlign: 'center',
    marginBottom: 16,
    lineHeight: 20,
  },
  welcomeText: {
    fontSize: 14,
    color: '#e8f5e9',
    textAlign: 'center',
    marginBottom: 16,
    lineHeight: 20,
  },
  loginButton: {
    backgroundColor: '#4caf50',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
    minWidth: 160,
    alignItems: 'center',
  },
  loginButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  exploreButton: {
    backgroundColor: '#4caf50',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
    minWidth: 160,
    alignItems: 'center',
  },
  exploreButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  section: {
    padding: 24,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  headerRight: {
    alignItems: 'flex-end',
  },
  sectionTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#2e7d32',
  },
  refreshHint: {
    fontSize: 12,
    color: '#4caf50',
    fontStyle: 'italic',
  },
  sectionSubtitle: {
    fontSize: 16,
    color: '#666',
    marginBottom: 20,
    lineHeight: 22,
  },
  // Loading Styles
  loadingContainer: {
    alignItems: 'center',
    padding: 40,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#2e7d32',
    textAlign: 'center',
  },
  loadingSubtext: {
    marginTop: 8,
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
    fontStyle: 'italic',
  },
  // Error Styles
  errorContainer: {
    alignItems: 'center',
    padding: 40,
  },
  errorIcon: {
    fontSize: 48,
    marginBottom: 16,
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#d32f2f',
    marginBottom: 8,
  },
  errorText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 20,
    lineHeight: 22,
  },
  offlineActions: {
    alignItems: 'center',
    gap: 12,
  },
  offlineText: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
    fontStyle: 'italic',
    marginBottom: 8,
  },
  retryButton: {
    backgroundColor: '#2e7d32',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
    minWidth: 120,
    alignItems: 'center',
  },
  offlineButton: {
    backgroundColor: '#ff9800',
  },
  retryButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  // Empty State Styles
  emptyContainer: {
    alignItems: 'center',
    padding: 40,
  },
  emptyIcon: {
    fontSize: 64,
    marginBottom: 16,
  },
  emptyTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  emptyText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    lineHeight: 22,
  },
  // Products Grid
  productsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  productCard: {
    width: '48%',
    backgroundColor: '#ffffff',
    borderRadius: 12,
    marginBottom: 16,
    padding: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
  },
  productImage: {
    width: '100%',
    height: 120,
    borderRadius: 8,
    marginBottom: 8,
  },
  productInfo: {
    flex: 1,
  },
  productName: {
    fontSize: 14,
    fontWeight: '600',
    color: '#2e7d32',
    marginBottom: 4,
    lineHeight: 18,
  },
  productPrice: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 6,
  },
  // Badge Container
  badgeContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 4,
    marginBottom: 4,
  },
  newBadge: {
    backgroundColor: '#4caf50',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 4,
  },
  newBadgeText: {
    color: '#ffffff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  discountBadge: {
    backgroundColor: '#ff5722',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 4,
  },
  discountBadgeText: {
    color: '#ffffff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  loginHint: {
    fontSize: 10,
    color: '#ff9800',
    fontStyle: 'italic',
  },
  categoriesButton: {
    backgroundColor: '#2e7d32',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginBottom: 20,
  },
  categoriesButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  categoriesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  categoryItem: {
    width: '48%',
    backgroundColor: '#ffffff',
    padding: 20,
    borderRadius: 12,
    alignItems: 'center',
    marginBottom: 12,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2.22,
  },
  categoryIcon: {
    fontSize: 24,
    marginBottom: 8,
  },
  categoryName: {
    fontSize: 14,
    fontWeight: '600',
    color: '#2e7d32',
    textAlign: 'center',
  },
  benefitsList: {
    gap: 16,
  },
  benefitItem: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    backgroundColor: '#ffffff',
    padding: 16,
    borderRadius: 12,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2.22,
  },
  benefitIcon: {
    fontSize: 24,
    marginRight: 12,
    marginTop: 2,
  },
  benefitText: {
    flex: 1,
  },
  benefitTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 4,
  },
  benefitDescription: {
    fontSize: 14,
    color: '#666',
    lineHeight: 20,
  },
});

export default HomeScreen;./screens/dashboard/ProductCategoryScreen.tsx
==== ./screens/dashboard/ProductCategoryScreen.tsx ====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Image,
  ActivityIndicator,
  Alert,
  TextInput,
  RefreshControl,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { DrawerNavigationProp } from '@react-navigation/drawer';
import { RootDrawerParamList, Product, ApiProduct } from '../../types';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';
import  { useInternet }  from '../../context/InternetContext';
import { cacheManager } from '../../utils/cacheHelper';
import WishlistButton from '../../routes/WishlistButton';

type ProductCategoryScreenNavigationProp = DrawerNavigationProp<RootDrawerParamList, 'ProductCategory'>;

// Cache keys
const CATEGORY_PRODUCTS_CACHE_KEY = 'category_products_cache';

const ProductCategoryScreen = () => {
  const navigation = useNavigation<ProductCategoryScreenNavigationProp>();
  const route = useRoute();
  const { category } = route.params as { category: string };
  const { isInternetReachable } = useInternet();

  const [products, setProducts] = useState<Product[]>([]);
  const [filteredProducts, setFilteredProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [usingCache, setUsingCache] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');

  // Convert API product to our Product interface
  const convertApiProduct = (apiProduct: ApiProduct): Product => {
    return {
      id: apiProduct.id.toString(),
      name: apiProduct.title,
      title: apiProduct.title,
      price: apiProduct.price,
      category: apiProduct.category,
      description: apiProduct.description,
      image: apiProduct.thumbnail,
      discount: apiProduct.discountPercentage,
      rating: apiProduct.rating,
      stock: apiProduct.stock,
      isNew: apiProduct.stock > 50
    };
  };

  // Save category products to cache
  const saveCategoryProductsToCache = async (category: string, products: Product[]) => {
    const cacheKey = `${CATEGORY_PRODUCTS_CACHE_KEY}_${category}`;
    await cacheManager.set(cacheKey, products);
  };

  // Load category products from cache
  const loadCategoryProductsFromCache = async (category: string): Promise<Product[] | null> => {
    const cacheKey = `${CATEGORY_PRODUCTS_CACHE_KEY}_${category}`;
    return await cacheManager.get<Product[]>(cacheKey);
  };

  // Fetch products by category with Cache-First Strategy
  const fetchCategoryProducts = async (forceRefresh: boolean = false) => {
    try {
      setLoading(true);
      setError(null);

      // Check internet connection
      if (!isInternetReachable) {
        // Try to load from cache when offline
        const cachedProducts = await loadCategoryProductsFromCache(category);
        if (cachedProducts && cachedProducts.length > 0) {
          setProducts(cachedProducts);
          setFilteredProducts(cachedProducts);
          setError('Mode offline - menggunakan data cache');
          setUsingCache(true);
          console.log(`üì± Offline mode: Using cached products for ${category}`);
        } else {
          setError('Tidak ada koneksi internet dan tidak ada data cache.');
        }
        setLoading(false);
        setRefreshing(false);
        return;
      }

      // Cache-First Strategy: Check cache first unless force refresh
      if (!forceRefresh) {
        const cachedProducts = await loadCategoryProductsFromCache(category);
        if (cachedProducts && cachedProducts.length > 0) {
          setProducts(cachedProducts);
          setFilteredProducts(cachedProducts);
          setUsingCache(true);
          console.log(`üíæ Using cached products for category: ${category}`);
          
          // Continue to fetch fresh data in background
          fetchFreshCategoryProducts();
          return;
        }
      }

      // No cache or force refresh - fetch from API
      await fetchFreshCategoryProducts();

    } catch (err: unknown) {
      handleFetchError(err);
    }
  };

  // Fetch fresh category products from API
  const fetchFreshCategoryProducts = async () => {
    try {
      console.log(`üîÑ Fetching fresh products for category: ${category}`);
      
      const response = await fetch(`https://dummyjson.com/products/category/${category}`);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      if (data && data.products) {
        // Convert API products to our Product format
        const convertedProducts: Product[] = data.products.map((apiProduct: ApiProduct) =>
          convertApiProduct(apiProduct)
        );

        setProducts(convertedProducts);
        setFilteredProducts(convertedProducts);
        setUsingCache(false);
        setError(null);

        // Save to cache
        await saveCategoryProductsToCache(category, convertedProducts);
        
        console.log(`‚úÖ Category products loaded and cached: ${category}`);
      }
    } catch (err: unknown) {
      // If API fails, try to use cache as fallback
      const cachedProducts = await loadCategoryProductsFromCache(category);
      if (cachedProducts && cachedProducts.length > 0) {
        setProducts(cachedProducts);
        setFilteredProducts(cachedProducts);
        setUsingCache(true);
        setError('Gagal memuat data terbaru, menggunakan data cache');
        console.log(`üîÑ Fallback to cached data for ${category} after API failure`);
      } else {
        throw err; // Re-throw if no cache available
      }
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // Handle fetch errors
  const handleFetchError = async (err: unknown) => {
    console.error(`‚ùå Fetch failed for category ${category}:`, err);

    let errorMessage = 'Gagal memuat produk kategori';

    // Handle different error types
    if (err instanceof Error) {
      errorMessage = err.message;
    } else if (typeof err === 'string') {
      errorMessage = err;
    }

    // Try cache as fallback
    const cachedProducts = await loadCategoryProductsFromCache(category);
    if (cachedProducts && cachedProducts.length > 0) {
      setProducts(cachedProducts);
      setFilteredProducts(cachedProducts);
      setUsingCache(true);
      setError('Gagal memuat data terbaru, menggunakan data cache');
      setLoading(false);
      setRefreshing(false);
      return;
    }

    setError(errorMessage);
    setLoading(false);
    setRefreshing(false);
  };

  // Manual retry
  const handleRetry = () => {
    fetchCategoryProducts(true);
  };

  // Clear cache for this category
  const handleClearCache = async () => {
    const cacheKey = `${CATEGORY_PRODUCTS_CACHE_KEY}_${category}`;
    await cacheManager.remove(cacheKey);
    Alert.alert('Success', 'Cache cleared successfully');
    fetchCategoryProducts(true);
  };

  // Pull to refresh
  const onRefresh = () => {
    if (!isInternetReachable) {
      Alert.alert(
        'Tidak Terkoneksi',
        'Tidak dapat refresh produk saat offline.',
        [{ text: 'OK' }]
      );
      return;
    }

    setRefreshing(true);
    setError(null);
    setUsingCache(false);
    fetchCategoryProducts(true);
  };

  useEffect(() => {
    fetchCategoryProducts();
  }, [category]);

  // Filter products based on search
  useEffect(() => {
    if (searchQuery) {
      const filtered = products.filter(product =>
        product.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        product.description.toLowerCase().includes(searchQuery.toLowerCase())
      );
      setFilteredProducts(filtered);
    } else {
      setFilteredProducts(products);
    }
  }, [searchQuery, products]);

  const handleProductPress = (product: Product) => {
    navigation.navigate('ProductDetail', { productId: product.id });
  };

  const formatPrice = (price: number) => {
    return `$${price.toFixed(2)}`;
  };

  const calculateDiscountPrice = (price: number, discount?: number) => {
    if (!discount) return price;
    return price - (price * discount / 100);
  };

  const renderProductItem = ({ item }: { item: Product }) => (
    <TouchableOpacity
      style={styles.productCard}
      onPress={() => handleProductPress(item)}
    >
      <Image source={{ uri: item.image }} style={styles.productImage} />

      {/* --- TOMBOL WISHLIST --- */}
      <View style={styles.wishlistButtonContainer}>
        <WishlistButton product={item} size={20} />
      </View>

      {/* --- BADGE (NEW & DISCOUNT) --- */}
      {/* (Logika badge bisa ditambahkan di sini jika perlu) */}
      <View style={styles.productInfo}>
        <Text style={styles.productTitle} numberOfLines={2}>
          {item.name}
        </Text>

        <Text style={styles.productCategory}>
          {item.category}
        </Text>

        <View style={styles.priceContainer}>
          {item.discount && item.discount > 0 ? (
            <>
              <Text style={styles.originalPrice}>
                {formatPrice(item.price)}
              </Text>
              <Text style={styles.discountPrice}>
                {formatPrice(calculateDiscountPrice(item.price, item.discount))}
              </Text>
            </>
          ) : (
            <Text style={styles.normalPrice}>
              {formatPrice(item.price)}
            </Text>
          )}
        </View>

        {item.rating && (
          <View style={styles.ratingContainer}>
            <FontAwesome6 name="star" size={12} color="#ffc107" iconStyle='solid' />
            <Text style={styles.ratingText}>{item.rating}</Text>
          </View>
        )}

        <Text style={styles.productDescription} numberOfLines={2}>
          {item.description}
        </Text>
      </View>
    </TouchableOpacity>
  );

  if (loading && !refreshing) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#2e7d32" />
        <Text style={styles.loadingText}>
          {usingCache ? 'Memuat data cache...' : `Loading ${category}...`}
        </Text>
        {usingCache && (
          <Text style={styles.cacheIndicator}>üíæ Menggunakan data cache</Text>
        )}
      </View>
    );
  }

  if (error && filteredProducts.length === 0) {
    return (
      <View style={styles.errorContainer}>
        <FontAwesome6
          name={isInternetReachable ? "triangle-exclamation" : "wifi"}
          size={64}
          color={isInternetReachable ? "#ff6b6b" : "#6b7280"}
          iconStyle='solid'
        />
        <Text style={styles.errorTitle}>
          {isInternetReachable ? 'Gagal Memuat Produk' : 'Tidak Terkoneksi'}
        </Text>
        <Text style={styles.errorMessage}>{error}</Text>
        <TouchableOpacity
          style={[
            styles.retryButton,
            !isInternetReachable && styles.retryButtonOffline
          ]}
          onPress={handleRetry}
        >
          <Text style={styles.retryButtonText}>
            {isInternetReachable ? 'Coba Lagi' : 'Coba Lagi'}
          </Text>
        </TouchableOpacity>
        {usingCache && (
          <Text style={styles.cacheIndicator}>üì± Sedang menggunakan data cache</Text>
        )}
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity 
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <FontAwesome6 name="arrow-left" size={20} color="#2e7d32" iconStyle='solid' />
        </TouchableOpacity>
        
        <View style={styles.headerContent}>
          <Text style={styles.categoryTitle}>
            {category.charAt(0).toUpperCase() + category.slice(1)}
          </Text>
          <Text style={styles.productCount}>
            {filteredProducts.length} products
            {usingCache && ' ‚Ä¢ Cache'}
            {!isInternetReachable && ' ‚Ä¢ Offline'}
          </Text>
        </View>
      </View>

      {/* Network Status */}
      {!isInternetReachable && (
        <View style={styles.offlineIndicator}>
          <FontAwesome6 name="wifi" size={14} color="#ffffff" iconStyle='solid' />
          <Text style={styles.offlineIndicatorText}>Mode Offline</Text>
        </View>
      )}

      {/* Cache Status */}
      {usingCache && (
        <View style={styles.cacheBanner}>
          <FontAwesome6 name="database" size={14} color="#ffffff" iconStyle='solid' />
          <Text style={styles.cacheBannerText}>Menggunakan data cache</Text>
          <TouchableOpacity onPress={handleClearCache} style={styles.clearCacheButton}>
            <Text style={styles.clearCacheText}>Clear</Text>
          </TouchableOpacity>
        </View>
      )}

      {/* Search Bar */}
      <View style={[
        styles.searchContainer,
        !isInternetReachable && styles.searchContainerOffline
      ]}>
        <FontAwesome6 name="magnifying-glass" size={16} color="#666" iconStyle='solid' />
        <TextInput
          style={styles.searchInput}
          placeholder={isInternetReachable ? `Search in ${category}...` : "Search (offline mode)"}
          value={searchQuery}
          onChangeText={setSearchQuery}
          placeholderTextColor="#999"
          editable={isInternetReachable || products.length > 0}
        />
        {searchQuery ? (
          <TouchableOpacity onPress={() => setSearchQuery('')}>
            <FontAwesome6 name="xmark" size={16} color="#666" iconStyle='solid' />
          </TouchableOpacity>
        ) : null}
      </View>

      {/* Products List */}
      <FlatList
        data={filteredProducts}
        renderItem={renderProductItem}
        keyExtractor={(item) => item.id}
        numColumns={2}
        columnWrapperStyle={styles.productsRow}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={['#2e7d32']}
            enabled={isInternetReachable}
          />
        }
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <FontAwesome6
              name={isInternetReachable ? "box-open" : "wifi"}
              size={64}
              color="#ccc"
              iconStyle='solid'
            />
            <Text style={styles.emptyText}>
              {isInternetReachable ? 'No products found' : 'Tidak Terkoneksi'}
            </Text>
            <Text style={styles.emptySubtext}>
              {isInternetReachable
                ? 'Try adjusting your search'
                : 'Sambungkan ke internet untuk memuat produk'
              }
            </Text>
          </View>
        }
        contentContainerStyle={styles.productsList}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#f0f7f0',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  headerContent: {
    flex: 1,
  },
  categoryTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#2e7d32',
  },
  productCount: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  offlineIndicator: {
    backgroundColor: '#6b7280',
    flexDirection: 'row',
    alignItems: 'center',
    padding: 8,
    marginHorizontal: 16,
    marginTop: 12,
    borderRadius: 8,
    alignSelf: 'flex-start',
    gap: 6,
  },
  offlineIndicatorText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: '500',
  },
  cacheBanner: {
    backgroundColor: '#ff9800',
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    marginHorizontal: 16,
    marginTop: 12,
    borderRadius: 8,
  },
  cacheBannerText: {
    color: '#ffffff',
    fontSize: 14,
    fontWeight: '500',
    marginLeft: 8,
    flex: 1,
  },
  clearCacheButton: {
    backgroundColor: 'rgba(255,255,255,0.3)',
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 4,
  },
  clearCacheText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: '600',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 5,
    margin: 16,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  searchContainerOffline: {
    backgroundColor: '#f3f4f6',
    opacity: 0.7,
  },
  searchInput: {
    flex: 1,
    marginLeft: 12,
    fontSize: 16,
    color: '#333',
  },
  productsList: {
    padding: 16,
    paddingTop: 0,
  },
  productsRow: {
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  productCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    width: '48%',
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    overflow: 'hidden',
    position: 'relative',
  },
  wishlistButtonContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
    zIndex: 1,
  },
  productImage: {
    width: '100%',
    height: 120,
    resizeMode: 'cover',
  },
  discountBadge: {
    position: 'absolute',
    top: 8,
    left: 8,
    backgroundColor: '#ff4444',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
  },
  discountText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: 'bold',
  },
  newBadge: {
    position: 'absolute',
    top: 8,
    right: 8,
    backgroundColor: '#4caf50',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
  },
  newText: {
    color: '#ffffff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  productInfo: {
    padding: 12,
  },
  productTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  productCategory: {
    fontSize: 12,
    color: '#666',
    marginBottom: 8,
    fontWeight: '500',
    textTransform: 'capitalize',
  },
  priceContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  originalPrice: {
    fontSize: 12,
    color: '#999',
    textDecorationLine: 'line-through',
    marginRight: 6,
  },
  discountPrice: {
    fontSize: 16,
    color: '#2e7d32',
    fontWeight: 'bold',
  },
  normalPrice: {
    fontSize: 16,
    color: '#2e7d32',
    fontWeight: 'bold',
  },
  ratingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  ratingText: {
    fontSize: 12,
    color: '#666',
    marginLeft: 4,
    fontWeight: '500',
  },
  productDescription: {
    fontSize: 11,
    color: '#888',
    lineHeight: 14,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8f9fa',
    padding: 20,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#2e7d32',
    textAlign: 'center',
  },
  cacheIndicator: {
    fontSize: 14,
    color: '#ff9800',
    textAlign: 'center',
    marginTop: 8,
    fontWeight: '500',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8f9fa',
    padding: 20,
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#d32f2f',
    marginTop: 16,
    marginBottom: 8,
    textAlign: 'center',
  },
  errorMessage: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 20,
    lineHeight: 20,
  },
  retryButton: {
    backgroundColor: '#2e7d32',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
    elevation: 2,
  },
  retryButtonOffline: {
    backgroundColor: '#6b7280',
  },
  retryButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  emptyText: {
    fontSize: 18,
    color: '#666',
    fontWeight: '600',
    marginTop: 16,
    marginBottom: 8,
  },
  emptySubtext: {
    fontSize: 14,
    color: '#999',
    textAlign: 'center',
  },
});

export default ProductCategoryScreen;./screens/dashboard/ProductDetailScreen.tsx
==== ./screens/dashboard/ProductDetailScreen.tsx ====
import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  TouchableOpacity,
  Image,
  Alert,
  ActivityIndicator,
  RefreshControl
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList, Product } from '../../types';
import { useCart } from '../../context/CartContext';
import { productApi } from '../../services/api/productApi';
import { productCacheService } from '../../services/product/productCacheService';
import ResetStackButton from '../../components/ResetStackButton';
import { fetchWithRetry } from '../../utils/fetchWithRetry'; 

type ProductDetailScreenNavigationProp = NativeStackNavigationProp<HomeStackParamList, 'ProductDetail'>;

// Fallback product data untuk error 404/500
const FALLBACK_PRODUCT: Product = {
  id: "fallback",
  name: "Produk Arsip",
  title: "Produk Arsip",
  image: "https://dummyimage.com/300x300/cccccc/000000",
  price: 0,
  description: "Ini adalah versi arsip produk. Data terbaru tidak dapat dimuat.",
  category: "Archive",
  stock: 0,
  rating: 0
};

const ProductDetailScreen = () => {
  const { addToCart } = useCart();
  const navigation = useNavigation<ProductDetailScreenNavigationProp>();
  const route = useRoute();
  const { productId } = route.params as { productId: string };

  const [product, setProduct] = useState<Product | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showFallback, setShowFallback] = useState(false);
  const [httpStatus, setHttpStatus] = useState<number | null>(null);
  const [usingCache, setUsingCache] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  const [retryCount, setRetryCount] = useState(0); // ‚úÖ Track retry attempts

  useEffect(() => {
    fetchProductDetail();
  }, [productId]);

  /**
   * ‚úÖ FETCH PRODUCT DETAIL DENGAN RETRY MECHANISM
   */
  const fetchProductDetail = async (isRefreshing: boolean = false) => {
    try {
      if (!isRefreshing) {
        setLoading(true);
      }
      setError(null);
      setShowFallback(false);
      setHttpStatus(null);
      setRetryCount(0); // Reset retry count
      
      if (!isRefreshing) {
        setUsingCache(false);
      }

      console.log('üîÑ Fetching product details for ID:', productId);

      // ‚úÖ JIKA SEDANG REFRESH, SKIP CACHE & FORCE API CALL
      const cachedProduct = isRefreshing ? null : await productCacheService.getProductCache<Product>(productId);
      
      if (cachedProduct && !isRefreshing) {
        console.log('‚úÖ Using cached product data');
        setProduct(cachedProduct);
        setUsingCache(true);
        setLoading(false);
        return;
      }

      // ‚úÖ FETCH FROM API DENGAN RETRY MECHANISM
      console.log(isRefreshing ? 'üîÑ Force refreshing from API...' : 'üåê Cache miss, fetching from API...');
      
      const productData = await fetchWithRetry(
        async () => {
          const result = await productApi.getProductById(productId);
          setRetryCount(prev => prev + 1); // Track successful attempt
          return result;
        },
        { 
          maxRetry: 3, 
          baseDelay: 1000,
          retryOn5xx: true 
        }
      );
      
      // ‚úÖ SAVE TO CACHE
      await productCacheService.setProductCache(productId, productData);
      
      setProduct(productData);
      setUsingCache(false);
      
      console.log(isRefreshing ? '‚úÖ Product data refreshed and cache updated' : '‚úÖ Product details loaded from API and cached');
      
    } catch (err: any) {
      console.error('‚ùå Error fetching product after retries:', err);
      
      const status = err.response?.status;
      setHttpStatus(status);
      setRetryCount(0); // Reset karena gagal
      
      // ‚úÖ JIKA REFRESH GAGAL, COBA PAKAI CACHE SEBAGAI FALLBACK
      const cachedProduct = await productCacheService.getProductCache<Product>(productId);
      if (cachedProduct) {
        console.log('üîÑ Using cached data as fallback after API error');
        setProduct(cachedProduct);
        setUsingCache(true);
        setError(isRefreshing ? 'Refresh failed, using cached data' : 'Using cached data (offline mode)');
        
        if (isRefreshing) {
          Alert.alert(
            'Refresh Failed', 
            'Failed to refresh data. Using cached version instead.'
          );
        }
      } else {
        setError(err.message || 'Failed to load product details');
        
        if (status === 404 || status === 500) {
          setShowFallback(true);
          setProduct(FALLBACK_PRODUCT);
          
          if (isRefreshing) {
            Alert.alert(
              'Refresh Failed', 
              'Gagal memuat data terbaru setelah beberapa percobaan. Menampilkan versi arsip.'
            );
          } else {
            Alert.alert(
              'Connection Issue', 
              'Gagal memuat data produk setelah beberapa percobaan. Menampilkan versi arsip.'
            );
          }
        } else if (isRefreshing) {
          Alert.alert(
            'Refresh Failed', 
            'Failed to refresh product data after several attempts'
          );
        } else {
          Alert.alert(
            'Connection Error', 
            'Failed to load product details. Please check your connection.'
          );
        }
      }
    } finally {
      setLoading(false);
      if (isRefreshing) {
        setRefreshing(false);
      }
    }
  };

  /**
   * ‚úÖ PULL-TO-REFRESH HANDLER DENGAN RETRY
   */
  const onRefresh = () => {
    console.log('üîÑ Pull-to-refresh triggered');
    setRefreshing(true);
    fetchProductDetail(true);
  };

  /**
   * ‚úÖ MANUAL RETRY HANDLER
   */
  const handleManualRetry = () => {
    console.log('üîÑ Manual retry triggered');
    fetchProductDetail(false);
  };

  /**
   * CLEAR CACHE FOR THIS PRODUCT
   */
  const clearProductCache = async () => {
    await productCacheService.clearProductCache(productId);
    Alert.alert('Cache Cleared', 'Product cache has been cleared.');
    setUsingCache(false);
  };

  const handleBackToDrawerHome = () => {
    navigation.navigate('Home');
  };

  const handleAddToCart = () => {
    if (!product) return;
    
    if (product.id === "fallback") {
      Alert.alert('Info', 'Produk arsip tidak dapat ditambahkan ke keranjang.');
      return;
    }
    
    addToCart(product);
    Alert.alert('Added to Cart', `${product.name} has been added to your cart.`);
  };

  const handleBuyNow = () => {
    if (!product) return;
    
    if (product.id === "fallback") {
      Alert.alert('Info', 'Produk arsip tidak dapat dibeli.');
      return;
    }
    
    addToCart(product, 1);
  };

  // ‚úÖ HELPER FUNCTION UNTUK GET PRODUCT NAME
  const getProductName = (product: Product): string => {
    return product.title || product.name || 'Product Name Not Available';
  };

  // ‚úÖ HELPER FUNCTION UNTUK GET PRODUCT IMAGE
  const getProductImage = (product: Product): string => {
    return product.image || product.thumbnail || FALLBACK_PRODUCT.image!;
  };

  if (loading && !refreshing) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#2e7d32" />
        <Text style={styles.loadingText}>
          {usingCache ? 'Loading from cache...' : 'Loading product details...'}
        </Text>
        {retryCount > 0 && (
          <Text style={styles.retryInfoText}>
            Attempt {retryCount} of 4
          </Text>
        )}
      </View>
    );
  }

  const displayProduct = showFallback ? product : product;
  
  if ((error && !showFallback && !usingCache) || !displayProduct) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorTitle}>Failed to Load Product</Text>
        <Text style={styles.errorText}>
          {httpStatus ? `HTTP ${httpStatus} Error` : 'Network Error'}
        </Text>
        <Text style={styles.errorDescription}>
          {error || 'Unable to load product details after several retry attempts.'}
        </Text>
        
        <View style={styles.errorActions}>
          <TouchableOpacity 
            style={[styles.retryButton, styles.primaryRetryButton]} 
            onPress={handleManualRetry}
          >
            <Text style={styles.primaryRetryButtonText}>üîÑ Try Again</Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={styles.retryButton} 
            onPress={() => navigation.goBack()}
          >
            <Text style={styles.retryButtonText}>Go Back</Text>
          </TouchableOpacity>
        </View>
        
        {/* Debug info for developers */}
        {__DEV__ && (
          <View style={styles.debugInfo}>
            <Text style={styles.debugText}>Product ID: {productId}</Text>
            <Text style={styles.debugText}>HTTP Status: {httpStatus || 'N/A'}</Text>
            <Text style={styles.debugText}>Error: {error}</Text>
          </View>
        )}
      </View>
    );
  }

  return (
    <ScrollView 
      style={styles.container}
      refreshControl={
        <RefreshControl
          refreshing={refreshing}
          onRefresh={onRefresh}
          colors={['#2e7d32']}
          tintColor="#2e7d32"
          title="Pull to refresh..."
          titleColor="#666"
        />
      }
      showsVerticalScrollIndicator={false}
    >
      {/* Cache Status Banner */}
      {usingCache && (
        <View style={styles.cacheBanner}>
          <Text style={styles.cacheBannerText}>
            üíæ Using Cached Data
          </Text>
          <TouchableOpacity onPress={clearProductCache} style={styles.clearCacheButton}>
            <Text style={styles.clearCacheText}>Clear Cache</Text>
          </TouchableOpacity>
        </View>
      )}

      {/* Retry Success Banner */}
      {retryCount > 1 && !usingCache && (
        <View style={styles.retrySuccessBanner}>
          <Text style={styles.retrySuccessText}>
            ‚úÖ Loaded after {retryCount} attempts
          </Text>
        </View>
      )}

      {/* Fallback Product Banner */}
      {showFallback && (
        <View style={styles.fallbackBanner}>
          <Text style={styles.fallbackBannerText}>
            ‚ö†Ô∏è Showing Archived Version
          </Text>
        </View>
      )}

      {/* HTTP Status Debug Info */}
      {__DEV__ && httpStatus && (
        <View style={styles.debugContainer}>
          <Text style={styles.debugText}>
            HTTP Status: {httpStatus} | {httpStatus === 404 ? 'Not Found' : httpStatus === 500 ? 'Server Error' : 'Other Error'}
          </Text>
        </View>
      )}

      <View style={styles.imageContainer}>
        <Image
          source={{ uri: getProductImage(displayProduct) }}
          style={styles.productImage}
          resizeMode="cover"
        />
        <View style={styles.badgeContainer}>
          {displayProduct.isNew && (
            <View style={[styles.badge, styles.newBadge]}>
              <Text style={styles.badgeText}>NEW</Text>
            </View>
          )}
          {displayProduct.discount && displayProduct.discount > 0 && (
            <View style={[styles.badge, styles.discountBadge]}>
              <Text style={styles.badgeText}>{Math.round(displayProduct.discount)}% OFF</Text>
            </View>
          )}
          {showFallback && (
            <View style={[styles.badge, styles.fallbackBadge]}>
              <Text style={styles.badgeText}>ARCHIVE</Text>
            </View>
          )}
          {usingCache && (
            <View style={[styles.badge, styles.cacheBadge]}>
              <Text style={styles.badgeText}>CACHE</Text>
            </View>
          )}
          {retryCount > 1 && (
            <View style={[styles.badge, styles.retryBadge]}>
              <Text style={styles.badgeText}>RETRY {retryCount}</Text>
            </View>
          )}
        </View>
      </View>

      <View style={styles.content}>
        <Text style={styles.category}>{displayProduct.category?.toUpperCase() || 'PRODUCT'}</Text>
        
        <Text style={styles.name}>{getProductName(displayProduct)}</Text>
        
        <Text style={styles.price}>
          {displayProduct.price > 0 ? `$${displayProduct.price.toLocaleString()}` : 'Price not available'}
        </Text>
        
        <View style={styles.stockContainer}>
          <Text style={[
            styles.stockText, 
            (displayProduct.stock ?? 0) > 0 ? styles.inStock : styles.outOfStock
          ]}>
            {(displayProduct.stock ?? 0) > 0 ? 'In Stock' : 'Out of Stock'}
          </Text>
          {usingCache && (
            <Text style={styles.cacheHint}>
              üí° Pull down to refresh data
            </Text>
          )}
        </View>

        <Text style={styles.description}>{displayProduct.description}</Text>

        {/* Action Buttons */}
        <View style={styles.buttonGroup}>
          <TouchableOpacity 
            style={[
              styles.cartButton,
              ((displayProduct.stock ?? 0) === 0 || showFallback) && styles.disabledButton
            ]} 
            onPress={handleAddToCart}
            disabled={(displayProduct.stock ?? 0) === 0 || showFallback}
          >
            <Text style={styles.cartButtonText}>
              {showFallback ? 'Archived Product' : 
               (displayProduct.stock ?? 0) === 0 ? 'Out of Stock' : 'Add to Cart'}
            </Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={[
              styles.buyButton,
              ((displayProduct.stock ?? 0) === 0 || showFallback) && styles.disabledButton
            ]} 
            onPress={handleBuyNow}
            disabled={(displayProduct.stock ?? 0) === 0 || showFallback}
          >
            <Text style={styles.buyButtonText}>
              {showFallback ? 'Not Available' : 
               (displayProduct.stock ?? 0) === 0 ? 'Out of Stock' : 'Buy Now'}
            </Text>
          </TouchableOpacity>
        </View>

        {/* Navigation Buttons */}
        <View style={styles.navigationButtons}>
          <TouchableOpacity 
            style={styles.navButton} 
            onPress={handleBackToDrawerHome}
          >
            <Text style={styles.navButtonText}>Back to Home</Text>
          </TouchableOpacity>
          
          <ResetStackButton />
        </View>

        {/* Refresh Hint */}
        <View style={styles.refreshHintContainer}>
          <Text style={styles.refreshHintText}>
            üí° Pull down from top to refresh product data
          </Text>
          <Text style={styles.retryHintText}>
            üîÑ Automatic retry on network failures
          </Text>
        </View>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#9bf89bff',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8f9fa',
    padding: 20,
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#666',
  },
  retryInfoText: {
    marginTop: 8,
    fontSize: 14,
    color: '#2e7d32',
    fontWeight: '500',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8f9fa',
    padding: 20,
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#ff5722',
    marginBottom: 8,
    textAlign: 'center',
  },
  errorText: {
    fontSize: 16,
    color: '#ff5722',
    marginBottom: 8,
    textAlign: 'center',
    fontWeight: '600',
  },
  errorDescription: {
    fontSize: 14,
    color: '#666',
    marginBottom: 24,
    textAlign: 'center',
    lineHeight: 20,
  },
  errorActions: {
    flexDirection: 'row',
    gap: 12,
    marginBottom: 20,
  },
  retryButton: {
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#2e7d32',
  },
  primaryRetryButton: {
    backgroundColor: '#2e7d32',
  },
  primaryRetryButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  retryButtonText: {
    color: '#2e7d32',
    fontSize: 16,
    fontWeight: '600',
  },
  debugInfo: {
    marginTop: 20,
    padding: 12,
    backgroundColor: '#fff3cd',
    borderRadius: 8,
    width: '100%',
  },
  debugText: {
    fontSize: 12,
    color: '#856404',
    fontFamily: 'monospace',
  },
  cacheBanner: {
    backgroundColor: '#ff9800',
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    justifyContent: 'space-between',
  },
  cacheBannerText: {
    color: '#ffffff',
    fontSize: 14,
    fontWeight: '600',
  },
  retrySuccessBanner: {
    backgroundColor: '#4caf50',
    padding: 12,
    alignItems: 'center',
  },
  retrySuccessText: {
    color: '#ffffff',
    fontSize: 14,
    fontWeight: '600',
  },
  clearCacheButton: {
    backgroundColor: 'rgba(255,255,255,0.3)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
  },
  clearCacheText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: '600',
  },
  cacheBadge: {
    backgroundColor: '#ff9800',
  },
  retryBadge: {
    backgroundColor: '#2196f3',
  },
  fallbackBanner: {
    backgroundColor: '#ff9800',
    padding: 12,
    alignItems: 'center',
  },
  fallbackBannerText: {
    color: '#ffffff',
    fontSize: 14,
    fontWeight: '600',
  },
  debugContainer: {
    backgroundColor: '#e3f2fd',
    padding: 8,
    alignItems: 'center',
  },
  imageContainer: {
    position: 'relative',
    height: 300,
    backgroundColor: '#ffffff',
  },
  productImage: {
    width: '100%',
    height: '100%',
  },
  badgeContainer: {
    position: 'absolute',
    top: 16,
    left: 16,
    flexDirection: 'row',
    gap: 8,
    flexWrap: 'wrap',
  },
  badge: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 6,
  },
  newBadge: {
    backgroundColor: '#4caf50',
  },
  discountBadge: {
    backgroundColor: '#ff5722',
  },
  fallbackBadge: {
    backgroundColor: '#9e9e9e',
  },
  badgeText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: 'bold',
  },
  content: {
    padding: 20,
  },
  category: {
    fontSize: 14,
    color: '#666',
    fontWeight: '600',
    marginBottom: 8,
  },
  name: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  price: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 8,
  },
  stockContainer: {
    marginBottom: 16,
  },
  stockText: {
    fontSize: 14,
    fontWeight: '600',
  },
  inStock: {
    color: '#4caf50',
  },
  outOfStock: {
    color: '#ff5722',
  },
  cacheHint: {
    fontSize: 12,
    color: '#666',
    fontStyle: 'italic',
    marginTop: 4,
  },
  description: {
    fontSize: 16,
    lineHeight: 24,
    color: '#666',
    marginBottom: 24,
  },
  buttonGroup: {
    flexDirection: 'row',
    gap: 12,
    marginBottom: 16,
  },
  cartButton: {
    flex: 1,
    backgroundColor: '#d8f7dbff',
    borderWidth: 2,
    borderColor: '#2e7d32',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  cartButtonText: {
    color: '#2e7d32',
    fontSize: 16,
    fontWeight: '600',
  },
  buyButton: {
    flex: 1,
    backgroundColor: '#2e7d32',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  buyButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  disabledButton: {
    opacity: 0.5,
  },
  navigationButtons: {
    gap: 12,
    marginBottom: 20,
  },
  navButton: {
    backgroundColor: '#4caf50',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  navButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  refreshHintContainer: {
    backgroundColor: '#e8f5e9',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#c8e6c9',
  },
  refreshHintText: {
    fontSize: 14,
    color: '#2e7d32',
    textAlign: 'center',
    fontWeight: '500',
    marginBottom: 4,
  },
  retryHintText: {
    fontSize: 12,
    color: '#2e7d32',
    textAlign: 'center',
    fontStyle: 'italic',
  },
});

export default ProductDetailScreen;./screens/dashboard/ProductListScreen.tsx
==== ./screens/dashboard/ProductListScreen.tsx ====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Image,
  TextInput,
  ActivityIndicator,
  Alert,
  RefreshControl,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { DrawerNavigationProp } from '@react-navigation/drawer';
import { RootDrawerParamList, Product, ApiProduct } from '../../types';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';
import { useInternet } from '../../context/InternetContext';
import { useNetworkAwareAction } from '../../hooks/useNetworkAwareAction';
import { cacheManager } from '../../utils/cachehelper';
import WishlistButton from '../../routes/WishlistButton'; // ‚úÖ Import WishlistButton
import { useAuth } from '../../context/AuthContext'; // ‚úÖ Import useAuth untuk cek login

type ProductListScreenNavigationProp = DrawerNavigationProp<RootDrawerParamList, 'ProductList'>;

// Cache keys
const PRODUCTS_CACHE_KEY = 'products_cache';
const CATEGORIES_CACHE_KEY = 'categories_cache';

const ProductListScreen = () => {
  const navigation = useNavigation<ProductListScreenNavigationProp>();
  const { isInternetReachable } = useInternet();
  const { executeIfOnline } = useNetworkAwareAction();
  const { isAuthenticated } = useAuth(); // ‚úÖ Untuk cek status login

  const [products, setProducts] = useState<Product[]>([]);
  const [filteredProducts, setFilteredProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('all');

  // Exponential Backoff State
  const [error, setError] = useState<string | null>(null);
  const [retryCount, setRetryCount] = useState(0);
  const [maxRetries] = useState(3);
  const [isRetrying, setIsRetrying] = useState(false);
  const [usingCache, setUsingCache] = useState(false);

  // Convert API product to our Product interface
  const convertApiProduct = (apiProduct: ApiProduct): Product => {
    return {
      id: apiProduct.id.toString(),
      name: apiProduct.title,
      title: apiProduct.title,
      price: apiProduct.price,
      category: apiProduct.category,
      description: apiProduct.description,
      image: apiProduct.thumbnail,
      discount: apiProduct.discountPercentage,
      isNew: apiProduct.stock > 50
    };
  };

  // Save products to cache
  const saveProductsToCache = async (products: Product[]) => {
    await cacheManager.set(PRODUCTS_CACHE_KEY, products);
    
    // Also save categories separately for faster access
    const categories = ['all', ...new Set(products.map(product => product.category))];
    await cacheManager.set(CATEGORIES_CACHE_KEY, categories);
  };

  // Load products from cache
  const loadProductsFromCache = async (): Promise<Product[] | null> => {
    return await cacheManager.get<Product[]>(PRODUCTS_CACHE_KEY);
  };

  // Load categories from cache
  const loadCategoriesFromCache = async (): Promise<string[] | null> => {
    return await cacheManager.get<string[]>(CATEGORIES_CACHE_KEY);
  };

  // Exponential Backoff Delay Calculator
  const getRetryDelay = (attempt: number): number => {
    return Math.pow(2, attempt) * 1000; // 1s, 2s, 4s
  };

  // Fetch products from API with Cache-First Strategy
  const fetchProducts = async (isManualRetry: boolean = false, forceRefresh: boolean = false) => {
    try {
      // Check internet connection before attempting fetch
      if (!isInternetReachable) {
        // Try to load from cache when offline
        const cachedProducts = await loadProductsFromCache();
        if (cachedProducts && cachedProducts.length > 0) {
          setProducts(cachedProducts);
          setFilteredProducts(cachedProducts);
          setError('Mode offline - menggunakan data cache');
          setUsingCache(true);
          console.log('üì± Offline mode: Using cached products');
        } else {
          setError('Tidak ada koneksi internet dan tidak ada data cache.');
        }
        setLoading(false);
        setRefreshing(false);
        return;
      }

      // Reset states for new attempt
      if (isManualRetry) {
        setRetryCount(0);
        setError(null);
        setIsRetrying(false);
        setUsingCache(false);
      }

      setLoading(true);

      // Cache-First Strategy: Check cache first unless force refresh
      if (!forceRefresh) {
        const cachedProducts = await loadProductsFromCache();
        if (cachedProducts && cachedProducts.length > 0) {
          setProducts(cachedProducts);
          setFilteredProducts(cachedProducts);
          setUsingCache(true);
          console.log('üíæ Using cached products');
          
          // Continue to fetch fresh data in background
          fetchFreshProducts();
          return;
        }
      }

      // No cache or force refresh - fetch from API
      await fetchFreshProducts();

    } catch (err: unknown) {
      handleFetchError(err);
    }
  };

  // Fetch fresh products from API
  const fetchFreshProducts = async () => {
    const currentAttempt = retryCount + 1;
    console.log(`üîÑ Fetch attempt ${currentAttempt}/${maxRetries + 1}`);

    try {
      await executeIfOnline(async () => {
        const response = await fetch('https://dummyjson.com/products');

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();

        if (data && data.products) {
          // Convert API products to our Product format
          const convertedProducts: Product[] = data.products.map((apiProduct: ApiProduct) =>
            convertApiProduct(apiProduct)
          );

          setProducts(convertedProducts);
          setFilteredProducts(convertedProducts);
          setError(null);
          setRetryCount(0);
          setIsRetrying(false);
          setUsingCache(false);

          // Save to cache
          await saveProductsToCache(convertedProducts);

          console.log('‚úÖ Products loaded successfully and cached');
        }
      }, {
        showAlert: false,
        alertMessage: 'Tidak dapat memuat produk saat offline.'
      });

    } catch (err: unknown) {
      // If API fails, try to use cache as fallback
      const cachedProducts = await loadProductsFromCache();
      if (cachedProducts && cachedProducts.length > 0) {
        setProducts(cachedProducts);
        setFilteredProducts(cachedProducts);
        setUsingCache(true);
        setError('Gagal memuat data terbaru, menggunakan data cache');
        console.log('üîÑ Fallback to cached data after API failure');
      } else {
        throw err; // Re-throw if no cache available
      }
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // Handle fetch errors
  const handleFetchError = async (err: unknown) => {
    console.error(`‚ùå Fetch attempt ${retryCount + 1} failed:`, err);

    let errorMessage = 'Unknown error occurred';

    // Handle different error types
    if (err instanceof Error) {
      errorMessage = err.message;
    } else if (typeof err === 'string') {
      errorMessage = err;
    } else if (err && typeof err === 'object' && 'message' in err) {
      errorMessage = String((err as any).message);
    }

    // Try cache as fallback
    const cachedProducts = await loadProductsFromCache();
    if (cachedProducts && cachedProducts.length > 0) {
      setProducts(cachedProducts);
      setFilteredProducts(cachedProducts);
      setUsingCache(true);
      setError('Gagal memuat data terbaru, menggunakan data cache');
      setLoading(false);
      setRefreshing(false);
      return;
    }

    // Handle network-specific errors
    if (errorMessage === 'NO_INTERNET_CONNECTION') {
      setError('Tidak ada koneksi internet. Periksa koneksi Anda.');
      setIsRetrying(false);
      setLoading(false);
      setRefreshing(false);
      return;
    }

    // Check if we should retry (only if we have internet)
    if (retryCount < maxRetries && isInternetReachable) {
      const delay = getRetryDelay(retryCount);
      const nextAttempt = retryCount + 2;

      console.log(`‚è≥ Retrying in ${delay / 1000}s... (Attempt ${nextAttempt})`);
      setIsRetrying(true);

      // Show temporary error message
      setError(`Gagal memuat produk. Mencoba lagi dalam ${delay / 1000} detik... (${retryCount + 1}/${maxRetries})`);

      // Schedule retry with exponential backoff
      setTimeout(() => {
        console.log(`üöÄ Executing auto-retry ${nextAttempt}`);
        setRetryCount(prev => prev + 1);
      }, delay);
    } else {
      // Max retries reached or no internet - show permanent error
      setIsRetrying(false);
      if (!isInternetReachable) {
        setError('Tidak ada koneksi internet. Periksa koneksi Anda.');
      } else {
        setError(`Gagal memuat produk setelah ${maxRetries + 1} percobaan. ${errorMessage}`);
      }
      console.error(`üí• All ${maxRetries + 1} attempts failed`);
    }
  };

  // Manual retry function with network check
  const handleManualRetry = () => {
    console.log('üîÑ Manual retry triggered', { isOnline: isInternetReachable });

    if (!isInternetReachable) {
      Alert.alert(
        'Tidak Terkoneksi',
        'Tidak ada koneksi internet. Periksa koneksi Anda dan coba lagi.',
        [{ text: 'OK' }]
      );
      return;
    }

    fetchProducts(true, true); // Force refresh on manual retry
  };

  // Clear cache and refresh
  const handleClearCache = async () => {
    await cacheManager.remove(PRODUCTS_CACHE_KEY);
    await cacheManager.remove(CATEGORIES_CACHE_KEY);
    Alert.alert('Success', 'Cache cleared successfully');
    fetchProducts(false, true);
  };

  useEffect(() => {
    fetchProducts();
  }, []);

  // Trigger automatic retry when retryCount changes (only if online)
  useEffect(() => {
    if (retryCount > 0 && retryCount <= maxRetries && isInternetReachable) {
      fetchProducts();
    }
  }, [retryCount, isInternetReachable]);

  // Handle network connection recovery
  useEffect(() => {
    if (isInternetReachable && error && error.includes('Tidak ada koneksi internet')) {
      console.log('üåê Connection recovered, auto-retrying...');
      setError('Koneksi pulih. Memuat ulang produk...');
      setTimeout(() => {
        fetchProducts(true, true);
      }, 1000);
    }
  }, [isInternetReachable]);

  // Filter products based on search and category
  useEffect(() => {
    let filtered = products;

    // Filter by search query
    if (searchQuery) {
      filtered = filtered.filter(product =>
        product.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        product.description.toLowerCase().includes(searchQuery.toLowerCase()) ||
        product.category.toLowerCase().includes(searchQuery.toLowerCase())
      );
    }

    // Filter by category
    if (selectedCategory !== 'all') {
      filtered = filtered.filter(product =>
        product.category.toLowerCase() === selectedCategory.toLowerCase()
      );
    }

    setFilteredProducts(filtered);
  }, [searchQuery, selectedCategory, products]);

  const onRefresh = () => {
    if (!isInternetReachable) {
      Alert.alert(
        'Tidak Terkoneksi',
        'Tidak dapat refresh produk saat offline.',
        [{ text: 'OK' }]
      );
      return;
    }

    setRefreshing(true);
    setRetryCount(0);
    setError(null);
    setIsRetrying(false);
    setUsingCache(false);
    fetchProducts(false, true); // Force refresh on pull-to-refresh
  };

  const handleProductPress = (product: Product) => {
    navigation.navigate('ProductDetail', { productId: product.id });
  };

  const getCategories = () => {
    const categories = ['all', ...new Set(products.map(product => product.category))];
    return categories;
  };

  const formatPrice = (price: number) => {
    return `$${price.toFixed(2)}`;
  };

  const calculateDiscountPrice = (price: number, discount?: number) => {
    if (!discount) return price;
    return price - (price * discount / 100);
  };

  const renderProductItem = ({ item }: { item: Product }) => (
    <TouchableOpacity
      style={styles.productCard}
      onPress={() => handleProductPress(item)}
    >
      <Image source={{ uri: item.image }} style={styles.productImage} />

      {/* ‚úÖ WISHLIST BUTTON - Position Absolute di atas gambar */}
      <View style={styles.wishlistButtonContainer}>
        <WishlistButton 
          product={item}
          size={20}
          style={styles.wishlistButton}
        />
      </View>

      {/* Badge Container untuk NEW dan Discount */}
      <View style={styles.badgeContainer}>
        {item.isNew && (
          <View style={[styles.badge, styles.newBadge]}>
            <Text style={styles.badgeText}>NEW</Text>
          </View>
        )}
        {item.discount && item.discount > 0 && (
          <View style={[styles.badge, styles.discountBadge]}>
            <Text style={styles.badgeText}>-{Math.round(item.discount)}%</Text>
          </View>
        )}
      </View>

      <View style={styles.productInfo}>
        <Text style={styles.productTitle} numberOfLines={2}>
          {item.name}
        </Text>

        <Text style={styles.productCategory}>
          {item.category}
        </Text>

        <View style={styles.priceContainer}>
          {item.discount && item.discount > 0 ? (
            <>
              <Text style={styles.originalPrice}>
                {formatPrice(item.price)}
              </Text>
              <Text style={styles.discountPrice}>
                {formatPrice(calculateDiscountPrice(item.price, item.discount))}
              </Text>
            </>
          ) : (
            <Text style={styles.normalPrice}>
              {formatPrice(item.price)}
            </Text>
          )}
        </View>

        <Text style={styles.productDescription} numberOfLines={2}>
          {item.description}
        </Text>
      </View>
    </TouchableOpacity>
  );

  const renderCategoryChip = (category: string) => (
    <TouchableOpacity
      key={category}
      style={[
        styles.categoryChip,
        selectedCategory === category && styles.categoryChipSelected
      ]}
      onPress={() => setSelectedCategory(category)}
    >
      <Text style={[
        styles.categoryText,
        selectedCategory === category && styles.categoryTextSelected
      ]}>
        {category.charAt(0).toUpperCase() + category.slice(1)}
      </Text>
    </TouchableOpacity>
  );

  // Show permanent error UI after all retries failed or no internet
  if (error && !isRetrying && (retryCount >= maxRetries || !isInternetReachable)) {
    return (
      <View style={styles.errorContainer}>
        <FontAwesome6
          name={isInternetReachable ? "triangle-exclamation" : "wifi"}
          size={64}
          color={isInternetReachable ? "#ff6b6b" : "#6b7280"}
          iconStyle='solid'
        />
        <Text style={styles.errorTitle}>
          {isInternetReachable ? 'Gagal Memuat Produk' : 'Tidak Terkoneksi'}
        </Text>
        <Text style={styles.errorMessage}>{error}</Text>
        <Text style={styles.retryInfo}>
          {!isInternetReachable
            ? 'Sambungkan perangkat Anda ke internet'
            : `${maxRetries + 1} percobaan otomatis telah dilakukan`
          }
        </Text>
        <TouchableOpacity
          style={[
            styles.retryButton,
            !isInternetReachable && styles.retryButtonOffline
          ]}
          onPress={handleManualRetry}
        >
          <Text style={styles.retryButtonText}>
            {isInternetReachable ? 'Coba Lagi Manual' : 'Coba Lagi'}
          </Text>
        </TouchableOpacity>
        {usingCache && (
          <Text style={styles.cacheIndicator}>
            üì± Sedang menggunakan data cache
          </Text>
        )}
      </View>
    );
  }

  // Show loading with retry info during retries
  if (loading || isRetrying) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#2e7d32" />
        <Text style={styles.loadingText}>
          {isRetrying
            ? `Mencoba lagi... (${retryCount + 1}/${maxRetries})`
            : usingCache ? 'Memuat data cache...' : 'Loading products...'
          }
        </Text>
        {isRetrying && (
          <Text style={styles.retryInfo}>
            Percobaan otomatis {retryCount + 1} dari {maxRetries}
          </Text>
        )}
        {error && isRetrying && (
          <Text style={styles.retryDetail}>{error}</Text>
        )}
        {!isInternetReachable && (
          <Text style={styles.offlineWarning}>
            ‚ö†Ô∏è Sedang offline - menunggu koneksi...
          </Text>
        )}
        {usingCache && (
          <Text style={styles.cacheIndicator}>
            üíæ Menggunakan data cache
          </Text>
        )}
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* Network Status Indicator */}
      {!isInternetReachable && (
        <View style={styles.offlineIndicator}>
          <FontAwesome6 name="wifi" size={14} color="#ffffff" iconStyle='solid' />
          <Text style={styles.offlineIndicatorText}>Mode Offline</Text>
        </View>
      )}

      {/* Cache Status Indicator */}
      {usingCache && (
        <View style={styles.cacheBanner}>
          <FontAwesome6 name="database" size={14} color="#ffffff" iconStyle='solid' />
          <Text style={styles.cacheBannerText}>Menggunakan data cache</Text>
          <TouchableOpacity onPress={handleClearCache} style={styles.clearCacheButton}>
            <Text style={styles.clearCacheText}>Clear</Text>
          </TouchableOpacity>
        </View>
      )}

      {/* Temporary Error Banner during retries */}
      {error && isRetrying && (
        <View style={styles.retryBanner}>
          <FontAwesome6 name="clock-rotate-left" size={16} color="#fff" iconStyle='solid' />
          <Text style={styles.retryBannerText}>{error}</Text>
        </View>
      )}

      {/* Search Bar */}
      <View style={[
        styles.searchContainer,
        !isInternetReachable && styles.searchContainerOffline
      ]}>
        <FontAwesome6 name="magnifying-glass" size={16} color="#666" iconStyle='solid' />
        <TextInput
          style={styles.searchInput}
          placeholder={isInternetReachable ? "Search products..." : "Search (offline mode)"}
          value={searchQuery}
          onChangeText={setSearchQuery}
          placeholderTextColor="#999"
          editable={isInternetReachable || products.length > 0}
        />
        {searchQuery ? (
          <TouchableOpacity onPress={() => setSearchQuery('')}>
            <FontAwesome6 name="xmark" size={16} color="#666" iconStyle='solid' />
          </TouchableOpacity>
        ) : null}
      </View>

      {/* Categories */}
      <View style={styles.categoriesContainer}>
        <FlatList
          horizontal
          data={getCategories()}
          renderItem={({ item }) => renderCategoryChip(item)}
          keyExtractor={(item) => item}
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.categoriesList}
        />
      </View>

      {/* Products Count with Online Status */}
      <View style={styles.resultsContainer}>
        <Text style={styles.resultsText}>
          {filteredProducts.length} products found
          {!isInternetReachable && ' ‚Ä¢ Offline'}
          {usingCache && ' ‚Ä¢ Cache'}
          {isAuthenticated && ' ‚Ä¢ Login'} {/* ‚úÖ Tampilkan status login */}
        </Text>
      </View>

      {/* Products List */}
      <FlatList
        data={filteredProducts}
        renderItem={renderProductItem}
        keyExtractor={(item) => item.id}
        numColumns={2}
        columnWrapperStyle={styles.productsRow}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={['#2e7d32']}
            enabled={isInternetReachable}
          />
        }
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <FontAwesome6
              name={isInternetReachable ? "box-open" : "wifi"}
              size={64}
              color="#ccc"
              iconStyle='solid'
            />
            <Text style={styles.emptyText}>
              {isInternetReachable ? 'No products found' : 'Tidak Terkoneksi'}
            </Text>
            <Text style={styles.emptySubtext}>
              {isInternetReachable
                ? 'Try adjusting your search or filter'
                : 'Sambungkan ke internet untuk memuat produk'
              }
            </Text>
          </View>
        }
        contentContainerStyle={styles.productsList}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#9bf89bff',
    padding: 16,
  },
  wishlistButtonContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
    zIndex: 10, // Pastikan di atas badge lainnya
  },
  wishlistButton: {
    // Style tambahan untuk wishlist button di product card
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
  },

  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f0f7f0',
    padding: 20,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#2e7d32',
    textAlign: 'center',
  },
  offlineWarning: {
    fontSize: 14,
    color: '#dc2626',
    textAlign: 'center',
    marginTop: 8,
    fontWeight: '500',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f0f7f0',
    padding: 20,
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#d32f2f',
    marginTop: 16,
    marginBottom: 8,
    textAlign: 'center',
  },
  errorMessage: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 8,
    lineHeight: 20,
  },
  retryInfo: {
    fontSize: 14,
    color: '#888',
    textAlign: 'center',
    marginBottom: 20,
    fontStyle: 'italic',
  },
  retryDetail: {
    fontSize: 12,
    color: '#666',
    textAlign: 'center',
    marginTop: 8,
    fontStyle: 'italic',
  },
  retryButton: {
    backgroundColor: '#2e7d32',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
    elevation: 2,
  },
  retryButtonOffline: {
    backgroundColor: '#6b7280',
  },
  retryButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  retryBanner: {
    backgroundColor: '#ff9800',
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderRadius: 8,
    marginBottom: 16,
  },
  retryBannerText: {
    color: '#ffffff',
    fontSize: 14,
    fontWeight: '500',
    marginLeft: 8,
  },
  offlineIndicator: {
    backgroundColor: '#6b7280',
    flexDirection: 'row',
    alignItems: 'center',
    padding: 8,
    borderRadius: 8,
    marginBottom: 12,
    alignSelf: 'flex-start',
    gap: 6,
  },
  offlineIndicatorText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: '500',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 5,
    marginBottom: 16,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  searchContainerOffline: {
    backgroundColor: '#f3f4f6',
    opacity: 0.7,
  },
  searchInput: {
    flex: 1,
    marginLeft: 12,
    fontSize: 16,
    color: '#333',
  },
  categoriesContainer: {
    marginBottom: 16,
  },
  categoriesList: {
    paddingRight: 16,
  },
  categoryChip: {
    backgroundColor: '#ffffff',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    marginRight: 8,
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  categoryChipSelected: {
    backgroundColor: '#2e7d32',
    borderColor: '#2e7d32',
  },
  categoryText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  categoryTextSelected: {
    color: '#ffffff',
    fontWeight: '600',
  },
  resultsContainer: {
    marginBottom: 16,
  },
  resultsText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  productsList: {
    paddingBottom: 16,
  },
  productsRow: {
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  productCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    width: '48%',
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    overflow: 'hidden',
    position: 'relative',
  },
  productImage: {
    width: '100%',
    height: 120,
    resizeMode: 'cover',
  },
  badgeContainer: {
    position: 'absolute',
    top: 8,
    left: 8,
    gap: 6, // Jarak antar badge
    alignItems: 'flex-start',
  },
  badge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
  },
  badgeText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: 'bold',
  },
  discountBadge: {
    backgroundColor: '#ff4444',
  },
  newBadge: {
    backgroundColor: '#4caf50',
  },
  productInfo: {
    padding: 12,
  },
  productTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  productCategory: {
    fontSize: 12,
    color: '#666',
    marginBottom: 8,
    fontWeight: '500',
    textTransform: 'capitalize',
  },
  priceContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  originalPrice: {
    fontSize: 12,
    color: '#999',
    textDecorationLine: 'line-through',
    marginRight: 6,
  },
  discountPrice: {
    fontSize: 16,
    color: '#2e7d32',
    fontWeight: 'bold',
  },
  normalPrice: {
    fontSize: 16,
    color: '#2e7d32',
    fontWeight: 'bold',
  },
  productDescription: {
    fontSize: 11,
    color: '#888',
    lineHeight: 14,
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  emptyText: {
    fontSize: 18,
    color: '#666',
    fontWeight: '600',
    marginTop: 16,
    marginBottom: 8,
  },
  emptySubtext: {
    fontSize: 14,
    color: '#999',
    textAlign: 'center',
  },
  cacheBanner: {
    backgroundColor: '#ff9800',
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderRadius: 8,
    marginBottom: 16,
  },
  cacheBannerText: {
    color: '#ffffff',
    fontSize: 14,
    fontWeight: '500',
    marginLeft: 8,
    flex: 1,
  },
  clearCacheButton: {
    backgroundColor: 'rgba(255,255,255,0.3)',
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 4,
  },
  clearCacheText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: '600',
  },
  cacheIndicator: {
    fontSize: 14,
    color: '#ff9800',
    textAlign: 'center',
    marginTop: 8,
    fontWeight: '500',
  },
});

export default ProductListScreen;./screens/dashboard/Profile.tsx
==== ./screens/dashboard/Profile.tsx ====
import React, { useState, useContext, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  TextInput,
  Alert,
  ActivityIndicator,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { DrawerNavigationProp } from '@react-navigation/drawer';
import { RootDrawerParamList, User } from '../../types'; // Import User type
import { AuthContext } from '../../context/AuthContext';
import FontAwesome6 from '@react-native-vector-icons/fontawesome6';

// Extended interface untuk form data
interface UserFormData {
  name: string;
  email: string;
  phone: string;
  address: string;
}

const ProfileScreen = () => {
  const navigation = useNavigation<DrawerNavigationProp<RootDrawerParamList>>();
  const { 
    user, 
    isAuthenticated, 
    updateProfile, 
    logout, 
    loadingAuth 
  } = useContext(AuthContext);

  const [isEditing, setIsEditing] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [userData, setUserData] = useState<UserFormData>({
    name: '',
    email: '',
    phone: '',
    address: '',
  });

  // Safe data extraction dengan fallbacks
  const getUserData = (userData: User | undefined): UserFormData => {
    return {
      name: userData?.name || '',
      email: userData?.email || '',
      phone: userData?.phone || '',
      address: userData?.address || '',
    };
  };

  const getJoinDate = (userData: User | undefined): string => {
    return userData?.joinDate || '2024-01-01'; // Default value
  };

  // Load user data ketika component mount atau user berubah
  useEffect(() => {
    if (user) {
      setUserData(getUserData(user));
    }
  }, [user]);

  const handleSave = async () => {
    if (!userData.name.trim() || !userData.email.trim()) {
      Alert.alert('Error', 'Please fill in all required fields');
      return;
    }

    setIsLoading(true);
    
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Update profile dengan data yang valid
      updateProfile({
        name: userData.name,
        email: userData.email,
        phone: userData.phone || undefined, // Convert empty string to undefined
        address: userData.address || undefined,
        // joinDate tetap tidak diubah karena readonly
      });
      
      setIsLoading(false);
      setIsEditing(false);
      Alert.alert('Success', 'Profile updated successfully!');
    } catch (error) {
      setIsLoading(false);
      Alert.alert('Error', 'Failed to update profile. Please try again.');
    }
  };

  const handleEdit = () => {
    setIsEditing(true);
  };

  const handleCancel = () => {
    // Reset ke data asli
    if (user) {
      setUserData(getUserData(user));
    }
    setIsEditing(false);
  };

  const handleInputChange = (field: keyof UserFormData, value: string) => {
    setUserData(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleLogout = () => {
    Alert.alert(
      'Logout',
      'Yakin mau keluar dari akun lu?',
      [
        {
          text: 'Batal',
          style: 'cancel',
        },
        {
          text: 'Ya, Logout',
          style: 'destructive',
          onPress: async () => {
            try {
              await logout({ reason: 'user_initiated' });
            } catch (error) {
              Alert.alert('Error', 'Logout failed. Please try again.');
            }
          },
        },
      ],
      { cancelable: true }
    );
  };

  const handleClearAllData = () => {
    Alert.alert(
      'Clear All Data',
      'This will remove ALL your data including preferences, cart, and favorites. This action cannot be undone!',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Clear Everything',
          style: 'destructive',
          onPress: async () => {
            try {
              await logout({ 
                clearAll: false, 
                reason: 'user_clear_data' 
              });
              Alert.alert('Success', 'All data has been cleared successfully');
            } catch (error) {
              Alert.alert('Error', 'Failed to clear data. Please try again.');
            }
          },
        },
      ]
    );
  };


  // Loading state
  if (loadingAuth) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#2e7d32" />
        <Text style={styles.loadingText}>Loading profile...</Text>
      </View>
    );
  }

  // Jika belum login, tampilkan pesan
  if (!isAuthenticated || !user) {
    return (
      <View style={styles.container}>
        <View style={styles.notLoggedInContainer}>
          <FontAwesome6 name="user-slash" size={64} color="#666" iconStyle='solid' />
          <Text style={styles.notLoggedInTitle}>Not Logged In</Text>
          <Text style={styles.notLoggedInText}>
            Please login to view your profile
          </Text>
          <TouchableOpacity 
            style={styles.loginButton}
            onPress={() => navigation.navigate('Login')}
          >
            <Text style={styles.loginButtonText}>Go to Login</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  }

  const getInitials = (name: string) => {
    if (!name.trim()) return 'US';
    return name
      .split(' ')
      .map(n => n[0])
      .join('')
      .toUpperCase()
      .substring(0, 2);
  };

  const formatJoinDate = (joinDate: string) => {
    try {
      const date = new Date(joinDate);
      return date.toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'long' 
      });
    } catch {
      return 'January 2024';
    }
  };

  return (
    <ScrollView style={styles.container} showsVerticalScrollIndicator={false}>
      {/* Header Section */}
      <View style={styles.header}>
        <View style={styles.avatarContainer}>
          <View style={styles.avatar}>
            <Text style={styles.avatarText}>
              {getInitials(userData.name)}
            </Text>
          </View>
          <TouchableOpacity style={styles.editAvatarButton}>
            <FontAwesome6 name="camera" size={16} color="#ffffff" iconStyle='solid' />
          </TouchableOpacity>
        </View>
        
        <Text style={styles.userName}>{userData.name}</Text>
        <Text style={styles.userEmail}>{userData.email}</Text>
        
        <View style={styles.memberSince}>
          <FontAwesome6 name="calendar" size={12} color="#e8f5e9" iconStyle='solid' />
          <Text style={styles.memberSinceText}>
            Member since {formatJoinDate(getJoinDate(user))}
          </Text>
        </View>
      </View>

      {/* Profile Information Section */}
      <View style={styles.section}>
        <View style={styles.sectionHeader}>
          <Text style={styles.sectionTitle}>Personal Information</Text>
          {!isEditing ? (
            <TouchableOpacity 
              style={styles.editButton} 
              onPress={handleEdit}
              disabled={isLoading}
            >
              <FontAwesome6 name="pen" size={14} color="#2e7d32" iconStyle='solid' />
              <Text style={styles.editButtonText}> Edit</Text>
            </TouchableOpacity>
          ) : null}
        </View>

        <View style={styles.form}>
          {/* Name Field */}
          <View style={styles.inputGroup}>
            <Text style={styles.label}>
              <FontAwesome6 name="user" size={14} color="#2e7d32" iconStyle='solid' /> Full Name *
            </Text>
            {isEditing ? (
              <TextInput
                style={styles.input}
                value={userData.name}
                onChangeText={(value) => handleInputChange('name', value)}
                placeholder="Enter your full name"
                placeholderTextColor="#999"
                editable={!isLoading}
              />
            ) : (
              <Text style={styles.value}>{userData.name}</Text>
            )}
          </View>

          {/* Email Field */}
          <View style={styles.inputGroup}>
            <Text style={styles.label}>
              <FontAwesome6 name="envelope" size={14} color="#2e7d32" iconStyle='solid' /> Email Address *
            </Text>
            {isEditing ? (
              <TextInput
                style={styles.input}
                value={userData.email}
                onChangeText={(value) => handleInputChange('email', value)}
                placeholder="Enter your email"
                placeholderTextColor="#999"
                keyboardType="email-address"
                autoCapitalize="none"
                editable={!isLoading}
              />
            ) : (
              <Text style={styles.value}>{userData.email}</Text>
            )}
          </View>

          {/* Phone Field */}
          <View style={styles.inputGroup}>
            <Text style={styles.label}>
              <FontAwesome6 name="phone" size={14} color="#2e7d32" iconStyle='solid' /> Phone Number
            </Text>
            {isEditing ? (
              <TextInput
                style={styles.input}
                value={userData.phone}
                onChangeText={(value) => handleInputChange('phone', value)}
                placeholder="Enter your phone number"
                placeholderTextColor="#999"
                keyboardType="phone-pad"
                editable={!isLoading}
              />
            ) : (
              <Text style={styles.value}>
                {userData.phone || 'Not provided'}
              </Text>
            )}
          </View>

          {/* Address Field */}
          <View style={styles.inputGroup}>
            <Text style={styles.label}>
              <FontAwesome6 name="location-dot" size={14} color="#2e7d32" iconStyle='solid' /> Address
            </Text>
            {isEditing ? (
              <TextInput
                style={[styles.input, styles.textArea]}
                value={userData.address}
                onChangeText={(value) => handleInputChange('address', value)}
                placeholder="Enter your address"
                placeholderTextColor="#999"
                multiline
                numberOfLines={3}
                textAlignVertical="top"
                editable={!isLoading}
              />
            ) : (
              <Text style={styles.value}>
                {userData.address || 'Not provided'}
              </Text>
            )}
          </View>

          {/* Edit Mode Buttons */}
          {isEditing && (
            <View style={styles.editButtons}>
              <TouchableOpacity 
                style={[styles.button, styles.cancelButton]}
                onPress={handleCancel}
                disabled={isLoading}
              >
                <Text style={styles.cancelButtonText}>
                  {isLoading ? 'Canceling...' : 'Cancel'}
                </Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={[
                  styles.button, 
                  styles.saveButton,
                  isLoading && styles.buttonDisabled
                ]}
                onPress={handleSave}
                disabled={isLoading}
              >
                {isLoading ? (
                  <ActivityIndicator color="#ffffff" size="small" />
                ) : (
                  <>
                    <FontAwesome6 name="check" size={16} color="#ffffff" iconStyle='solid' />
                    <Text style={styles.saveButtonText}> Save Changes</Text>
                  </>
                )}
              </TouchableOpacity>
            </View>
          )}
        </View>
      </View>

      {/* Account Stats */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Account Statistics</Text>
        <View style={styles.statsGrid}>
          <View style={styles.statItem}>
            <FontAwesome6 name="cart-shopping" size={20} color="#2e7d32" iconStyle='solid' />
            <Text style={styles.statNumber}>12</Text>
            <Text style={styles.statLabel}>Orders</Text>
          </View>
          <View style={styles.statItem}>
            <FontAwesome6 name="heart" size={20} color="#2e7d32" iconStyle='solid' />
            <Text style={styles.statNumber}>8</Text>
            <Text style={styles.statLabel}>Wishlist</Text>
          </View>
          <View style={styles.statItem}>
            <FontAwesome6 name="star" size={20} color="#2e7d32" iconStyle='solid' />
            <Text style={styles.statNumber}>47</Text>
            <Text style={styles.statLabel}>Reviews</Text>
          </View>
          <View style={styles.statItem}>
            <FontAwesome6 name="award" size={20} color="#2e7d32" iconStyle='solid' />
            <Text style={styles.statNumber}>Gold</Text>
            <Text style={styles.statLabel}>Member</Text>
          </View>
        </View>
      </View>

      {/* Actions Section */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Account Actions</Text>
        
        <TouchableOpacity style={styles.actionButton}>
          <FontAwesome6 name="credit-card" size={16} color="#2e7d32" iconStyle='solid' />
          <Text style={styles.actionButtonText}> Payment Methods</Text>
        </TouchableOpacity>
        
        <TouchableOpacity style={styles.actionButton}>
          <FontAwesome6 name="location-arrow" size={16} color="#2e7d32" iconStyle='solid' />
          <Text style={styles.actionButtonText}> Shipping Addresses</Text>
        </TouchableOpacity>
        
        <TouchableOpacity style={styles.actionButton}>
          <FontAwesome6 name="bell" size={16} color="#2e7d32" iconStyle='solid' />
          <Text style={styles.actionButtonText}> Notification Settings</Text>
        </TouchableOpacity>
        
        <TouchableOpacity style={styles.actionButton}>
          <FontAwesome6 name="shield" size={16} color="#2e7d32" iconStyle='solid' />
          <Text style={styles.actionButtonText}> Privacy & Security</Text>
        </TouchableOpacity>
      </View>

      {/* Danger Zone Section */}
      <View style={styles.section}>
        <Text style={styles.dangerSectionTitle}>Danger Zone</Text>
        <Text style={styles.dangerSectionDescription}>
          These actions are irreversible. Please proceed with caution.
        </Text>
        
        <TouchableOpacity 
          style={styles.clearDataButton}
          onPress={handleClearAllData}
        >
          <FontAwesome6 name="broom" size={16} color="#ef4444" iconStyle='solid' />
          <Text style={styles.clearDataButtonText}>Factory Reset</Text>
        </TouchableOpacity>
      </View>

      {/* Logout Button */}
      <View style={styles.section}>
        <TouchableOpacity 
          style={styles.logoutButton}
          onPress={handleLogout}
        >
          <FontAwesome6 name="right-from-bracket" size={16} color="#ffffff" iconStyle='solid' />
          <Text style={styles.logoutButtonText}> Logout</Text>
        </TouchableOpacity>
      </View>


      {/* Bottom Spacer */}
      <View style={styles.bottomSpacer} />
    </ScrollView>
  );
};

// Styles tetap sama seperti sebelumnya
const styles = StyleSheet.create({
  // ... (styles dari kode sebelumnya tetap sama)
  container: {
    flex: 1,
    backgroundColor: '#9bf89bff',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#9bf89bff',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#2e7d32',
    fontWeight: '500',
  },
  notLoggedInContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
    backgroundColor: '#9bf89bff',
  },
  notLoggedInTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginTop: 20,
    marginBottom: 8,
  },
  notLoggedInText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 30,
    lineHeight: 22,
  },
  loginButton: {
    backgroundColor: '#2e7d32',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  loginButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  header: {
    backgroundColor: '#2e7d32',
    padding: 30,
    alignItems: 'center',
    paddingTop: 40,
  },
  avatarContainer: {
    position: 'relative',
    marginBottom: 16,
  },
  avatar: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: '#4caf50',
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
  },
  avatarText: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#ffffff',
  },
  editAvatarButton: {
    position: 'absolute',
    bottom: 0,
    right: 0,
    backgroundColor: '#1b5e20',
    width: 28,
    height: 28,
    borderRadius: 14,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#ffffff',
    elevation: 2,
  },
  userName: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 4,
    textAlign: 'center',
  },
  userEmail: {
    fontSize: 16,
    color: '#e8f5e9',
    marginBottom: 12,
    textAlign: 'center',
  },
  memberSince: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  memberSinceText: {
    fontSize: 12,
    color: '#e8f5e9',
    opacity: 0.9,
  },
  section: {
    backgroundColor: '#ffffff',
    margin: 16,
    marginBottom: 8,
    padding: 20,
    borderRadius: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2e7d32',
  },
  dangerSectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ef4444',
    marginBottom: 8,
  },
  dangerSectionDescription: {
    fontSize: 14,
    color: '#666',
    marginBottom: 16,
    lineHeight: 20,
  },
  editButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#e8f5e9',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 6,
  },
  editButtonText: {
    fontSize: 14,
    color: '#2e7d32',
    fontWeight: '500',
  },
  form: {
    gap: 20,
  },
  inputGroup: {
    gap: 8,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    color: '#2e7d32',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    color: '#333',
    backgroundColor: '#f9f9f9',
  },
  textArea: {
    height: 80,
    textAlignVertical: 'top',
  },
  value: {
    fontSize: 16,
    color: '#333',
    paddingVertical: 8,
    lineHeight: 24,
  },
  editButtons: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 10,
  },
  button: {
    flex: 1,
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'row',
  },
  buttonDisabled: {
    opacity: 0.6,
  },
  cancelButton: {
    backgroundColor: 'transparent',
    borderWidth: 1,
    borderColor: '#666',
  },
  cancelButtonText: {
    color: '#666',
    fontSize: 16,
    fontWeight: '600',
  },
  saveButton: {
    backgroundColor: '#2e7d32',
  },
  saveButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  statsGrid: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statItem: {
    alignItems: 'center',
    flex: 1,
  },
  statNumber: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginTop: 8,
    marginBottom: 4,
  },
  statLabel: {
    fontSize: 12,
    color: '#666',
    textAlign: 'center',
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  actionButtonText: {
    fontSize: 16,
    color: '#333',
    fontWeight: '500',
    marginLeft: 12,
  },
  clearDataButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#fef2f2',
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#fecaca',
  },
  clearDataButtonText: {
    color: '#ef4444',
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 8,
  },
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#ef4444',
    padding: 16,
    borderRadius: 8,
    elevation: 2,
    shadowColor: '#ef4444',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
  },
  logoutButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 8,
  },
  bottomSpacer: {
    height: 20,
  },
});

export default ProfileScreen;./screens/settings/Setting.tsx
==== ./screens/settings/Setting.tsx ====
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Switch,
  Alert,
  TextInput,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { useSwipe } from '../../context/SwipeContext';


const SettingsScreen = () => {
  const navigation = useNavigation();
  const { canSwipe, setCanSwipe } = useSwipe();
  
  const [settings, setSettings] = useState({
    notifications: true,
    darkMode: false,
    autoSync: true,
    locationServices: false,
    biometricLogin: true,
    swipeDrawer: canSwipe
  });

  const [userPreferences, setUserPreferences] = useState({
    language: 'English',
    currency: 'USD',
    region: 'United States',
  });

  const [feedback, setFeedback] = useState('');

  const handleToggleSetting = (setting: keyof typeof settings) => {
    const newValue = !settings[setting];
    
    setSettings(prev => ({
      ...prev,
      [setting]: newValue,
    }));

    // ‚úÖ INTEGRASI SWIPE DRAWER DENGAN CONTEXT
   if (setting === 'swipeDrawer') {
      setCanSwipe(newValue);
      Alert.alert(
        'Swipe Drawer',
        newValue
          ? 'Swipe gesture enabled! You can now open drawer by swiping from the edge.'
          : 'Swipe gesture disabled! Drawer can only be opened via toggle icon.',
        [{ text: 'OK' }]
      );
    }
  };

  // ‚úÖ SYNC SETTINGS DENGAN CONTEXT SETIAP SWIPEEnabled BERUBAH
  useEffect(() => {
    setSettings(prev => ({
      ...prev,
      swipeDrawer: canSwipe,
    }));
  }, [canSwipe]);

  const handleSavePreferences = () => {
    Alert.alert('Success', 'Preferences saved successfully!');
  };

  const handleSubmitFeedback = () => {
    if (feedback.trim().length < 10) {
      Alert.alert('Error', 'Please provide feedback with at least 10 characters.');
      return;
    }
    
    Alert.alert('Thank You', 'Your feedback has been submitted!');
    setFeedback('');
  };

  const handleClearCache = () => {
    Alert.alert(
      'Clear Cache',
      'Are you sure you want to clear all cached data?',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Clear',
          style: 'destructive',
          onPress: () => {
            Alert.alert('Success', 'Cache cleared successfully!');
          },
        },
      ]
    );
  };

  const handleLogout = () => {
    Alert.alert(
      'Logout',
      'Are you sure you want to logout?',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Logout',
          style: 'destructive',
          onPress: () => {
            // Handle logout logic here
            Alert.alert('Success', 'You have been logged out!');
            navigation.goBack();
          },
        },
      ]
    );
  };


  return (
    <ScrollView style={styles.container}>
      {/* Header */}
       <View style={styles.header}>
        <Text style={styles.headerTitle}>‚öôÔ∏è Settings</Text>
        <Text style={styles.headerSubtitle}>
          Manage your app preferences and account settings
        </Text>
      </View>

      {/* App Settings Section */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>App Settings</Text>
        
        {/* ‚úÖ SWIPE DRAWER TOGGLE - TERINTEGRASI DENGAN CONTEXT */}
         <View style={styles.settingItem}>
          <View style={styles.settingInfo}>
            <Text style={styles.settingName}>Swipe to Open Drawer</Text>
            <Text style={styles.settingDescription}>
              {settings.swipeDrawer 
                ? 'Drawer can be opened by swiping from screen edge' 
                : 'Drawer can only be opened via toggle icon'
              }
            </Text>
          </View>
          <Switch
            value={settings.swipeDrawer}
            onValueChange={() => handleToggleSetting('swipeDrawer')}
            trackColor={{ false: '#767577', true: '#81b0ff' }}
            thumbColor={settings.swipeDrawer ? '#2e7d32' : '#f4f3f4'}
          />
        </View>

        <View style={styles.settingItem}>
          <View style={styles.settingInfo}>
            <Text style={styles.settingName}>Push Notifications</Text>
            <Text style={styles.settingDescription}>
              Receive updates about new products and promotions
            </Text>
          </View>
          <Switch
            value={settings.notifications}
            onValueChange={() => handleToggleSetting('notifications')}
            trackColor={{ false: '#767577', true: '#81b0ff' }}
            thumbColor={settings.notifications ? '#2e7d32' : '#f4f3f4'}
          />
        </View>

        <View style={styles.settingItem}>
          <View style={styles.settingInfo}>
            <Text style={styles.settingName}>Dark Mode</Text>
            <Text style={styles.settingDescription}>
              Switch to dark theme for better night viewing
            </Text>
          </View>
          <Switch
            value={settings.darkMode}
            onValueChange={() => handleToggleSetting('darkMode')}
            trackColor={{ false: '#767577', true: '#81b0ff' }}
            thumbColor={settings.darkMode ? '#2e7d32' : '#f4f3f4'}
          />
        </View>

        <View style={styles.settingItem}>
          <View style={styles.settingInfo}>
            <Text style={styles.settingName}>Auto Sync</Text>
            <Text style={styles.settingDescription}>
              Automatically sync your data with the cloud
            </Text>
          </View>
          <Switch
            value={settings.autoSync}
            onValueChange={() => handleToggleSetting('autoSync')}
            trackColor={{ false: '#767577', true: '#81b0ff' }}
            thumbColor={settings.autoSync ? '#2e7d32' : '#f4f3f4'}
          />
        </View>

        <View style={styles.settingItem}>
          <View style={styles.settingInfo}>
            <Text style={styles.settingName}>Location Services</Text>
            <Text style={styles.settingDescription}>
              Allow app to access your location for better recommendations
            </Text>
          </View>
          <Switch
            value={settings.locationServices}
            onValueChange={() => handleToggleSetting('locationServices')}
            trackColor={{ false: '#767577', true: '#81b0ff' }}
            thumbColor={settings.locationServices ? '#2e7d32' : '#f4f3f4'}
          />
        </View>

        <View style={styles.settingItem}>
          <View style={styles.settingInfo}>
            <Text style={styles.settingName}>Biometric Login</Text>
            <Text style={styles.settingDescription}>
              Use fingerprint or face ID for faster login
            </Text>
          </View>
          <Switch
            value={settings.biometricLogin}
            onValueChange={() => handleToggleSetting('biometricLogin')}
            trackColor={{ false: '#767577', true: '#81b0ff' }}
            thumbColor={settings.biometricLogin ? '#2e7d32' : '#f4f3f4'}
          />
        </View>
      </View>

      {/* Preferences Section */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Preferences</Text>

        <View style={styles.preferenceItem}>
          <Text style={styles.preferenceLabel}>Language</Text>
          <View style={styles.preferenceValue}>
            <Text style={styles.preferenceText}>{userPreferences.language}</Text>
            <TouchableOpacity style={styles.changeButton}>
              <Text style={styles.changeButtonText}>Change</Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.preferenceItem}>
          <Text style={styles.preferenceLabel}>Currency</Text>
          <View style={styles.preferenceValue}>
            <Text style={styles.preferenceText}>{userPreferences.currency}</Text>
            <TouchableOpacity style={styles.changeButton}>
              <Text style={styles.changeButtonText}>Change</Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.preferenceItem}>
          <Text style={styles.preferenceLabel}>Region</Text>
          <View style={styles.preferenceValue}>
            <Text style={styles.preferenceText}>{userPreferences.region}</Text>
            <TouchableOpacity style={styles.changeButton}>
              <Text style={styles.changeButtonText}>Change</Text>
            </TouchableOpacity>
          </View>
        </View>

        <TouchableOpacity
          style={styles.saveButton}
          onPress={handleSavePreferences}
        >
          <Text style={styles.saveButtonText}>Save Preferences</Text>
        </TouchableOpacity>
      </View>

      {/* Feedback Section */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Feedback</Text>
        <Text style={styles.feedbackDescription}>
          We'd love to hear your thoughts and suggestions to improve our app.
        </Text>

        <TextInput
          style={styles.feedbackInput}
          value={feedback}
          onChangeText={setFeedback}
          placeholder="Tell us what you think..."
          placeholderTextColor="#999"
          multiline
          numberOfLines={4}
          textAlignVertical="top"
        />

        <TouchableOpacity
          style={[
            styles.feedbackButton,
            feedback.trim().length < 10 && styles.feedbackButtonDisabled
          ]}
          onPress={handleSubmitFeedback}
          disabled={feedback.trim().length < 10}
        >
          <Text style={styles.feedbackButtonText}>Submit Feedback</Text>
        </TouchableOpacity>
      </View>

      {/* Actions Section */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Actions</Text>

        <TouchableOpacity
          style={[styles.actionButton, styles.clearCacheButton]}
          onPress={handleClearCache}
        >
          <Text style={styles.actionButtonText}>üóëÔ∏è Clear Cache</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.actionButton, styles.helpButton]}
        >
          <Text style={styles.actionButtonText}>‚ùì Help & Support</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.actionButton, styles.aboutButton]}
        >
          <Text style={styles.actionButtonText}>‚ÑπÔ∏è About App</Text>
        </TouchableOpacity>
      </View>

      {/* Account Section */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Account</Text>

        <TouchableOpacity
          style={[styles.actionButton, styles.logoutButton]}
          onPress={handleLogout}
        >
          <Text style={styles.logoutButtonText}>üö™ Logout</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.actionButton, styles.deleteButton]}
        >
          <Text style={styles.deleteButtonText}>üóëÔ∏è Delete Account</Text>
        </TouchableOpacity>
      </View>

      {/* App Info */}
      <View style={styles.appInfo}>
        <Text style={styles.appVersion}>Eco Store v1.0.0</Text>
        <Text style={styles.appCopyright}>¬© 2024 Eco Store. All rights reserved.</Text>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  header: {
    backgroundColor: '#2e7d32',
    padding: 24,
    paddingTop: 40,
  },
  headerTitle: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 8,
  },
  headerSubtitle: {
    fontSize: 16,
    color: '#e8f5e9',
    opacity: 0.9,
    lineHeight: 20,
  },
  section: {
    backgroundColor: '#ffffff',
    margin: 16,
    marginBottom: 8,
    padding: 20,
    borderRadius: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#2e7d32',
    marginBottom: 16,
  },
  settingItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  settingInfo: {
    flex: 1,
    marginRight: 16,
  },
  settingName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  settingDescription: {
    fontSize: 14,
    color: '#666',
    lineHeight: 18,
  },
  preferenceItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  preferenceLabel: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
  },
  preferenceValue: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  preferenceText: {
    fontSize: 14,
    color: '#666',
  },
  changeButton: {
    backgroundColor: '#e8f5e9',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 6,
  },
  changeButtonText: {
    fontSize: 12,
    color: '#2e7d32',
    fontWeight: '500',
  },
  saveButton: {
    backgroundColor: '#2e7d32',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 16,
  },
  saveButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  feedbackDescription: {
    fontSize: 14,
    color: '#666',
    lineHeight: 20,
    marginBottom: 16,
  },
  feedbackInput: {
    backgroundColor: '#f8f9fa',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    color: '#333',
    minHeight: 100,
    textAlignVertical: 'top',
    marginBottom: 16,
  },
  feedbackButton: {
    backgroundColor: '#4caf50',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  feedbackButtonDisabled: {
    backgroundColor: '#a5d6a7',
    opacity: 0.6,
  },
  feedbackButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  actionButton: {
    padding: 16,
    borderRadius: 8,
    marginBottom: 8,
    borderWidth: 1,
  },
  clearCacheButton: {
    backgroundColor: '#fff3e0',
    borderColor: '#ffb74d',
  },
  helpButton: {
    backgroundColor: '#e3f2fd',
    borderColor: '#64b5f6',
  },
  aboutButton: {
    backgroundColor: '#f3e5f5',
    borderColor: '#ba68c8',
  },
  logoutButton: {
    backgroundColor: '#ffebee',
    borderColor: '#ef5350',
  },
  deleteButton: {
    backgroundColor: '#fbe9e7',
    borderColor: '#ff8a65',
  },
  actionButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
  },
  logoutButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#d32f2f',
  },
  deleteButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#f44336',
  },
  appInfo: {
    alignItems: 'center',
    padding: 24,
    marginBottom: 20,
  },
  appVersion: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  appCopyright: {
    fontSize: 12,
    color: '#999',
  },
});

export default SettingsScreen;./services/api/apiClient.ts
==== ./services/api/apiClient.ts ====
// src/api/apiClient.ts
import axios, { AxiosInstance, AxiosResponse, AxiosRequestConfig } from 'axios';
import * as Keychain from 'react-native-keychain';
import { ApiResponse } from '../../types';

// Konfigurasi Keychain untuk API Key
const API_KEYCHAIN_CONFIG = {
  service: 'com.ecom.apiKey', // Namespace berbeda dari user token
  accessible: Keychain.ACCESSIBLE.WHEN_UNLOCKED_THIS_DEVICE_ONLY,
} as const;

// API Key statis aplikasi (ganti dengan API Key sebenarnya)
const APP_API_KEY = 'ek_yourapp_987654321abcdef1234567890';

// Helper untuk mengelola API Key di Keychain
const ApiKeychainHelper = {
  async saveApiKey(apiKey: string): Promise<void> {
    try {
      if (!apiKey) {
        throw new Error('API Key cannot be empty');
      }

      const result = await Keychain.setGenericPassword(
        'appApiKey',
        apiKey,
        API_KEYCHAIN_CONFIG
      );

      if (!result) {
        throw new Error('Failed to save API Key to Keychain');
      }

      console.log('‚úÖ API Key saved to Keychain successfully');
    } catch (error) {
      console.error('‚ùå Error saving API Key to Keychain:', error);
      throw error;
    }
  },

  async getApiKey(): Promise<string | null> {
    try {
      const credentials = await Keychain.getGenericPassword(API_KEYCHAIN_CONFIG);
      
      if (credentials && credentials.password) {
        console.log('‚úÖ API Key retrieved from Keychain');
        return credentials.password;
      }
      
      console.log('‚ÑπÔ∏è No API Key found in Keychain');
      return null;
    } catch (error) {
      console.error('‚ùå Error retrieving API Key from Keychain:', error);
      return null;
    }
  },

  async deleteApiKey(): Promise<void> {
    try {
      await Keychain.resetGenericPassword(API_KEYCHAIN_CONFIG);
      console.log('‚úÖ API Key removed from Keychain');
    } catch (error) {
      console.error('‚ùå Error removing API Key from Keychain:', error);
    }
  },

  async hasApiKey(): Promise<boolean> {
    try {
      const credentials = await Keychain.getGenericPassword(API_KEYCHAIN_CONFIG);
      return !!credentials && !!credentials.password;
    } catch (error) {
      console.error('Error checking API Key in Keychain:', error);
      return false;
    }
  }
};

// Setup API Key saat aplikasi pertama kali dijalankan
export const setupAndStoreApiKey = async (): Promise<void> => {
  try {
    console.log('üîß Setting up API Key...');
    
    const hasExistingApiKey = await ApiKeychainHelper.hasApiKey();
    
    if (hasExistingApiKey) {
      console.log('‚úÖ API Key already exists in Keychain');
      return;
    }

    await ApiKeychainHelper.saveApiKey(APP_API_KEY);
    console.log('üéØ API Key setup completed successfully');
    
  } catch (error) {
    console.error('‚ùå Failed to setup API Key:', error);
    throw error;
  }
};

// Create axios instance dengan base configuration
const apiClient: AxiosInstance = axios.create({
  baseURL: 'https://dummyjson.com', // Tetap menggunakan base URL yang ada
  timeout: 15000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Enhanced Request interceptor dengan API Key
apiClient.interceptors.request.use(
  async (config) => {
    try {
      // Tambahkan API Key ke header untuk semua request
      const apiKey = await ApiKeychainHelper.getApiKey();
      
      if (apiKey && config.headers) {
        config.headers['X-API-Key'] = apiKey;
      }

      console.log(`üöÄ [API] ${config.method?.toUpperCase()} ${config.url}`, {
        headers: {
          ...config.headers,
          'X-API-Key': apiKey ? '***' + apiKey.slice(-4) : 'MISSING' // Log partial untuk security
        },
        data: config.data ? { ...config.data } : 'no data'
      });

      return config;
    } catch (error) {
      console.error('‚ùå [API] Request Interceptor Error:', error);
      return config; // Tetap lanjutkan request meski ada error di interceptor
    }
  },
  (error) => {
    console.error('‚ùå [API] Request Error:', error);
    return Promise.reject(error);
  }
);

// Response interceptor (tetap sama dengan enhancement)
apiClient.interceptors.response.use(
  (response: AxiosResponse) => {
    console.log(`‚úÖ [API] ${response.status} ${response.config.url}`, {
      data: response.data
    });
    return response;
  },
  (error) => {
    console.error('‚ùå [API] Response Error:', {
      message: error.message,
      status: error.response?.status,
      data: error.response?.data
    });

    // Enhanced error handling dengan API Key specific errors
    if (error.response) {
      const { status, data } = error.response;
      
      switch (status) {
        case 401:
          error.message = data?.message || 'Invalid API Key or unauthorized access';
          error.isApiKeyError = true;
          break;
        case 403:
          error.message = data?.message || 'API Key rejected or insufficient permissions';
          error.isApiKeyError = true;
          break;
        case 400:
          error.message = data?.message || 'Bad request';
          break;
        case 404:
          error.message = data?.message || 'Resource not found';
          break;
        case 429:
          error.message = 'API rate limit exceeded';
          break;
        case 500:
          error.message = 'Internal server error';
          break;
        default:
          error.message = data?.message || `Request failed with status ${status}`;
      }
    } else if (error.request) {
      error.message = 'Network error. Please check your connection.';
    }

    return Promise.reject(error);
  }
);

// Export helper functions
export const apiKeyHelper = ApiKeychainHelper;

// Utility functions untuk API calls (optional, untuk konsistensi)
export const apiUtils = {
  async get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await apiClient.get<T>(url, config);
    return response.data;
  },

  async post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await apiClient.post<T>(url, data, config);
    return response.data;
  },

  async put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await apiClient.put<T>(url, data, config);
    return response.data;
  },

  async delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await apiClient.delete<T>(url, config);
    return response.data;
  },
};

export default apiClient;./services/api/authApi.ts
==== ./services/api/authApi.ts ====
import axios from 'axios';
import { LoginForm, ApiResponse } from '../../types';

const api = axios.create({
  baseURL: 'https://dummyjson.com',
  timeout: 20000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Response interceptor untuk transform response
api.interceptors.response.use(
  (response) => {
    console.log('üì• [AXIOS-INTERCEPTOR] Raw response received:', {
      status: response.status,
      data: response.data
    });

    if (response.status === 200) {
      console.log('‚úÖ [AXIOS-INTERCEPTOR] Status 200 OK - Transforming response...');
      
      const transformedData = {
        ...response,
        data: {
          success: true,
          token: response.data.token || 'simulated_token_xyz',
          user: response.data,
          message: 'Login successful'
        }
      };

      console.log('üîÑ [AXIOS-INTERCEPTOR] Transformed response:', {
        success: transformedData.data.success,
        token: transformedData.data.token ? '***' + transformedData.data.token.slice(-8) : 'none'
      });

      if (transformedData.data.token) {
        console.log('üîê [AXIOS-INTERCEPTOR] TOKEN RECEIVED:', transformedData.data.token);
      }

      return transformedData;
    }

    return response;
  },
  (error) => {
    console.error('‚ùå [AXIOS-INTERCEPTOR] Response error:', error.response?.data || error.message);
    return Promise.reject(error);
  }
);

export const authApi = {
  login: async (credentials: LoginForm): Promise<ApiResponse> => {
    try {
      console.log('üöÄ [AUTH-API] Starting login...');

      const username = credentials.username.trim();
      
      if (!username) {
        throw new Error('Username is required for DummyJSON');
      }

      const requestData = {
        username: username,
        password: credentials.password.trim()
      };

      console.log('üì§ [AUTH-API] Sending to DummyJSON:', {
        username: requestData.username,
        passwordLength: requestData.password.length
      });

      if (!requestData.username || !requestData.password) {
        throw new Error('Username and password are required');
      }

      console.log('üåê [AUTH-API] Making POST request...');
      
      const response = await api.post('/auth/login', requestData);
      
      console.log('‚úÖ [AUTH-API] Response received after interceptor:', response.data);

      return response.data;

    } catch (error: any) {
      console.error('‚ùå [AUTH-API] Login error details:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data
      });
      
      throw new Error(`DummyJSON API Error: ${error.response?.data?.message || error.message}`);
    }
  },
};

export default api;./services/api/index.ts
==== ./services/api/index.ts ====
// src/services/api/index.ts
// export { default as productApi } from './productApi';
// export * from './productApi';./services/api/productApi.ts
==== ./services/api/productApi.ts ====
import { Product, ApiProduct, ProductResponse } from '../../types';
import apiClient from './apiClient';
import { fetchWithRetry } from '../../utils/fetchWithRetry';

// Convert API product to our Product interface
const convertApiProduct = (apiProduct: ApiProduct): Product => {
  return {
    id: apiProduct.id.toString(),
    name: apiProduct.title,
    price: apiProduct.price,
    category: apiProduct.category,
    description: apiProduct.description,
    image: apiProduct.thumbnail,
    discount: apiProduct.discountPercentage,
    isNew: apiProduct.rating > 4.5 || apiProduct.stock > 50,
    stock: apiProduct.stock
  };
};

// Product API Service dengan Retry Mechanism
export const productApi = {
  /**
   * Get all products with optional AbortSignal and retry
   */
  getAllProducts: async (signal?: AbortSignal): Promise<Product[]> => {
    return fetchWithRetry(
      async () => {
        try {
          const config = signal ? { signal } : undefined;
          const response = await apiClient.get<ProductResponse>('/products', config);
          const apiProducts = response.data.products;
          
          return apiProducts.map(convertApiProduct);
        } catch (error: any) {
          if (error.name === 'AbortError') {
            console.log('Request was aborted');
            throw error; // Don't retry aborted requests
          }
          throw new Error('Failed to fetch products');
        }
      },
      { 
        maxRetry: 3, 
        baseDelay: 500,
        retryOn5xx: true 
      }
    );
  },

  /**
   * Get popular products (high discount or popular brands) with retry
   */
  getPopularProducts: async (limit: number = 12, signal?: AbortSignal): Promise<Product[]> => {
    return fetchWithRetry(
      async () => {
        try {
          const config = signal ? { signal } : undefined;
          const response = await apiClient.get<ProductResponse>('/products', config);
          const apiProducts = response.data.products;
          
          const convertedProducts = apiProducts.map(convertApiProduct);
          
          // Filter popular products
          const popularProducts = convertedProducts
            .filter(product => 
              (product.discount && product.discount > 15) || // Good discount
              product.name.toLowerCase().includes('iphone') ||
              product.name.toLowerCase().includes('samsung') ||
              product.name.toLowerCase().includes('macbook')
            )
            .slice(0, limit);
          
          return popularProducts;
        } catch (error: any) {
          if (error.name === 'AbortError') {
            console.log('Request was aborted');
            throw error;
          }
          throw new Error('Failed to fetch popular products');
        }
      },
      { 
        maxRetry: 3, 
        baseDelay: 500 
      }
    );
  },

  /**
   * Get new products (high rating or high stock) with retry
   */
  getNewProducts: async (limit: number = 12, signal?: AbortSignal): Promise<Product[]> => {
    return fetchWithRetry(
      async () => {
        try {
          const config = signal ? { signal } : undefined;
          const response = await apiClient.get<ProductResponse>('/products', config);
          const apiProducts = response.data.products;
          
          const convertedProducts = apiProducts.map(convertApiProduct);
          
          // Filter new products
          const newProducts = convertedProducts
            .filter(product => product.isNew)
            .slice(0, limit);
          
          return newProducts;
        } catch (error: any) {
          if (error.name === 'AbortError') {
            console.log('Request was aborted');
            throw error;
          }
          throw new Error('Failed to fetch new products');
        }
      },
      { 
        maxRetry: 3, 
        baseDelay: 500 
      }
    );
  },

  /**
   * Get discounted products with retry
   */
  getDiscountedProducts: async (minDiscount: number = 10, limit: number = 12, signal?: AbortSignal): Promise<Product[]> => {
    return fetchWithRetry(
      async () => {
        try {
          const config = signal ? { signal } : undefined;
          const response = await apiClient.get<ProductResponse>('/products', config);
          const apiProducts = response.data.products;
          
          const convertedProducts = apiProducts.map(convertApiProduct);
          
          // Filter discounted products
          const discountedProducts = convertedProducts
            .filter(product => product.discount && product.discount >= minDiscount)
            .slice(0, limit);
          
          return discountedProducts;
        } catch (error: any) {
          if (error.name === 'AbortError') {
            console.log('Request was aborted');
            throw error;
          }
          throw new Error('Failed to fetch discounted products');
        }
      },
      { 
        maxRetry: 3, 
        baseDelay: 500 
      }
    );
  },

  /**
   * Get products by category with retry
   */
  getProductsByCategory: async (category: string, signal?: AbortSignal): Promise<Product[]> => {
    return fetchWithRetry(
      async () => {
        try {
          const config = signal ? { signal } : undefined;
          const response = await apiClient.get<ProductResponse>(`/products/category/${category}`, config);
          const apiProducts = response.data.products;
          
          return apiProducts.map(convertApiProduct);
        } catch (error: any) {
          if (error.name === 'AbortError') {
            console.log('Request was aborted');
            throw error;
          }
          throw new Error(`Failed to fetch products for ${category}`);
        }
      },
      { 
        maxRetry: 3, 
        baseDelay: 500 
      }
    );
  },

  /**
   * Get single product by ID with retry
   */
  getProductById: async (id: string, signal?: AbortSignal): Promise<Product> => {
    return fetchWithRetry(
      async () => {
        try {
          const config = signal ? { signal } : undefined;
          const response = await apiClient.get<ApiProduct>(`/products/${id}`, config);
          return convertApiProduct(response.data);
        } catch (error: any) {
          if (error.name === 'AbortError') {
            console.log('Request was aborted');
            throw error;
          }
          throw new Error('Failed to fetch product');
        }
      },
      { 
        maxRetry: 3, 
        baseDelay: 500 
      }
    );
  },

  /**
   * Search products by query with retry
   */
  searchProducts: async (query: string, signal?: AbortSignal): Promise<Product[]> => {
    return fetchWithRetry(
      async () => {
        try {
          const config = signal ? { signal } : undefined;
          const response = await apiClient.get<ProductResponse>(`/products/search?q=${query}`, config);
          const apiProducts = response.data.products;
          
          return apiProducts.map(convertApiProduct);
        } catch (error: any) {
          if (error.name === 'AbortError') {
            console.log('Request was aborted');
            throw error;
          }
          throw new Error('Failed to search products');
        }
      },
      { 
        maxRetry: 3, 
        baseDelay: 500 
      }
    );
  },

  /**
   * Get all categories with retry
   */
  getCategories: async (signal?: AbortSignal): Promise<string[]> => {
    return fetchWithRetry(
      async () => {
        try {
          const config = signal ? { signal } : undefined;
          const response = await apiClient.get<string[]>('/products/categories', config);
          return response.data;
        } catch (error: any) {
          if (error.name === 'AbortError') {
            console.log('Request was aborted');
            throw error;
          }
          throw new Error('Failed to fetch categories');
        }
      },
      { 
        maxRetry: 3, 
        baseDelay: 500 
      }
    );
  }
};

export default productApi;./services/auth/authService.ts
==== ./services/auth/authService.ts ====
import AsyncStorage from '@react-native-async-storage/async-storage';

interface AuthData {
  token: string;
  user: {
    id: string;
    email: string;
    name: string;
  };
}

class AuthService {
  private readonly AUTH_STORAGE_KEY = 'auth_data';

  async loadToken(): Promise<AuthData | null> {
    try {
      console.log('üîê Loading auth token from storage...');
      
      const authData = await AsyncStorage.getItem(this.AUTH_STORAGE_KEY);
      
      if (authData) {
        const parsedData: AuthData = JSON.parse(authData);
        console.log('‚úÖ Auth token loaded successfully');
        return parsedData;
      }
      
      console.log('‚ÑπÔ∏è No auth token found in storage');
      return null;
    } catch (error) {
      console.error('‚ùå Failed to load auth token:', error);
      throw new Error('AUTH_LOAD_FAILED');
    }
  }

  async saveToken(authData: AuthData): Promise<void> {
    try {
      await AsyncStorage.setItem(this.AUTH_STORAGE_KEY, JSON.stringify(authData));
    } catch (error) {
      console.error('‚ùå Failed to save auth token:', error);
      throw error;
    }
  }

  async clearToken(): Promise<void> {
    try {
      await AsyncStorage.removeItem(this.AUTH_STORAGE_KEY);
    } catch (error) {
      console.error('‚ùå Failed to clear auth token:', error);
      throw error;
    }
  }
}

export default new AuthService();./services/cart/cartService.ts
==== ./services/cart/cartService.ts ====
import AsyncStorage from '@react-native-async-storage/async-storage';
import { CartItem } from '../../types';

interface CartData {
  items: CartItem[];
  lastUpdated: string;
  version: string;
}

class CartService {
  private readonly CART_STORAGE_KEYS = {
    CART_DATA: 'cartData',
    CART_BACKUP: 'cartBackup',
  } as const;

  // ‚úÖ GET USER-SPECIFIC STORAGE KEY
  private getUserCartStorageKey(userId: string | undefined): string {
    return userId ? `${this.CART_STORAGE_KEYS.CART_DATA}_${userId}` : this.CART_STORAGE_KEYS.CART_DATA;
  }

  // ‚úÖ LOAD CART DATA UNTUK HYDRATION
  async loadCart(userId?: string): Promise<CartData | null> {
    try {
      console.log('üõí Loading cart data from storage...');
      
      const storageKey = this.getUserCartStorageKey(userId);
      const cartData = await AsyncStorage.getItem(storageKey);
      
      if (cartData) {
        const parsedData: CartData = JSON.parse(cartData);
        console.log(`‚úÖ Cart data loaded: ${parsedData.items?.length || 0} items`);
        return parsedData;
      }
      
      console.log('‚ÑπÔ∏è No cart data found in storage');
      return null;
    } catch (error) {
      console.error('‚ùå Failed to load cart data:', error);
      
      // Try backup
      try {
        const backupKey = userId ? `${this.CART_STORAGE_KEYS.CART_BACKUP}_${userId}` : this.CART_STORAGE_KEYS.CART_BACKUP;
        const backupData = await AsyncStorage.getItem(backupKey);
        if (backupData) {
          console.log('üîÑ Loading from backup cart data');
          return {
            items: JSON.parse(backupData),
            lastUpdated: new Date().toISOString(),
            version: '1.0'
          };
        }
      } catch (backupError) {
        console.error('‚ùå Backup also failed:', backupError);
      }
      
      throw new Error('CART_LOAD_FAILED');
    }
  }

  // ‚úÖ SAVE CART DATA
  async saveCart(cartData: CartData, userId?: string): Promise<void> {
    try {
      const storageKey = this.getUserCartStorageKey(userId);
      await AsyncStorage.setItem(storageKey, JSON.stringify(cartData));
      console.log('üíæ Cart data saved successfully');
    } catch (error) {
      console.error('‚ùå Failed to save cart data:', error);
      throw error;
    }
  }

  // ‚úÖ CLEAR CART DATA
  async clearCart(userId?: string): Promise<void> {
    try {
      const storageKey = this.getUserCartStorageKey(userId);
      const backupKey = userId ? `${this.CART_STORAGE_KEYS.CART_BACKUP}_${userId}` : this.CART_STORAGE_KEYS.CART_BACKUP;
      
      await AsyncStorage.multiRemove([storageKey, backupKey]);
      console.log('üßπ Cart data cleared');
    } catch (error) {
      console.error('‚ùå Failed to clear cart data:', error);
      throw error;
    }
  }
}

export default new CartService();./services/index.ts
==== ./services/index.ts ====
// src/services/index.ts
// Export semua services
export * from './api';./services/product/productCacheService.ts
==== ./services/product/productCacheService.ts ====
import AsyncStorage from '@react-native-async-storage/async-storage';

/**
 * PRODUCT CACHE SERVICE
 * Handle product detail caching dengan TTL (Time To Live)
 * Cache disimpan per item untuk optimal storage usage
 */

// Config
const CACHE_PREFIX = '@product_detail:';
const CACHE_META_KEY = '@product_cache_meta';
const DEFAULT_TTL = 5 * 60 * 1000; // 5 menit dalam milliseconds

export interface CacheData<T> {
  value: T;
  ttl_product: number; // Timestamp expiration
}

export interface CacheMeta {
  lastUpdated: string;
  totalCached: number;
  size: number;
  version: string;
}

class ProductCacheService {
  private getCacheKey(productId: string): string {
    return `${CACHE_PREFIX}${productId}`;
  }

  /**
   * LOAD CACHE META
   * Untuk hydration manager - load metadata cache
   */
  async loadCacheMeta(): Promise<CacheMeta | null> {
    try {
      console.log('üíæ Loading cache metadata...');
      
      const cacheMeta = await AsyncStorage.getItem(CACHE_META_KEY);
      
      if (cacheMeta) {
        const parsedData: CacheMeta = JSON.parse(cacheMeta);
        console.log('‚úÖ Cache metadata loaded:', {
          totalCached: parsedData.totalCached,
          lastUpdated: parsedData.lastUpdated
        });
        return parsedData;
      }
      
      console.log('‚ÑπÔ∏è No cache metadata found');
      return null;
    } catch (error) {
      console.error('‚ùå Failed to load cache metadata:', error);
      throw new Error('CACHE_META_LOAD_FAILED');
    }
  }

  /**
   * SAVE CACHE META
   * Simpan metadata cache
   */
  async saveCacheMeta(cacheMeta: CacheMeta): Promise<void> {
    try {
      await AsyncStorage.setItem(CACHE_META_KEY, JSON.stringify(cacheMeta));
      console.log('üíæ Cache metadata saved');
    } catch (error) {
      console.error('‚ùå Failed to save cache metadata:', error);
      throw error;
    }
  }

  /**
   * UPDATE CACHE META
   * Update metadata berdasarkan current cache state
   */
  async updateCacheMeta(): Promise<CacheMeta> {
    try {
      const cacheInfo = await this.getCacheInfo();
      const newMeta: CacheMeta = {
        lastUpdated: new Date().toISOString(),
        totalCached: cacheInfo.total,
        size: cacheInfo.total * 1024, // Estimasi kasar
        version: '1.0'
      };

      await this.saveCacheMeta(newMeta);
      return newMeta;
    } catch (error) {
      console.error('‚ùå Failed to update cache metadata:', error);
      throw error;
    }
  }

  /**
   * GET PRODUCT CACHE
   * Return cached data jika masih valid, null jika expired/tidak ada
   */
  async getProductCache<T>(productId: string): Promise<T | null> {
    try {
      const cacheKey = this.getCacheKey(productId);
      const cachedData = await AsyncStorage.getItem(cacheKey);

      if (!cachedData) {
        console.log(`üì¶ No cache found for product: ${productId}`);
        return null;
      }

      const parsedCache: CacheData<T> = JSON.parse(cachedData);
      const now = Date.now();

      // Cek TTL expiration
      if (now > parsedCache.ttl_product) {
        console.log(`‚è∞ Cache expired for product: ${productId}`);
        await this.clearProductCache(productId); // Auto-clean expired cache
        return null;
      }

      console.log(`‚úÖ Using cached data for product: ${productId}`);
      return parsedCache.value;

    } catch (error) {
      console.error(`‚ùå Error reading cache for product ${productId}:`, error);
      return null; // Graceful degradation: return null on error
    }
  }

  /**
   * SET PRODUCT CACHE
   * Simpan data + TTL timestamp, update metadata
   */
  async setProductCache<T>(productId: string, data: T, ttl: number = DEFAULT_TTL): Promise<void> {
    try {
      const cacheKey = this.getCacheKey(productId);
      const cacheData: CacheData<T> = {
        value: data,
        ttl_product: Date.now() + ttl // Current time + TTL
      };

      await AsyncStorage.setItem(cacheKey, JSON.stringify(cacheData));
      console.log(`üíæ Cache saved for product: ${productId}, expires in ${ttl / 1000}s`);

      // Update metadata setelah save cache
      await this.updateCacheMeta();

    } catch (error) {
      console.error(`‚ùå Error saving cache for product ${productId}:`, error);
      // Tidak throw error, biar app tidak crash
    }
  }

  /**
   * CLEAR PRODUCT CACHE
   * Hapus cache untuk product tertentu, update metadata
   */
  async clearProductCache(productId: string): Promise<void> {
    try {
      const cacheKey = this.getCacheKey(productId);
      await AsyncStorage.removeItem(cacheKey);
      console.log(`üßπ Cache cleared for product: ${productId}`);

      // Update metadata setelah clear cache
      await this.updateCacheMeta();

    } catch (error) {
      console.error(`‚ùå Error clearing cache for product ${productId}:`, error);
    }
  }

  /**
   * CLEAR ALL PRODUCT CACHES
   * Untuk debugging atau storage cleanup
   */
  async clearAllProductCaches(): Promise<void> {
    try {
      const keys = await AsyncStorage.getAllKeys();
      const productCacheKeys = keys.filter(key => key.startsWith(CACHE_PREFIX));
      
      if (productCacheKeys.length > 0) {
        await AsyncStorage.multiRemove(productCacheKeys);
        console.log(`üßπ Cleared ${productCacheKeys.length} product caches`);
        
        // Clear metadata juga
        await AsyncStorage.removeItem(CACHE_META_KEY);
      }
    } catch (error) {
      console.error('‚ùå Error clearing all product caches:', error);
    }
  }

  /**
   * GET CACHE INFO
   * Untuk debugging dan monitoring
   */
  async getCacheInfo(): Promise<{ total: number; expired: number; valid: number }> {
    try {
      const keys = await AsyncStorage.getAllKeys();
      const productCacheKeys = keys.filter(key => key.startsWith(CACHE_PREFIX));
      let expiredCount = 0;
      let validCount = 0;
      const now = Date.now();

      // Check each cache for expiration
      for (const key of productCacheKeys) {
        const cachedData = await AsyncStorage.getItem(key);
        if (cachedData) {
          const parsedCache: CacheData<any> = JSON.parse(cachedData);
          if (now > parsedCache.ttl_product) {
            expiredCount++;
          } else {
            validCount++;
          }
        }
      }

      return {
        total: productCacheKeys.length,
        expired: expiredCount,
        valid: validCount
      };
    } catch (error) {
      console.error('‚ùå Error getting cache info:', error);
      return { total: 0, expired: 0, valid: 0 };
    }
  }

  /**
   * CLEAN EXPIRED CACHES
   * Bersihkan cache yang sudah expired
   */
  async cleanExpiredCaches(): Promise<number> {
    try {
      const keys = await AsyncStorage.getAllKeys();
      const productCacheKeys = keys.filter(key => key.startsWith(CACHE_PREFIX));
      let cleanedCount = 0;
      const now = Date.now();

      for (const key of productCacheKeys) {
        const cachedData = await AsyncStorage.getItem(key);
        if (cachedData) {
          const parsedCache: CacheData<any> = JSON.parse(cachedData);
          if (now > parsedCache.ttl_product) {
            await AsyncStorage.removeItem(key);
            cleanedCount++;
          }
        }
      }

      if (cleanedCount > 0) {
        console.log(`üßπ Cleaned ${cleanedCount} expired caches`);
        await this.updateCacheMeta();
      }

      return cleanedCount;
    } catch (error) {
      console.error('‚ùå Error cleaning expired caches:', error);
      return 0;
    }
  }

  /**
   * INITIALIZE CACHE SYSTEM
   * Untuk hydration - initialize cache system
   */
  async initialize(): Promise<void> {
    try {
      console.log('üöÄ Initializing product cache system...');
      
      // Clean expired caches on startup
      const cleanedCount = await this.cleanExpiredCaches();
      
      // Load or create cache metadata
      let cacheMeta = await this.loadCacheMeta();
      if (!cacheMeta) {
        cacheMeta = await this.updateCacheMeta();
      }

      console.log('‚úÖ Product cache system initialized:', {
        cleanedExpired: cleanedCount,
        totalCached: cacheMeta.totalCached
      });

    } catch (error) {
      console.error('‚ùå Failed to initialize cache system:', error);
      // Jangan throw, biar app tetap jalan
    }
  }
}

export const productCacheService = new ProductCacheService();./services/wishlist/useWishlist.ts
==== ./services/wishlist/useWishlist.ts ====
import { useState, useEffect, useCallback } from 'react';
import { wishlistService, WishlistState } from './wishlistService';
import { safeStorage } from '../../utils/safeStorage';

/**
 * USE WISHLIST HOOK
 * State management untuk wishlist di UI components
 * Now with safe storage handling and auto-recovery
 */

export const useWishlist = () => {
  const [wishlist, setWishlist] = useState<WishlistState>({
    items: [],
    meta: { count: 0, updatedAt: new Date().toISOString() }
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [storageHealth, setStorageHealth] = useState<'healthy' | 'repaired' | 'replaced'>('healthy');

  /**
   * LOAD WISHLIST PADA APP STARTUP DENGAN SAFE STORAGE
   */
  const loadWishlist = useCallback(async (): Promise<void> => {
    try {
      setLoading(true);
      setError(null);
      
      // Use safeLoad instead of direct service call
      const fallbackWishlist: WishlistState = {
        items: [],
        meta: { count: 0, updatedAt: new Date().toISOString() }
      };
      
      const result = await safeStorage.safeLoad<WishlistState>(
        'wishlist_data',
        fallbackWishlist,
        { maxRetries: 3, repairAttempts: 2 }
      );
      
      if (result.success && result.data) {
        setWishlist(result.data);
        
        // Track storage health for debugging
        if (result.wasRepaired) {
          setStorageHealth('repaired');
          console.log('üîß Wishlist data was repaired during load');
        } else {
          setStorageHealth('healthy');
        }
      } else {
        setWishlist(fallbackWishlist);
        setStorageHealth('replaced');
        console.warn('‚ö†Ô∏è Using fallback wishlist data due to storage issues');
      }
      
    } catch (err) {
      console.error('‚ùå useWishlist load error:', err);
      setError('Failed to load wishlist');
      
      // Fallback to empty state
      setWishlist({
        items: [],
        meta: { count: 0, updatedAt: new Date().toISOString() }
      });
      setStorageHealth('replaced');
    } finally {
      setLoading(false);
    }
  }, []);

  /**
   * TOGGLE ITEM - UPDATE STATE & STORAGE DENGAN SAFE SAVE
   */
  const toggleItem = useCallback(async (productId: string): Promise<void> => {
    try {
      setError(null);
      
      // Optimistic update
      const currentItems = [...wishlist.items];
      const itemIndex = currentItems.indexOf(productId);
      let newItems: string[];
      
      if (itemIndex > -1) {
        // Remove item
        newItems = currentItems.filter(id => id !== productId);
      } else {
        // Add item
        newItems = [...currentItems, productId];
      }
      
      const updatedWishlist: WishlistState = {
        items: newItems,
        meta: {
          count: newItems.length,
          updatedAt: new Date().toISOString()
        }
      };
      
      // Update UI immediately
      setWishlist(updatedWishlist);
      
      // Save to storage safely
      const saveResult = await safeStorage.safeSave('wishlist_data', updatedWishlist);
      
      if (!saveResult.success) {
        console.error('‚ùå Failed to save wishlist:', saveResult.error);
        // Revert optimistic update
        await loadWishlist();
      }
      
    } catch (err) {
      console.error('‚ùå useWishlist toggle error:', err);
      setError('Failed to update wishlist');
      // Revert optimistic update dengan reload
      await loadWishlist();
    }
  }, [wishlist.items, loadWishlist]);

  /**
   * CHECK IF ITEM IN WISHLIST
   */
  const isInWishlist = useCallback((productId: string): boolean => {
    return wishlist.items.includes(productId);
  }, [wishlist.items]);

  /**
   * CLEAR WISHLIST DENGAN SAFE REMOVE
   */
  const clearWishlist = useCallback(async (): Promise<void> => {
    try {
      setError(null);
      
      // Optimistic update
      setWishlist({
        items: [],
        meta: { count: 0, updatedAt: new Date().toISOString() }
      });
      
      // Remove from storage safely
      const removeResult = await safeStorage.safeRemove('wishlist_data');
      
      if (!removeResult.success) {
        console.error('‚ùå Failed to clear wishlist storage:', removeResult.error);
        // Still consider it successful since UI is updated
      }
      
    } catch (err) {
      console.error('‚ùå useWishlist clear error:', err);
      setError('Failed to clear wishlist');
      // Reload to ensure consistency
      await loadWishlist();
    }
  }, [loadWishlist]);

  /**
   * CHECK STORAGE HEALTH
   */
  const checkStorageHealth = useCallback(async (): Promise<void> => {
    try {
      const fallbackWishlist: WishlistState = {
        items: [],
        meta: { count: 0, updatedAt: new Date().toISOString() }
      };
      
      const health = await safeStorage.checkStorageHealth('wishlist_data', fallbackWishlist);
      console.log('ü©∫ Wishlist storage health:', health);
      
    } catch (err) {
      console.error('‚ùå Storage health check failed:', err);
    }
  }, []);

  // Load wishlist on mount
  useEffect(() => {
    loadWishlist();
  }, [loadWishlist]);

  return {
    // State
    wishlist,
    loading,
    error,
    storageHealth,
    
    // Actions
    toggleItem,
    isInWishlist,
    clearWishlist,
    refreshWishlist: loadWishlist,
    checkStorageHealth,
    
    // Convenience properties
    wishlistCount: wishlist.meta.count,
    wishlistItems: wishlist.items,
  };
};./services/wishlist/wishlistService.ts
==== ./services/wishlist/wishlistService.ts ====
import AsyncStorage from '@react-native-async-storage/async-storage';

/**
 * WISHLIST SERVICE
 * Handle wishlist persistence dengan AsyncStorage
 * MultiSet/MultiGet untuk atomic operations
 */

const STORAGE_KEYS = {
  WISHLIST_ITEMS: 'wishlistItems',
  WISHLIST_META: 'wishlistMeta',
} as const;

export interface WishlistMeta {
  count: number;
  updatedAt: string; // ISO string
}

export interface WishlistState {
  items: string[]; // Array of product IDs
  meta: WishlistMeta;
}

class WishlistService {
  /**
   * LOAD WISHLIST DARI ASYNCSTORAGE
   * MultiGet untuk load items & meta sekaligus
   */
  async loadWishlist(): Promise<WishlistState> {
    try {
      const results = await AsyncStorage.multiGet([
        STORAGE_KEYS.WISHLIST_ITEMS,
        STORAGE_KEYS.WISHLIST_META,
      ]);

      // Convert results to object
      const storageData = results.reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
      }, {} as Record<string, string | null>);

      // Parse wishlist items
      let items: string[] = [];
      if (storageData[STORAGE_KEYS.WISHLIST_ITEMS]) {
        try {
          items = JSON.parse(storageData[STORAGE_KEYS.WISHLIST_ITEMS]!);
          // Validate items array
          if (!Array.isArray(items)) {
            console.warn('‚ö†Ô∏è Invalid wishlist items format, resetting...');
            items = [];
          }
        } catch (error) {
          console.error('‚ùå Error parsing wishlist items:', error);
          items = [];
        }
      }

      // Parse wishlist meta
      let meta: WishlistMeta = {
        count: 0,
        updatedAt: new Date().toISOString(),
      };
      
      if (storageData[STORAGE_KEYS.WISHLIST_META]) {
        try {
          const parsedMeta = JSON.parse(storageData[STORAGE_KEYS.WISHLIST_META]!);
          // Validate meta structure
          if (parsedMeta && typeof parsedMeta.count === 'number') {
            meta = {
              count: parsedMeta.count,
              updatedAt: parsedMeta.updatedAt || new Date().toISOString(),
            };
          }
        } catch (error) {
          console.error('‚ùå Error parsing wishlist meta:', error);
          // Keep default meta
        }
      }

      // Ensure count matches actual items
      meta.count = items.length;

      console.log('‚úÖ Wishlist loaded:', { items: items.length, meta });
      return { items, meta };

    } catch (error) {
      console.error('‚ùå WishlistService loadWishlist error:', error);
      // Return empty state sebagai fallback
      return {
        items: [],
        meta: { count: 0, updatedAt: new Date().toISOString() }
      };
    }
  }

  /**
   * TOGGLE ITEM DI WISHLIST
   * Add jika belum ada, remove jika sudah ada
   */
  async toggleItem(productId: string): Promise<WishlistState> {
    try {
      // Load current state dulu
      const currentState = await this.loadWishlist();
      let newItems: string[];

      // Toggle logic
      if (currentState.items.includes(productId)) {
        // Remove item
        newItems = currentState.items.filter(id => id !== productId);
        console.log('üóëÔ∏è Removed from wishlist:', productId);
      } else {
        // Add item
        newItems = [...currentState.items, productId];
        console.log('‚ù§Ô∏è Added to wishlist:', productId);
      }

      // Update meta
      const newMeta: WishlistMeta = {
        count: newItems.length,
        updatedAt: new Date().toISOString(),
      };

      // Save ke AsyncStorage dengan MultiSet
      await AsyncStorage.multiSet([
        [STORAGE_KEYS.WISHLIST_ITEMS, JSON.stringify(newItems)],
        [STORAGE_KEYS.WISHLIST_META, JSON.stringify(newMeta)],
      ]);

      console.log('üíæ Wishlist saved:', { 
        items: newItems.length, 
        count: newMeta.count 
      });

      return {
        items: newItems,
        meta: newMeta,
      };

    } catch (error) {
      console.error('‚ùå WishlistService toggleItem error:', error);
      throw new Error('Failed to update wishlist');
    }
  }

  /**
   * CHECK APAKAH ITEM ADA DI WISHLIST
   */
  async isItemInWishlist(productId: string): Promise<boolean> {
    try {
      const { items } = await this.loadWishlist();
      return items.includes(productId);
    } catch (error) {
      console.error('‚ùå WishlistService isItemInWishlist error:', error);
      return false;
    }
  }

  /**
   * CLEAR ALL WISHLIST DATA
   * Untuk debugging atau reset
   */
  async clearWishlist(): Promise<void> {
    try {
      await AsyncStorage.multiRemove([
        STORAGE_KEYS.WISHLIST_ITEMS,
        STORAGE_KEYS.WISHLIST_META,
      ]);
      console.log('üßπ Wishlist cleared');
    } catch (error) {
      console.error('‚ùå WishlistService clearWishlist error:', error);
      throw new Error('Failed to clear wishlist');
    }
  }

  /**
   * GET WISHLIST STATS
   * Untuk display count di UI
   */
  async getWishlistStats(): Promise<{ count: number; lastUpdated: string }> {
    try {
      const { meta } = await this.loadWishlist();
      return {
        count: meta.count,
        lastUpdated: meta.updatedAt,
      };
    } catch (error) {
      console.error('‚ùå WishlistService getWishlistStats error:', error);
      return { count: 0, lastUpdated: new Date().toISOString() };
    }
  }
}

export const wishlistService = new WishlistService();./src.txt
==== ./src.txt ====
./storage/authService.ts
==== ./storage/authService.ts ====
import { secureStorage } from './secureStorage';

/**
 * UPDATED AUTH SERVICE
 * Compatible dengan secureStorage yang baru
 */

export interface LoginCredentials {
  username: string;
  password: string;
}

export interface AuthResponse {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
  user: {
    id: string;
    username: string;
    email: string;
    name: string;
    avatar?: string;
  };
}

class AuthService {
async login(credentials: LoginCredentials): Promise<AuthResponse> {
    try {
        console.log('üîê [AUTH] Starting login with:', credentials);

        const response = await fetch('https://dummyjson.com/auth/login', {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(credentials),
        });

        console.log('üì° [AUTH] Response status:', response.status);
        
        const responseText = await response.text();
        console.log('üì° [AUTH] Response body:', responseText);

        if (!response.ok) {
            throw new Error(`LOGIN_FAILED: ${response.status} - ${responseText}`);
        }

        const data = JSON.parse(responseText);
        console.log('‚úÖ [AUTH] Login successful, data received:', {
            hasToken: !!data.token,
            hasAccessToken: !!data.accessToken,
            allFields: Object.keys(data)
        });

        // Handle case where token might be in different field
        const accessToken = data.token || data.accessToken || `mock_token_${Date.now()}`;
        
        const authResponse: AuthResponse = {
            accessToken: accessToken,
            refreshToken: data.refreshToken || `refresh_${Date.now()}`,
            expiresIn: data.expiresIn || 3600 * 1000,
            user: {
                id: data.id.toString(),
                username: data.username,
                email: data.email,
                name: data.firstName && data.lastName 
                    ? `${data.firstName} ${data.lastName}`
                    : data.username,
                avatar: data.image,
            }
        };

        console.log('‚úÖ [AUTH] Formatted auth response:', authResponse);
        return authResponse;

    } catch (error) {
        console.error('‚ùå [AUTH] Login error:', error);
        throw error;
    }
}

  async logout(): Promise<void> {
    try {
      await secureStorage.clearAllSecureData();
    } catch (error) {
      console.error('AuthService logout error:', error);
      throw error;
    }
  }

  async getCurrentAuthState(): Promise<{
    isAuthenticated: boolean;
    user: any | null;
    token: string | null;
  }> {
    try {
      const token = await secureStorage.getAccessToken();
      
      // Untuk sekarang, return basic state saja
      // User data bisa di-load dari API nanti jika needed
      return {
        isAuthenticated: !!token,
        user: null, // Bisa di-load dari API jika needed
        token
      };
    } catch (error) {
      console.error('AuthService getCurrentAuthState error:', error);
      return {
        isAuthenticated: false,
        user: null,
        token: null
      };
    }
  }

  async updateUserData(userData: any): Promise<void> {
    try {
      // Simpan user data - sementara skip dulu
      console.log('User data updated (storage pending):', userData);
    } catch (error) {
      console.error('AuthService updateUserData error:', error);
      throw error;
    }
  }

  async validateToken(): Promise<boolean> {
    try {
      const token = await secureStorage.getAccessToken();
      if (!token) return false;

      // TODO: Implement token validation logic
      // Bisa cek expiry, signature, dll.
      return true;
    } catch (error) {
      console.error('AuthService validateToken error:', error);
      return false;
    }
  }

  async refreshAccessToken(): Promise<string | null> {
    try {
      const refreshToken = await secureStorage.getRefreshToken();
      if (!refreshToken) return null;

      // TODO: Implement refresh token logic
      // const newToken = await api.refreshToken(refreshToken);
      // await secureStorage.setAccessToken(newToken);
      // return newToken;

      return null;
    } catch (error) {
      console.error('AuthService refreshAccessToken error:', error);
      return null;
    }
  }
}

export const authService = new AuthService();./storage/secureStorage.ts
==== ./storage/secureStorage.ts ====
import * as Keychain from 'react-native-keychain';

/**
 * SECURE STORAGE SERVICE
 * Khusus untuk data sensitif: tokens, credentials, biometric data
 * Kenapa dipisah: 
 * - Security focus yang ketat
 * - Tidak terkontaminasi dengan non-sensitive data
 * - Memudahkan audit security
 */

const KEYCHAIN_CONFIG = {
  service: 'com.ecom.securestore',
  accessible: Keychain.ACCESSIBLE.WHEN_UNLOCKED_THIS_DEVICE_ONLY,
} as const;

// Key names untuk different types of data
const SECURE_KEYS = {
  ACCESS_TOKEN: 'accessToken',
  REFRESH_TOKEN: 'refreshToken', 
  BIOMETRIC_DATA: 'biometricData',
  ENCRYPTION_KEY: 'encryptionKey',
  SESSION_SECRET: 'sessionSecret',
} as const;

class SecureStorage {
  /**
   * SIMPAN ACCESS TOKEN
   * Token utama untuk API authorization
   */
  async setAccessToken(token: string): Promise<void> {
    try {
      if (!token || token.length < 10) {
        throw new Error('Invalid access token format');
      }

      const result = await Keychain.setGenericPassword(
        SECURE_KEYS.ACCESS_TOKEN,
        token,
        KEYCHAIN_CONFIG
      );

      if (!result) {
        throw new Error('Failed to save access token to secure storage');
      }

      console.log('‚úÖ Access token saved to secure storage');
    } catch (error) {
      console.error('‚ùå SecureStorage setAccessToken error:', error);
      
      // Enhanced error handling
      if (error instanceof Error) {
        if (error.message.includes('Could not encrypt')) {
          throw new Error('SECURE_STORAGE_ENCRYPTION_FAILED');
        } else if (error.message.includes('Duplicate')) {
          throw new Error('TOKEN_ALREADY_EXISTS');
        }
      }
      
      throw new Error('ACCESS_TOKEN_SAVE_FAILED');
    }
  }

  /**
   * AMBIL ACCESS TOKEN
   */
  async getAccessToken(): Promise<string | null> {
    try {
      const credentials = await Keychain.getGenericPassword(KEYCHAIN_CONFIG);
      
      if (credentials && credentials.password) {
        // Validasi: cek apakah ini access token (bukan data lain)
        if (credentials.username === SECURE_KEYS.ACCESS_TOKEN) {
          if (credentials.password.length >= 10) {
            return credentials.password;
          } else {
            console.warn('‚ö†Ô∏è Invalid access token format found');
            await this.removeAccessToken();
            return null;
          }
        }
      }
      
      return null;
    } catch (error) {
      console.error('‚ùå SecureStorage getAccessToken error:', error);
      
      // Classify errors untuk handling yang tepat
      if (error instanceof Error) {
        const errorMsg = error.message.toLowerCase();
        
        if (errorMsg.includes('user canceled') || errorMsg.includes('authentication failed')) {
          throw new Error('SECURE_STORAGE_ACCESS_DENIED');
        } else if (errorMsg.includes('keychain') && errorMsg.includes('not found')) {
          throw new Error('ACCESS_TOKEN_NOT_FOUND');
        } else if (errorMsg.includes('security') || errorMsg.includes('encryption')) {
          throw new Error('SECURE_STORAGE_CORRUPTED');
        }
      }
      
      throw new Error('ACCESS_TOKEN_RETRIEVAL_FAILED');
    }
  }

  /**
   * HAPUS ACCESS TOKEN
   */
  async removeAccessToken(): Promise<void> {
    try {
      // Approach 1: Reset dengan config spesifik
      await Keychain.resetGenericPassword(KEYCHAIN_CONFIG);
      
      // Approach 2: Reset generic untuk memastikan
      await Keychain.resetGenericPassword();
      
      console.log('‚úÖ Access token removed from secure storage');
    } catch (error) {
      console.error('‚ùå SecureStorage removeAccessToken error:', error);
      throw new Error('ACCESS_TOKEN_REMOVAL_FAILED');
    }
  }

  /**
   * SIMPAN REFRESH TOKEN
   * Token untuk mendapatkan access token baru
   */
  async setRefreshToken(token: string): Promise<void> {
    try {
      if (!token || token.length < 10) {
        throw new Error('Invalid refresh token format');
      }

      // Simpan dengan username yang berbeda
      await Keychain.setGenericPassword(
        SECURE_KEYS.REFRESH_TOKEN,
        token,
        KEYCHAIN_CONFIG
      );

      console.log('‚úÖ Refresh token saved to secure storage');
    } catch (error) {
      console.error('‚ùå SecureStorage setRefreshToken error:', error);
      throw new Error('REFRESH_TOKEN_SAVE_FAILED');
    }
  }

  /**
   * AMBIL REFRESH TOKEN
   */
  async getRefreshToken(): Promise<string | null> {
    try {
      const credentials = await Keychain.getGenericPassword(KEYCHAIN_CONFIG);
      
      if (credentials && credentials.password && credentials.username === SECURE_KEYS.REFRESH_TOKEN) {
        if (credentials.password.length >= 10) {
          return credentials.password;
        } else {
          await this.removeRefreshToken();
          return null;
        }
      }
      
      return null;
    } catch (error) {
      console.error('‚ùå SecureStorage getRefreshToken error:', error);
      throw new Error('REFRESH_TOKEN_RETRIEVAL_FAILED');
    }
  }

  /**
   * HAPUS REFRESH TOKEN
   */
  async removeRefreshToken(): Promise<void> {
    try {
      // Untuk menghapus specific item, kita reset semua
      // Karena Keychain tidak support delete by key
      await this.clearAllSecureData();
      console.log('‚úÖ Refresh token removed');
    } catch (error) {
      console.error('‚ùå SecureStorage removeRefreshToken error:', error);
      throw new Error('REFRESH_TOKEN_REMOVAL_FAILED');
    }
  }

  /**
   * SIMPAN BIOMETRIC DATA
   * Untuk biometric authentication
   */
  async setBiometricData(data: string): Promise<void> {
    try {
      if (!data) {
        throw new Error('Invalid biometric data');
      }

      await Keychain.setGenericPassword(
        SECURE_KEYS.BIOMETRIC_DATA,
        data,
        {
          ...KEYCHAIN_CONFIG,
          accessControl: Keychain.ACCESS_CONTROL.BIOMETRY_ANY, // Require biometric
        }
      );

      console.log('‚úÖ Biometric data saved to secure storage');
    } catch (error) {
      console.error('‚ùå SecureStorage setBiometricData error:', error);
      throw new Error('BIOMETRIC_DATA_SAVE_FAILED');
    }
  }

  /**
   * AMBIL BIOMETRIC DATA
   * Akan trigger biometric prompt
   */
  async getBiometricData(): Promise<string | null> {
    try {
      const credentials = await Keychain.getGenericPassword({
        ...KEYCHAIN_CONFIG,
        authenticationPrompt: {
          title: 'Authenticate to access app',
        },
      });
      
      if (credentials && credentials.password && credentials.username === SECURE_KEYS.BIOMETRIC_DATA) {
        return credentials.password;
      }
      
      return null;
    } catch (error) {
      console.error('‚ùå SecureStorage getBiometricData error:', error);
      throw new Error('BIOMETRIC_DATA_RETRIEVAL_FAILED');
    }
  }

  /**
   * HAPUS BIOMETRIC DATA
   */
  async removeBiometricData(): Promise<void> {
    try {
      await this.clearAllSecureData();
      console.log('‚úÖ Biometric data removed');
    } catch (error) {
      console.error('‚ùå SecureStorage removeBiometricData error:', error);
      throw new Error('BIOMETRIC_DATA_REMOVAL_FAILED');
    }
  }

  /**
   * CEK APAKAH ACCESS TOKEN ADA
   * tanpa mengambil value-nya (untuk performance)
   */
  async hasAccessToken(): Promise<boolean> {
    try {
      const token = await this.getAccessToken();
      return !!token;
    } catch (error) {
      console.error('‚ùå SecureStorage hasAccessToken error:', error);
      return false;
    }
  }

  /**
   * CEK APAKAH REFRESH TOKEN ADA
   */
  async hasRefreshToken(): Promise<boolean> {
    try {
      const token = await this.getRefreshToken();
      return !!token;
    } catch (error) {
      console.error('‚ùå SecureStorage hasRefreshToken error:', error);
      return false;
    }
  }

  /**
   * VALIDASI KEYCHAIN ACCESS
   * Test apakah secure storage bisa diakses
   */
  async validateKeychainAccess(): Promise<boolean> {
    try {
      const testData = 'test_keychain_access_' + Date.now();
      
      // Test write
      await this.setAccessToken(testData);
      
      // Test read
      const retrieved = await this.getAccessToken();
      
      // Cleanup
      await this.removeAccessToken();
      
      const isValid = retrieved === testData;
      console.log('üîê Keychain access validation:', isValid ? '‚úÖ OK' : '‚ùå FAILED');
      
      return isValid;
    } catch (error) {
      console.error('‚ùå Keychain access validation failed:', error);
      return false;
    }
  }

  /**
   * HAPUS SEMUA DATA SENSITIVE
   * Untuk logout atau reset
   */
  async clearAllSecureData(): Promise<void> {
    try {
      console.log('üßπ Clearing all secure data...');
      
      // Multiple approaches untuk memastikan data terhapus
      await Promise.all([
        Keychain.resetGenericPassword(KEYCHAIN_CONFIG),
        Keychain.resetGenericPassword({ service: 'com.ecom.securestore' }),
        Keychain.resetGenericPassword() // Fallback
      ]);
      
      console.log('‚úÖ All secure data cleared');
    } catch (error) {
      console.error('‚ùå SecureStorage clearAllSecureData error:', error);
      throw new Error('SECURE_DATA_CLEAR_FAILED');
    }
  }

  /**
   * GET SECURE STORAGE INFO
   * Untuk debugging dan monitoring
   */
  async getSecureStorageInfo(): Promise<{
    hasAccessToken: boolean;
    hasRefreshToken: boolean;
    hasBiometricData: boolean;
    keychainAccessible: boolean;
  }> {
    try {
      const [hasAccessToken, hasRefreshToken, hasBiometricData, keychainAccessible] = await Promise.all([
        this.hasAccessToken(),
        this.hasRefreshToken(),
        this.getBiometricData().then(data => !!data).catch(() => false),
        this.validateKeychainAccess()
      ]);

      return {
        hasAccessToken,
        hasRefreshToken,
        hasBiometricData,
        keychainAccessible,
      };
    } catch (error) {
      console.error('‚ùå SecureStorage getInfo error:', error);
      return {
        hasAccessToken: false,
        hasRefreshToken: false,
        hasBiometricData: false,
        keychainAccessible: false,
      };
    }
  }

  /**
   * MIGRASI DARI LEGACY STORAGE
   * Pindahkan token dari AsyncStorage ke Secure Storage
   */
  async migrateFromLegacyStorage(asyncStorage: any): Promise<void> {
    try {
      console.log('üîÑ Checking for legacy token migration...');
      
      // Cek apakah sudah ada token di secure storage
      const hasExistingToken = await this.hasAccessToken();
      if (hasExistingToken) {
        console.log('‚úÖ Token already in secure storage, no migration needed');
        return;
      }

      // Cek token di legacy storage (AsyncStorage)
      const legacyToken = await asyncStorage.getItem('userToken');
      const legacyRefreshToken = await asyncStorage.getItem('refreshToken');

      if (legacyToken && legacyToken.length >= 10) {
        console.log('üîÑ Migrating legacy tokens to secure storage...');
        
        // Migrate access token
        await this.setAccessToken(legacyToken);
        
        // Migrate refresh token jika ada
        if (legacyRefreshToken && legacyRefreshToken.length >= 10) {
          await this.setRefreshToken(legacyRefreshToken);
        }

        // Hapus dari legacy storage
        await asyncStorage.multiRemove(['userToken', 'refreshToken']);
        
        console.log('‚úÖ Legacy tokens migrated to secure storage');
      } else {
        console.log('‚ÑπÔ∏è No legacy tokens found to migrate');
      }
    } catch (error) {
      console.error('‚ùå Token migration error:', error);
      throw new Error('TOKEN_MIGRATION_FAILED');
    }
  }
}

// Export singleton instance
export const secureStorage = new SecureStorage();

// Export types untuk error handling
export type SecureStorageError = 
  | 'ACCESS_TOKEN_SAVE_FAILED'
  | 'ACCESS_TOKEN_RETRIEVAL_FAILED' 
  | 'ACCESS_TOKEN_REMOVAL_FAILED'
  | 'REFRESH_TOKEN_SAVE_FAILED'
  | 'REFRESH_TOKEN_RETRIEVAL_FAILED'
  | 'REFRESH_TOKEN_REMOVAL_FAILED'
  | 'BIOMETRIC_DATA_SAVE_FAILED'
  | 'BIOMETRIC_DATA_RETRIEVAL_FAILED'
  | 'BIOMETRIC_DATA_REMOVAL_FAILED'
  | 'SECURE_STORAGE_ACCESS_DENIED'
  | 'SECURE_STORAGE_CORRUPTED'
  | 'SECURE_DATA_CLEAR_FAILED'
  | 'TOKEN_MIGRATION_FAILED';./storage/storageService.ts
==== ./storage/storageService.ts ====
// storageService.ts (FIXED VERSION)
import AsyncStorage from '@react-native-async-storage/async-storage';
import { secureStorage } from './secureStorage'; // Import secure storage

/**
 * FIXED STORAGE SERVICE dengan security yang benar
 */
export const STORAGE_KEYS = {
  // ‚úÖ NON-SENSITIVE data only
  USER_DATA: 'userData',           // User profile (non-sensitive parts)
  APP_THEME: 'appTheme',
  NOTIFICATION_STATUS: 'notificationStatus', 
  LANGUAGE: 'appLanguage',
  FIRST_LAUNCH: 'firstLaunch',
  USER_PREFERENCES: 'userPreferences',
  RECENT_SEARCHES: 'recentSearches',
  FAVORITE_PRODUCTS: 'favoriteProducts',
  CART_DATA: 'cartData',
  CART_BACKUP: 'cartBackup',
  PENDING_ORDERS: 'pendingOrders',
  DRAFT_DATA: 'draftData',
} as const;

// ‚úÖ Hapus SENSITIVE_KEYS karena data sensitif sudah pindah ke secureStorage
export const CLEARABLE_KEYS = [
  STORAGE_KEYS.USER_DATA,
  STORAGE_KEYS.USER_PREFERENCES,
  STORAGE_KEYS.RECENT_SEARCHES,
  STORAGE_KEYS.FAVORITE_PRODUCTS,
  STORAGE_KEYS.CART_DATA,
  STORAGE_KEYS.CART_BACKUP,
  STORAGE_KEYS.PENDING_ORDERS,
  STORAGE_KEYS.DRAFT_DATA,
] as const;

export const PERSISTENT_KEYS = [
  STORAGE_KEYS.APP_THEME,
  STORAGE_KEYS.NOTIFICATION_STATUS,
  STORAGE_KEYS.LANGUAGE,
  STORAGE_KEYS.FIRST_LAUNCH,
] as const;

class StorageService {
  // MARK: - Secure Storage DELEGATION
  // Semua method secure storage di-delegate ke secureStorage.ts
  async setAccessToken(token: string): Promise<void> {
    return secureStorage.setAccessToken(token);
  }

  async getAccessToken(): Promise<string | null> {
    return secureStorage.getAccessToken();
  }

  async removeAccessToken(): Promise<void> {
    return secureStorage.clearAllSecureData();
  }

  async hasAccessToken(): Promise<boolean> {
    const token = await secureStorage.getAccessToken();
    return !!token;
  }

  // MARK: - AsyncStorage Operations (NON-SENSITIVE only)
  async setItem(key: string, value: any): Promise<void> {
    try {
      // ‚úÖ Validasi: jangan simpan sensitive data di AsyncStorage
      if (this.isSensitiveKey(key)) {
        throw new Error(`Cannot store sensitive data '${key}' in AsyncStorage`);
      }

      const stringValue = typeof value === 'string' ? value : JSON.stringify(value);
      await AsyncStorage.setItem(key, stringValue);
    } catch (error) {
      console.error(`AsyncStorage set error for key ${key}:`, error);
      throw error;
    }
  }

  async getItem<T>(key: string): Promise<T | null> {
    try {
      const value = await AsyncStorage.getItem(key);
      if (value === null) return null;

      try {
        return JSON.parse(value) as T;
      } catch {
        return value as T;
      }
    } catch (error) {
      console.error(`AsyncStorage get error for key ${key}:`, error);
      return null;
    }
  }

  // ... method lainnya tetap sama TAPI tanpa sensitive data

  private isSensitiveKey(key: string): boolean {
    const sensitiveKeys = ['token', 'password', 'secret', 'key', 'auth'];
    return sensitiveKeys.some(sensitive => key.toLowerCase().includes(sensitive));
  }
}

export const storageService = new StorageService();./types/auth.ts
==== ./types/auth.ts ====
// src/types/auth.ts
export interface AuthState {
  isAuthenticated: boolean;
  user?: {
    id: string;
    username: string;
    email: string;
    name: string;
    phone?: string;
    address?: string;
    joinDate?: string;
    avatar?: string;
    // Additional fields from DummyJSON
    firstName?: string;
    lastName?: string;
    gender?: string;
    image?: string;
  };
}

export interface LoginForm {
  username: string;
  email: string;
  password: string;
}

export interface ApiResponse {
  success: boolean;
  token?: string;
  user?: any;
  message?: string;
  loginMethod?: 'username' | 'email'; 
}
./types/cart.ts
==== ./types/cart.ts ====
import { Product, CartItem } from './index';

export interface CartContextType {
  // State
  cartItems: CartItem[];
  cartItemCount: number;
  totalPrice: number;
  isCartLoading: boolean;
  lastCartError: string | null;
  
  // Setters untuk hydration
  setCartItems: (items: CartItem[]) => void;
  
  // Actions
  addToCart: (product: Product, quantity?: number) => Promise<void>;
  updateQuantity: (productId: string, quantity: number) => Promise<void>;
  removeFromCart: (productId: string) => Promise<void>;
  clearCart: () => Promise<void>;
  refreshCart: () => Promise<void>;
}./types/deepLinking.ts
==== ./types/deepLinking.ts ====
import { NavigationContainerRef } from '@react-navigation/native';

export interface DeepLinkParams {
  [key: string]: string;
}


export interface DeepLinkingHandlerInterface {
  setNavigationRef: (ref: React.RefObject<NavigationContainerRef<any>>) => void;
  initialize: () => Promise<string | null>;
  cleanup: () => void;
  handleDeepLink: (url: string | null) => void;
  handleNativeDeepLink: (url: string) => void;
  processPendingUrl: () => void;
  isHandlerReady: () => boolean;
  getState: () => {
    isReady: boolean;
    pendingUrl: string | null;
    hasNavigationRef: boolean;
  };
}

export interface UseDeepLinkingReturn {
  isDeepLinkingReady: boolean;
  processPendingUrl: () => void;
}

// ‚úÖ NEW TYPES FOR ADD-TO-CART DEEP LINK
export interface AddToCartDeepLink {
  type: 'add-to-cart';
  productId: string;
}

export interface ViewProductDeepLink {
  type: 'view-product';
  productId: string;
}

export interface OpenCartDeepLink {
  type: 'open-cart';
}

// ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è TAMBAHIN INI BRO ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è
export interface FallbackDeepLink {
  type: 'fallback';
  reason?: string;
}
// ‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è TAMBAHIN INI BRO ‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è

export type DeepLinkAction =
  | AddToCartDeepLink
  | ViewProductDeepLink
  | OpenCartDeepLink
  | FallbackDeepLink; // ‚¨ÖÔ∏è masukin ke union

export interface DeepLinkResult {
  success: boolean;
  action: DeepLinkAction;
  error?: string;
}


export type ParsedDeepLink = DeepLinkResult;./types/index.ts
==== ./types/index.ts ====
// types/index.ts
export * from './auth';
export * from './user';
export * from './product';
export * from './navigation';./types/navigation.ts
==== ./types/navigation.ts ====
// types/navigation.ts
import { Product } from './product';

// Root Stack Navigator Types
export type RootStackParamList = {
  RootDrawer: undefined;
  CategoriesWithBottomTabs: undefined;
  ProductDetail: { productId: string };
  ProductList: undefined
  Profile: undefined;
  Login: undefined;
};

export type RootDrawerParamList = {
  Home: undefined;
  CategoriesWithBottomTabs: undefined;
  Cart: undefined;
  Analytics: undefined;
  Profile: { userId?: string };
  Settings: undefined;
  CategoryList: undefined;
  Login: undefined;
  ProductCategory: { category: string };
  ProductList: undefined;
  ProductDetail: { productId: string }; 
  CheckoutModal: undefined;
  TestError: undefined;
};

export type HomeStackParamList = {
  Home: undefined;
  CategoriesWithBottomTabs: undefined;
  ProductDetail: { productId: string };
  Cart: undefined;
  ProductList: undefined;
  Profile: undefined;
  Login: undefined;
  TestError: undefined;
  CheckoutModal: { 
        product?: Product; // Untuk checkout single product
        cartItems?: CartItem[]; // Untuk checkout dari cart
        subtotal?: number;
        discount?: number;
        shippingFee?: number;
        tax?: number;
        total?: number;
    };
};

export type BottomTabsParamList = {
  Home: undefined;
  CategoriesTopTabs: undefined;
  Analytics: undefined;
  Profile: undefined;
  Login: undefined;
};

export type TopTabsParamList = {
  Popular: undefined;
  New: undefined;
  Discount: undefined;
  Electronics: undefined;
  Clothing: undefined;
  Food: undefined;
  Automotive: undefined;
  Entertainment: undefined;
  Baby: undefined;
};

export interface CartItem {
    product: Product;
    quantity: number;
    id: string;
}./types/product.ts
==== ./types/product.ts ====
// types/product.ts
export interface Product {
  id: string;
  name: string;
  title?: string;
  price: number;
  category: string;
  description: string;
  image: string;
  isNew?: boolean;
  rating?: number;
  discount?: number;
  stock?: number;
  brand?: string; // Tambahkan brand sebagai optional
  thumbnail?: string; // Tambahkan thumbnail sebagai optional
}

export interface NewProduct {
  id: string;
  name: string;
  price: string;
  imageUrl: string;
  description: string;
}

export type ErrorsState = {
  [key in keyof Omit<NewProduct, 'id'>]?: string;
};

// Untuk API dummyjson.com (jika perlu)
export interface ApiProduct {
  id: number;
  title: string;
  description: string;
  price: number;
  discountPercentage: number;
  rating: number;
  stock: number;
  brand: string;
  category: string;
  thumbnail: string;
  images: string[];
}

export interface ProductResponse {
  products: ApiProduct[];
  total: number;
  skip: number;
  limit: number;
}./types/retry.ts
==== ./types/retry.ts ====
export interface RetryOptions {
  maxRetry?: number;
  baseDelay?: number;
  retryOn5xx?: boolean;
}

export interface RetryState {
  attempt: number;
  maxRetry: number;
  baseDelay: number;
}./types/user.ts
==== ./types/user.ts ====
export interface User {
  id: string;
  username: string;
  email: string;
  name: string;
  phone?: string;           // Tambahkan ini
  address?: string;         // Tambahkan ini
  joinDate?: string;        // Tambahkan ini
  avatar?: string;
  firstName?: string;
  lastName?: string;
  gender?: string;
  image?: string;
  dateOfBirth?: string;     // Optional: tambahkan jika perlu
  bio?: string;             // Optional: tambahkan jika perlu
}./utils/cachehelper.ts
==== ./utils/cachehelper.ts ====
import AsyncStorage from '@react-native-async-storage/async-storage';

export interface CacheData<T> {
  data: T;
  timestamp: number;
  ttl: number; // Time to live in milliseconds
}

export class CacheManager {
  private static instance: CacheManager;

  private constructor() {}

  static getInstance(): CacheManager {
    if (!CacheManager.instance) {
      CacheManager.instance = new CacheManager();
    }
    return CacheManager.instance;
  }

  // Save data to cache with TTL
  async set<T>(key: string, data: T, ttl: number = 30 * 60 * 1000): Promise<void> {
    try {
      const cacheData: CacheData<T> = {
        data,
        timestamp: Date.now(),
        ttl
      };
      await AsyncStorage.setItem(key, JSON.stringify(cacheData));
      console.log(`üíæ Cache saved for key: ${key}`);
    } catch (error) {
      console.error(`‚ùå Error saving cache for key ${key}:`, error);
    }
  }

  // Get data from cache if not expired
  async get<T>(key: string): Promise<T | null> {
    try {
      const cached = await AsyncStorage.getItem(key);
      if (!cached) return null;

      const cacheData: CacheData<T> = JSON.parse(cached);
      const now = Date.now();
      const isExpired = now - cacheData.timestamp > cacheData.ttl;

      if (isExpired) {
        console.log(`‚è∞ Cache expired for key: ${key}`);
        await this.remove(key); // Clean up expired cache
        return null;
      }

      console.log(`üìñ Cache hit for key: ${key}`);
      return cacheData.data;
    } catch (error) {
      console.error(`‚ùå Error reading cache for key ${key}:`, error);
      return null;
    }
  }

  // Remove specific cache
  async remove(key: string): Promise<void> {
    try {
      await AsyncStorage.removeItem(key);
      console.log(`üóëÔ∏è Cache removed for key: ${key}`);
    } catch (error) {
      console.error(`‚ùå Error removing cache for key ${key}:`, error);
    }
  }

  // Clear all cache
  async clear(): Promise<void> {
    try {
      await AsyncStorage.clear();
      console.log('üßπ All cache cleared');
    } catch (error) {
      console.error('‚ùå Error clearing cache:', error);
    }
  }

  // Check if cache is valid without removing it
  async isValid(key: string): Promise<boolean> {
    try {
      const cached = await AsyncStorage.getItem(key);
      if (!cached) return false;

      const cacheData: CacheData<any> = JSON.parse(cached);
      const now = Date.now();
      return now - cacheData.timestamp <= cacheData.ttl;
    } catch (error) {
      console.error(`‚ùå Error checking cache validity for key ${key}:`, error);
      return false;
    }
  }
}

// Export singleton instance
export const cacheManager = CacheManager.getInstance();./utils/deepLinkingHandler.ts
==== ./utils/deepLinkingHandler.ts ====
import { Linking, EmitterSubscription, Platform, Alert, AppState } from 'react-native';
import { NavigationContainerRef } from '@react-navigation/native';
import { NativeModules } from 'react-native';
import {
  DeepLinkParams,
  ParsedDeepLink,
  DeepLinkAction,
  DeepLinkResult,
  AddToCartDeepLink,
  ViewProductDeepLink,
  OpenCartDeepLink
} from '../types/deepLinking';

// ‚úÖ Import cart context atau service untuk handle add to cart
import { productApi } from '../services/api/productApi';

interface TroubleshootingState {
  lastProcessedUrl: string | null;
  lastError: string | null;
  appState: string;
  isColdStart: boolean;
}

// ‚úÖ Callback interface untuk external handlers
export interface DeepLinkCallbacks {
  onAddToCart?: (productId: string) => Promise<void>;
  onViewProduct?: (productId: string) => void;
  onOpenCart?: () => void;
  onAuthRequired?: (targetRoute: string, params?: any) => void;
  onInvalidParam?: (error: string) => void;
}

// ‚úÖ Interface untuk pending deep link dengan auth gate
interface PendingDeepLink {
  url: string;
  parsedLink: ParsedDeepLink;
  targetAction: DeepLinkAction;
  timestamp: number;
}

class DeepLinkingHandler {
  private navigationRef: NavigationContainerRef<any> | null = null;
  private isReady: boolean = false;
  private pendingUrl: string | null = null;
  private pendingAuthDeepLink: PendingDeepLink | null = null;
  private subscriptions: { remove: () => void }[] = [];
  private troubleshootingState: TroubleshootingState = {
    lastProcessedUrl: null,
    lastError: null,
    appState: 'active',
    isColdStart: true
  };

  // ‚úÖ External callbacks untuk cart operations dan auth
  private callbacks: DeepLinkCallbacks = {};
  private isUserLoggedIn: boolean = false;

  setNavigationRef = (ref: NavigationContainerRef<any> | null): void => {
    this.navigationRef = ref;
    if (ref) {
      console.log('‚úÖ Navigation ref set');
      this.processPendingUrl();
    }
  };

  // ‚úÖ Set external callbacks
  setCallbacks = (callbacks: DeepLinkCallbacks): void => {
    this.callbacks = callbacks;
    console.log('‚úÖ Deep link callbacks set');
  };

  // ‚úÖ Set auth state untuk auth gate
  setAuthState = (isLoggedIn: boolean): void => {
    this.isUserLoggedIn = isLoggedIn;
    console.log(`üîê Auth state updated: ${isLoggedIn ? 'Logged In' : 'Logged Out'}`);

    // Jika user baru login dan ada pending auth deep link, process sekarang
    if (isLoggedIn && this.pendingAuthDeepLink) {
      this.processPendingAuthDeepLink();
    }
  };

  initialize = async (): Promise<string | null> => {
    try {
      console.log('üöÄ Initializing Deep Linking Handler...');

      let initialUrl: string | null = null;

      // Setup app state listener
      this.setupAppStateListener();

      // Handle Android cold start
      if (Platform.OS === 'android') {
        try {
          if (NativeModules.MainActivity?.getStoredDeepLink) {
            const url: string | null = await NativeModules.MainActivity.getStoredDeepLink();
            if (url) {
              console.log('ü§ñ Android stored deep link:', url);
              initialUrl = url;
            }
          }
        } catch (error) {
          console.log('‚ùå Error getting stored deep link:', error);
        }
      }

      // Handle initial URL (cold start)
      const url = await Linking.getInitialURL();
      if (url) {
        console.log('üì± Initial URL found:', url);
        initialUrl = url;
      }

      // Check if app can open our scheme
      const canOpen = await Linking.canOpenURL('ecommerceapp://test');
      console.log(`üîó Can open ecommerceapp:// scheme: ${canOpen}`);

      this.isReady = true;
      this.troubleshootingState.isColdStart = false;

      console.log('‚úÖ DeepLinkingHandler initialized successfully');
      this.logTroubleshootingState();

      return initialUrl;
    } catch (error) {
      console.log('‚ùå Error initializing deep linking:', error);
      this.troubleshootingState.lastError = `Initialization failed: ${error}`;
      return null;
    }
  };

  // ‚úÖ ENHANCED DEEP LINK PARSER DENGAN VALIDASI
  parseDeepLinkUrl = (url: string): DeepLinkResult => {
    try {
      console.log('üîó Parsing deep link URL:', url);

      // Basic validation
      if (!url || typeof url !== 'string') {
        return {
          success: false,
          action: { type: 'fallback', reason: 'Invalid URL format' },
          error: 'Invalid URL format',
        };
      }

      // Parse URL
      const parsedUrl = new URL(url);
      const host = parsedUrl.host;
      const pathSegments = parsedUrl.pathname.split('/').filter(segment => segment.length > 0);

      console.log('üîó URL parsed - Host:', host, 'Path:', pathSegments);

      // Handle different actions
      if (pathSegments.length === 0) {
        // miniecom:// - fallback ke home
        return {
          success: true,
          action: { type: 'fallback' }
        };
      }

      const action = pathSegments[0];
      const param = pathSegments[1];

      switch (action) {
        case 'product':
          if (!param) {
            return {
              success: false,
              action: { type: 'fallback' },
              error: 'Product ID is required for product action'
            };
          }

          // ‚úÖ VALIDASI: Product ID harus angka
          if (!this.isValidProductId(param)) {
            return {
              success: false,
              action: { type: 'fallback' },
              error: 'Invalid product ID format - must be numeric'
            };
          }

          return {
            success: true,
            action: {
              type: 'view-product',
              productId: param
            } as ViewProductDeepLink
          };

        case 'add-to-cart':
          if (!param) {
            return {
              success: false,
              action: { type: 'fallback' },
              error: 'Product ID is required for add-to-cart action'
            };
          }

          // ‚úÖ VALIDASI: Product ID harus angka
          if (!this.isValidProductId(param)) {
            return {
              success: false,
              action: { type: 'fallback' },
              error: 'Invalid product ID format - must be numeric'
            };
          }

          return {
            success: true,
            action: {
              type: 'add-to-cart',
              productId: param
            } as AddToCartDeepLink
          };

        case 'home':
          return {
            success: true,
            action: { type: 'fallback' }
          };

        case 'cart':
          return {
            success: true,
            action: { type: 'open-cart' } as OpenCartDeepLink
          };

        default:
          return {
            success: false,
            action: { type: 'fallback' },
            error: `Unknown action: ${action}`
          };
      }
    } catch (error) {
      console.error('‚ùå Error parsing deep link:', error);
      return {
        success: false,
        action: { type: 'fallback' },
        error: 'Failed to parse deep link URL'
      };
    }
  };

  // ‚úÖ VALIDATE PRODUCT ID - HARUS ANGKA
  private isValidProductId = (productId: string): boolean => {
    return /^[0-9]+$/.test(productId) && productId.length > 0 && productId.length <= 10;
  };

  // ‚úÖ VALIDASI TARGET DENGAN AUTH CHECK
  validateTarget = (params: any, actionType: string): { isValid: boolean; requiresAuth: boolean } => {
    // Validasi parameter
    if (actionType === 'view-product' || actionType === 'add-to-cart') {
      if (!params.productId || !this.isValidProductId(params.productId)) {
        return { isValid: false, requiresAuth: false };
      }
    }

    // Tentukan apakah action memerlukan auth
    const requiresAuth = actionType === 'add-to-cart'; // Contoh: add-to-cart butuh login

    return { isValid: true, requiresAuth };
  };

  // ‚úÖ HANDLE DEEP LINK NAVIGATION DENGAN AUTH GATE
  handleDeepLinkNavigation = async (
    navigation: any,
    parsedLink: ParsedDeepLink,
    isLoggedIn: boolean
  ): Promise<void> => {
    console.log('üéØ Handling deep link navigation with auth gate:', {
      parsedLink,
      isLoggedIn
    });

    const { action } = parsedLink;

    // Validasi target
    const validation = this.validateTarget(action, action.type);

    if (!validation.isValid) {
      // ‚úÖ FALLBACK NAVIGATION: Invalid parameter
      console.log('‚ùå Invalid parameters, fallback to home');
      this.navigateToHome();
      this.showFallbackAlert(
        'Tautan Tidak Valid',
        'Tautan tidak valid, dialihkan ke beranda'
      );

      // Panggil callback untuk invalid param
      if (this.callbacks.onInvalidParam) {
        this.callbacks.onInvalidParam('Invalid product ID format');
      }
      return;
    }

    // ‚úÖ AUTH GATE: Check jika perlu login tapi belum login
    if (validation.requiresAuth && !isLoggedIn) {
      console.log('üîê Auth required but user not logged in, saving pending deep link');

      // Simpan sebagai pending deep link
      this.pendingAuthDeepLink = {
        url: `miniecom://${action.type}/${(action as any).productId || ''}`,
        parsedLink,
        targetAction: action,
        timestamp: Date.now()
      };

      // Panggil callback auth required
      if (this.callbacks.onAuthRequired) {
        this.callbacks.onAuthRequired(action.type, (action as any).productId);
      } else {
        // Fallback: Navigate ke login
        this.navigateToLogin();
      }
      return;
    }

    // ‚úÖ EXECUTE NAVIGATION: Valid dan auth terpenuhi
    this.executeNavigation(action);
  };

  // ‚úÖ PROCESS PENDING AUTH DEEP LINK SETELAH LOGIN
  private processPendingAuthDeepLink = (): void => {
    if (!this.pendingAuthDeepLink || !this.navigationRef) {
      return;
    }

    console.log('üîÑ Processing pending auth deep link:', this.pendingAuthDeepLink);

    // Tunggu sebentar untuk memastikan navigation ready
    setTimeout(() => {
      if (this.navigationRef && this.pendingAuthDeepLink) {
        this.executeNavigation(this.pendingAuthDeepLink.targetAction);
        this.pendingAuthDeepLink = null;
      }
    }, 1000);
  };

  // ‚úÖ EXECUTE NAVIGATION
  private executeNavigation = (action: DeepLinkAction): void => {
    if (!this.navigationRef) return;

    switch (action.type) {
      case 'view-product':
        this.navigateToProductDetail((action as ViewProductDeepLink).productId);
        break;

      case 'add-to-cart':
        this.handleAddToCartAction((action as AddToCartDeepLink).productId);
        break;

      case 'open-cart':
        this.navigateToCart();
        break;

      case 'fallback':
      default:
        this.navigateToHome();
        break;
    }
  };

  // Setup app state monitoring
  private setupAppStateListener = (): void => {
    const subscription = AppState.addEventListener('change', (nextAppState) => {
      console.log(`üîÑ App state changed: ${this.troubleshootingState.appState} ‚Üí ${nextAppState}`);
      this.troubleshootingState.appState = nextAppState;

      if (nextAppState === 'active') {
        // App came to foreground, process any pending URLs
        setTimeout(() => {
          this.processPendingUrl();
        }, 500);
      }
    });

    this.subscriptions.push(subscription);
  };

  cleanup = (): void => {
    console.log('üßπ Cleaning up deep linking handler');
    this.subscriptions.forEach(subscription => {
      try {
        subscription.remove();
      } catch (error) {
        console.log('Error removing subscription:', error);
      }
    });
    this.subscriptions = [];
    this.pendingAuthDeepLink = null;
    this.pendingUrl = null;
  };

  handleNativeDeepLink = (url: string): void => {
    console.log('üì± Native deep link received:', url);
    this.handleDeepLink(url);
  };

  handleDeepLink = (url: string | null): void => {
    if (!url) {
      console.log('‚ö†Ô∏è No URL provided to handleDeepLink');
      return;
    }

    console.log(`üéØ Handling deep link - Navigation ready: ${!!this.navigationRef}, App state: ${this.troubleshootingState.appState}`);

    if (!this.navigationRef) {
      console.log('‚è≥ Navigation ref not available, storing URL as pending:', url);
      this.pendingUrl = url;
      return;
    }

    this.handleUrlAndNavigate(url);
  };

  // ‚úÖ ENHANCED URL HANDLING DENGAN VALIDASI + AUTH GATE
  handleUrlAndNavigate = async (url: string): Promise<void> => {
    try {
      console.log('üîÑ Processing URL:', url);
      this.troubleshootingState.lastProcessedUrl = url;

      // Parse the deep link
      const result = this.parseDeepLinkUrl(url);

      if (!result.success) {
        console.log('‚ùå Invalid deep link format:', result.error);
        this.navigateToHome();
        this.showFallbackAlert(
          'Tautan Tidak Valid',
          result.error || 'Tautan tidak valid, dialihkan ke beranda'
        );
        return;
      }

      // Handle navigation dengan auth gate
      if (this.navigationRef) {
        await this.handleDeepLinkNavigation(
          this.navigationRef,
          result,
          this.isUserLoggedIn
        );
      }

    } catch (error) {
      console.log('‚ùå Error in handleUrlAndNavigate:', error);
      this.troubleshootingState.lastError = `Navigation failed: ${error}`;
      this.navigateToHome();
      this.showFallbackAlert('Error', 'Failed to process the link');
    }
  };

  // ‚úÖ HANDLE ADD TO CART ACTION
  private handleAddToCartAction = async (productId: string): Promise<void> => {
    try {
      console.log(`üõí Handling add-to-cart for product: ${productId}`);

      // Use external callback if provided
      if (this.callbacks.onAddToCart) {
        await this.callbacks.onAddToCart(productId);
        return;
      }

      // Fallback: Implement default add to cart behavior
      await this.defaultAddToCartHandler(productId);

    } catch (error) {
      console.error('‚ùå Error in handleAddToCartAction:', error);
      this.showFallbackAlert('Error', 'Failed to add product to cart');
    }
  };

  // ‚úÖ DEFAULT ADD TO CART HANDLER
  private defaultAddToCartHandler = async (productId: string): Promise<void> => {
    try {
      // Fetch product details
      const product = await productApi.getProductById(productId);

      // Show success message
      Alert.alert(
        'Added to Cart üõí',
        `${product.name} has been added to your cart!`,
        [
          {
            text: 'View Cart',
            onPress: () => this.navigateToCart()
          },
          {
            text: 'Continue Shopping',
            style: 'cancel'
          }
        ]
      );

      console.log('‚úÖ Product added to cart via deep link:', product.name);

    } catch (error: any) {
      console.error('‚ùå Failed to add product via deep link:', error);

      // Error handling dengan berbagai scenario
      if (error.message?.includes('Failed to fetch') || error.message?.includes('Network')) {
        Alert.alert(
          'Network Error',
          'Please check your internet connection and try again.',
          [{ text: 'OK' }]
        );
      } else if (error.response?.status === 404) {
        Alert.alert(
          'Product Not Found',
          'The requested product could not be found.',
          [{ text: 'OK' }]
        );
      } else {
        Alert.alert(
          'Error',
          'Failed to add product to cart. Please try again.',
          [{ text: 'OK' }]
        );
      }
    }
  };

  // ‚úÖ HANDLE VIEW PRODUCT ACTION
  private handleViewProductAction = (productId: string): void => {
    console.log(`üîç Navigating to product: ${productId}`);
    this.navigateToProductDetail(productId);
  };

  // ‚úÖ HANDLE OPEN CART ACTION
  private handleOpenCartAction = (): void => {
    console.log('üõí Opening cart');
    this.navigateToCart();
  };

  // ‚úÖ FALLBACK ALERT DENGAN BAHASA INDONESIA
  private showFallbackAlert = (title: string, message: string): void => {
    Alert.alert(title, message, [{ text: 'OK' }]);
  };

  // ‚úÖ NAVIGATION METHODS
  private navigateToHome = (): void => {
    if (!this.navigationRef) return;
    this.navigationRef.navigate('Home');
    console.log('üè† Navigated to Home');
  };

  private navigateToLogin = (): void => {
    if (!this.navigationRef) return;
    this.navigationRef.navigate('Login');
    console.log('üîê Navigated to Login');
  };

  private navigateToCart = (): void => {
    if (!this.navigationRef) return;
    this.navigationRef.navigate('Cart');
    console.log('üõí Navigated to Cart');
  };

  private navigateToProductDetail = (productId: string): void => {
    if (!this.navigationRef) return;
    this.navigationRef.navigate('ProductDetail', { productId });
    console.log('üì¶ Navigated to ProductDetail with productId:', productId);
  };

  // TROUBLESHOOTING UTILITIES
  private logTroubleshootingState = (): void => {
    console.log('üêõ TROUBLESHOOTING STATE:', this.troubleshootingState);
  };

  getTroubleshootingInfo = (): TroubleshootingState => {
    return { ...this.troubleshootingState };
  };

  // Process pending URL
  processPendingUrl = (): void => {
    if (this.pendingUrl && this.navigationRef) {
      console.log('üîÑ Processing pending URL:', this.pendingUrl);
      this.handleDeepLink(this.pendingUrl);
      this.pendingUrl = null;
    }
  };

  // ‚úÖ GET PENDING DEEP LINK INFO
  getPendingDeepLink = (): PendingDeepLink | null => {
    return this.pendingAuthDeepLink;
  };

  // ‚úÖ CLEAR PENDING DEEP LINK
  clearPendingDeepLink = (): void => {
    this.pendingAuthDeepLink = null;
  };

  isHandlerReady = (): boolean => this.isReady;

  getState = () => ({
    isReady: this.isReady,
    pendingUrl: this.pendingUrl,
    pendingAuthDeepLink: this.pendingAuthDeepLink,
    hasNavigationRef: !!this.navigationRef,
    isUserLoggedIn: this.isUserLoggedIn,
    troubleshooting: this.troubleshootingState,
  });

  // ‚úÖ TEST METHOD UNTUK DEEP LINK DENGAN SKENARIO BERBEDA
  testDeepLinkScenarios = (): void => {
    const testScenarios = [
      { url: 'ecommerceapp://product/123', description: 'Valid product ID' },
      { url: 'ecommerceapp://product/abc', description: 'Invalid product ID (harus angka)' },
      { url: 'ecommerceapp://add-to-cart/456', description: 'Valid add-to-cart' },
      { url: 'ecommerceapp://add-to-cart/xyz', description: 'Invalid add-to-cart' },
      { url: 'ecommerceapp://home', description: 'Home deep link' },
      { url: 'ecommerceapp://cart', description: 'Cart deep link' },
      { url: 'ecommerceapp://invalid', description: 'Unknown action' },
    ];

    console.log('üß™ TESTING DEEP LINK SCENARIOS');

    testScenarios.forEach(({ url, description }) => {
      console.log(`\n--- Testing: ${description} ---`);
      console.log(`URL: ${url}`);
      const result = this.parseDeepLinkUrl(url);
      console.log('Parse Result:', result);

      // Test validasi
      if (result.success) {
        const action = result.action;
        const validation = this.validateTarget(action, action.type);
        console.log('Validation Result:', validation);
      }
    });
  };

  // ‚úÖ DIAGNOSTIC FUNCTION
  runDiagnostics = async (): Promise<void> => {
    console.log('ü©∫ RUNNING DEEP LINK DIAGNOSTICS');

    // Test basic scheme
    const canOpen = await Linking.canOpenURL('ecommerceapp://test');
    console.log(`üîó Can open ecommerceapp:// scheme: ${canOpen}`);

    this.testDeepLinkScenarios();
    this.logTroubleshootingState();
  };
}

export default new DeepLinkingHandler();./utils/fetchWithRetry.ts
==== ./utils/fetchWithRetry.ts ====
import { RetryOptions, RetryState } from '../types/retry';

/**
 * Check if error is retryable (network error, timeout, or optional 5xx)
 */
const isRetryableError = (error: any, retryOn5xx: boolean): boolean => {
  // AbortError should not be retried
  if (error.name === 'AbortError') {
    return false;
  }

  // Network error (no response)
  if (!error.response) {
    return true;
  }

  const status = error.response.status;
  
  // Don't retry client errors (4xx)
  if (status >= 400 && status < 500) {
    return false;
  }

  // Retry server errors (5xx) if enabled
  if (retryOn5xx && status >= 500) {
    return true;
  }

  return false;
};

/**
 * Calculate delay using exponential backoff formula: baseDelay * 2^(attempt-1)
 */
const calculateDelay = (attempt: number, baseDelay: number): number => {
  return baseDelay * Math.pow(2, attempt - 1);
};

/**
 * Wait for specified delay
 */
const wait = (delay: number): Promise<void> => {
  return new Promise(resolve => setTimeout(resolve, delay));
};

/**
 * Main retry function with exponential backoff
 */
export const fetchWithRetry = async <T>(
  apiCall: () => Promise<T>,
  options: RetryOptions = {}
): Promise<T> => {
  const {
    maxRetry = 3,
    baseDelay = 500,
    retryOn5xx = true
  } = options;

  const state: RetryState = {
    attempt: 0,
    maxRetry,
    baseDelay
  };

  while (state.attempt <= maxRetry) {
    try {
      state.attempt++;
      
      console.log(`üîÑ [Retry] Attempt ${state.attempt}/${maxRetry + 1}`);
      
      const result = await apiCall();
      
      // Success - return result
      console.log(`‚úÖ [Retry] Attempt ${state.attempt} successful`);
      return result;
      
    } catch (error: any) {
      console.log(`‚ùå [Retry] Attempt ${state.attempt} failed:`, error.message);
      
      // Check if we should retry
      const shouldRetry = state.attempt <= maxRetry && 
                         isRetryableError(error, retryOn5xx);
      
      if (!shouldRetry) {
        console.log(`üö´ [Retry] Max retry reached or non-retryable error`);
        throw error;
      }
      
      // Calculate and wait for retry delay
      const delay = calculateDelay(state.attempt, baseDelay);
      console.log(`‚è≥ [Retry] Retrying in ${delay}ms...`);
      
      await wait(delay);
    }
  }
  
  throw new Error('Unexpected error in fetchWithRetry');
};./utils/navigationUtils.ts
==== ./utils/navigationUtils.ts ====
import { NavigationProp } from '@react-navigation/native';
import { DrawerNavigationProp } from '@react-navigation/drawer';

export const resetStackAndCloseDrawer = (navigation: NavigationProp<any>) => {
  // Reset stack ke initial route
  navigation.reset({
    index: 0,
    routes: [{ name: 'TopTabs' }],
  });

  // Tutup drawer
  const parent = navigation.getParent<DrawerNavigationProp<{}>>();
  if (parent?.closeDrawer) {
    parent.closeDrawer();
  }
};

export const navigateToParentDrawer = (navigation: NavigationProp<any>) => {
  const parent = navigation.getParent();
  if (parent) {
    parent.goBack();
  }
};

export const getCurrentRouteName = (navigation: any): string => {
  const state = navigation.getState();
  const route = state.routes[state.index];
  return route.name;
};

export const isDrawerOpen = (navigation: any): boolean => {
  const state = navigation.getState();
  return state.history.some((entry: any) => entry.type === 'drawer');
};

// Auth navigation utilities
export const navigateToAuth = (navigation: any) => {
  navigation.reset({
    index: 0,
    routes: [{ name: 'Auth' }],
  });
};

export const navigateToMainApp = (navigation: any) => {
  navigation.reset({
    index: 0,
    routes: [{ name: 'RootDrawer' }],
  });
};./utils/safeStorage.ts
==== ./utils/safeStorage.ts ====
import AsyncStorage from '@react-native-async-storage/async-storage';

/**
 * SAFE STORAGE UTILITIES
 * Handle corrupted JSON data dengan auto-recovery mechanism
 */

export interface SafeStorageResult<T> {
  success: boolean;
  data?: T;
  error?: string;
  wasRepaired?: boolean;
}

class SafeStorage {
  /**
   * SAFELY LOAD DATA FROM STORAGE
   * Auto-repair JSON corruption dan provide fallback
   */
  async safeLoad<T>(
    key: string, 
    fallbackValue: T,
    options: {
      maxRetries?: number;
      repairAttempts?: number;
    } = {}
  ): Promise<SafeStorageResult<T>> {
    const { maxRetries = 3, repairAttempts = 2 } = options;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`üîç Safe loading ${key} (attempt ${attempt}/${maxRetries})`);
        
        const storedData = await AsyncStorage.getItem(key);
        
        if (!storedData) {
          console.log(`üì≠ No data found for key: ${key}`);
          return { 
            success: true, 
            data: fallbackValue,
            wasRepaired: false 
          };
        }

        // Try to parse JSON
        try {
          const parsedData = JSON.parse(storedData);
          console.log(`‚úÖ Successfully loaded ${key}`);
          return { 
            success: true, 
            data: parsedData,
            wasRepaired: false 
          };
        } catch (parseError) {
          console.warn(`‚ö†Ô∏è JSON parse error for ${key}:`, parseError);
          
          // Try to repair corrupted JSON
          const repairResult = await this.attemptRepair(key, storedData, fallbackValue, repairAttempts);
          if (repairResult.success) {
            return {
              success: true,
              data: repairResult.data as T,
              wasRepaired: true
            };
          }

          // If repair failed and this is the last attempt, use fallback
          if (attempt === maxRetries) {
            console.error(`‚ùå All repair attempts failed for ${key}, using fallback`);
            await this.safeSave(key, fallbackValue);
            return {
              success: true,
              data: fallbackValue,
              wasRepaired: true
            };
          }
        }

      } catch (error) {
        console.error(`‚ùå Storage access error for ${key} (attempt ${attempt}):`, error);
        
        if (attempt === maxRetries) {
          return {
            success: false,
            error: `Failed to load ${key} after ${maxRetries} attempts`,
            data: fallbackValue
          };
        }
        
        // Wait before retry (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, 100 * attempt));
      }
    }

    return {
      success: false,
      error: 'Unexpected error in safeLoad',
      data: fallbackValue
    };
  }

  /**
   * ATTEMPT TO REPAIR CORRUPTED JSON DATA
   */
  private async attemptRepair<T>(
    key: string, 
    corruptedData: string, 
    fallbackValue: T,
    maxAttempts: number
  ): Promise<SafeStorageResult<T>> {
    console.log(`üõ†Ô∏è Attempting to repair corrupted data for: ${key}`);
    
    const repairStrategies = [
      // Strategy 1: Try to fix common JSON issues
      () => this.fixCommonJsonIssues(corruptedData),
      
      // Strategy 2: Extract valid JSON substring
      () => this.extractValidJson(corruptedData),
      
      // Strategy 3: Try parsing as different formats
      () => this.tryAlternativeParsing(corruptedData)
    ];

    for (let attempt = 0; attempt < Math.min(repairStrategies.length, maxAttempts); attempt++) {
      try {
        const repairedJson = repairStrategies[attempt]();
        if (repairedJson) {
          const parsedData = JSON.parse(repairedJson);
          
          // Save repaired data back to storage
          await this.safeSave(key, parsedData);
          console.log(`‚úÖ Successfully repaired ${key} with strategy ${attempt + 1}`);
          
          return {
            success: true,
            data: parsedData,
            wasRepaired: true
          };
        }
      } catch (error) {
        console.log(`‚ùå Repair strategy ${attempt + 1} failed:`, error);
      }
    }

    // All repair strategies failed, use fallback
    console.log(`‚ùå All repair strategies failed for ${key}, using fallback`);
    await this.safeSave(key, fallbackValue);
    return {
      success: true,
      data: fallbackValue,
      wasRepaired: true
    };
  }

  /**
   * FIX COMMON JSON ISSUES
   */
  private fixCommonJsonIssues(corruptedData: string): string | null {
    try {
      let fixedData = corruptedData;

      // Fix 1: Remove BOM characters
      fixedData = fixedData.replace(/^\uFEFF/, '');

      // Fix 2: Fix trailing commas
      fixedData = fixedData.replace(/,\s*([\]}])/g, '$1');

      // Fix 3: Fix missing quotes around keys
      fixedData = fixedData.replace(/([{,]\s*)([a-zA-Z0-9_]+)(\s*:)/g, '$1"$2"$3');

      // Fix 4: Remove extra characters at the end
      fixedData = fixedData.replace(/,[\s\r\n]*$/g, '');

      // Test if fixed data is valid JSON
      JSON.parse(fixedData);
      return fixedData;
    } catch {
      return null;
    }
  }

  /**
   * EXTRACT VALID JSON SUBSTRING
   */
  private extractValidJson(corruptedData: string): string | null {
    try {
      // Try to find valid JSON object or array
      const objectMatch = corruptedData.match(/\{[\s\S]*\}/);
      const arrayMatch = corruptedData.match(/\[[\s\S]*\]/);

      const candidates = [];
      if (objectMatch) candidates.push(objectMatch[0]);
      if (arrayMatch) candidates.push(arrayMatch[0]);

      for (const candidate of candidates) {
        try {
          JSON.parse(candidate);
          return candidate;
        } catch {
          // Continue to next candidate
        }
      }
      return null;
    } catch {
      return null;
    }
  }

  /**
   * TRY ALTERNATIVE PARSING METHODS
   */
  private tryAlternativeParsing(corruptedData: string): string | null {
    try {
      // Try wrapping in array if it's a collection of objects
      if (corruptedData.trim().startsWith('{') && !corruptedData.trim().endsWith('}')) {
        const wrapped = `[${corruptedData}]`;
        JSON.parse(wrapped);
        return wrapped;
      }
      return null;
    } catch {
      return null;
    }
  }

  /**
   * SAFELY SAVE DATA TO STORAGE
   */
  async safeSave<T>(
    key: string, 
    data: T, 
    options: {
      maxRetries?: number;
    } = {}
  ): Promise<SafeStorageResult<void>> {
    const { maxRetries = 3 } = options;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const jsonString = JSON.stringify(data, null, 2);
        await AsyncStorage.setItem(key, jsonString);
        console.log(`üíæ Successfully saved ${key}`);
        
        return { success: true };
      } catch (error) {
        console.error(`‚ùå Save error for ${key} (attempt ${attempt}):`, error);
        
        if (attempt === maxRetries) {
          return {
            success: false,
            error: `Failed to save ${key} after ${maxRetries} attempts`
          };
        }
        
        // Wait before retry
        await new Promise(resolve => setTimeout(resolve, 100 * attempt));
      }
    }

    return {
      success: false,
      error: 'Unexpected error in safeSave'
    };
  }

  /**
   * SAFELY REMOVE DATA FROM STORAGE
   */
  async safeRemove(
    key: string,
    options: {
      maxRetries?: number;
    } = {}
  ): Promise<SafeStorageResult<void>> {
    const { maxRetries = 3 } = options;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        await AsyncStorage.removeItem(key);
        console.log(`üóëÔ∏è Successfully removed ${key}`);
        
        return { success: true };
      } catch (error) {
        console.error(`‚ùå Remove error for ${key} (attempt ${attempt}):`, error);
        
        if (attempt === maxRetries) {
          return {
            success: false,
            error: `Failed to remove ${key} after ${maxRetries} attempts`
          };
        }
        
        await new Promise(resolve => setTimeout(resolve, 100 * attempt));
      }
    }

    return {
      success: false,
      error: 'Unexpected error in safeRemove'
    };
  }

  /**
   * CHECK IF STORAGE KEY EXISTS AND IS VALID
   */
  async checkStorageHealth<T>(
    key: string, 
    fallbackValue: T
  ): Promise<{
    exists: boolean;
    isValid: boolean;
    canRepair: boolean;
    suggestedAction: 'healthy' | 'repair' | 'replace';
  }> {
    try {
      const storedData = await AsyncStorage.getItem(key);
      
      if (!storedData) {
        return {
          exists: false,
          isValid: false,
          canRepair: false,
          suggestedAction: 'replace'
        };
      }

      try {
        JSON.parse(storedData);
        return {
          exists: true,
          isValid: true,
          canRepair: true,
          suggestedAction: 'healthy'
        };
      } catch {
        // Try to see if we can repair it
        const testRepair = this.fixCommonJsonIssues(storedData);
        return {
          exists: true,
          isValid: false,
          canRepair: !!testRepair,
          suggestedAction: testRepair ? 'repair' : 'replace'
        };
      }
    } catch (error) {
      console.error(`‚ùå Storage health check failed for ${key}:`, error);
      return {
        exists: false,
        isValid: false,
        canRepair: false,
        suggestedAction: 'replace'
      };
    }
  }
}

export const safeStorage = new SafeStorage();./utils/storageKeys.ts
==== ./utils/storageKeys.ts ====
// utils/storageKeys.ts
export const STORAGE_KEYS = {
  // Authentication data
  USER_TOKEN: 'userToken',
  USER_DATA: 'userData',
  SESSION_ID: 'sessionId',
  REFRESH_TOKEN: 'refreshToken',
  
  // App settings
  APP_THEME: 'appTheme',
  NOTIFICATION_STATUS: 'notificationStatus',
  LANGUAGE: 'appLanguage',
  FIRST_LAUNCH: 'firstLaunch',
  
  // User preferences
  USER_PREFERENCES: 'userPreferences',
  RECENT_SEARCHES: 'recentSearches',
  FAVORITE_PRODUCTS: 'favoriteProducts',
  
  // Cart data
  CART_DATA: 'cartData',
  CART_BACKUP: 'cartBackup',
  
  // Temporary data
  PENDING_ORDERS: 'pendingOrders',
  DRAFT_DATA: 'draftData',
} as const;

// Keys yang akan dihapus saat logout
export const SENSITIVE_KEYS = [
  STORAGE_KEYS.USER_TOKEN,
  STORAGE_KEYS.USER_DATA,
  STORAGE_KEYS.SESSION_ID,
  STORAGE_KEYS.REFRESH_TOKEN,
  STORAGE_KEYS.USER_PREFERENCES,
  STORAGE_KEYS.RECENT_SEARCHES,
  STORAGE_KEYS.FAVORITE_PRODUCTS,
  STORAGE_KEYS.CART_DATA,
  STORAGE_KEYS.CART_BACKUP,
  STORAGE_KEYS.PENDING_ORDERS,
  STORAGE_KEYS.DRAFT_DATA,
] as const;

// Keys yang akan dipertahankan saat logout
export const PERSISTENT_KEYS = [
  STORAGE_KEYS.APP_THEME,
  STORAGE_KEYS.NOTIFICATION_STATUS,
  STORAGE_KEYS.LANGUAGE,
  STORAGE_KEYS.FIRST_LAUNCH,
] as const;./utils/validation.ts
==== ./utils/validation.ts ====
import { NewProduct, ErrorsState } from '../types';

// Product Validations
export const validationForm = (product: NewProduct): ErrorsState => {
  const errors: ErrorsState = {};

  // Name validation
  if (!product.name.trim()) {
    errors.name = 'Product name is required';
  } else if (product.name.trim().length < 3) {
    errors.name = 'Product name must be at least 3 characters';
  } else if (product.name.trim().length > 100) {
    errors.name = 'Product name must be less than 100 characters';
  }

  // Price validation
  if (!product.price.trim()) {
    errors.price = 'Price is required';
  } else {
    const priceValue = Number(product.price);
    if (isNaN(priceValue) || priceValue <= 0) {
      errors.price = 'Price must be a valid number greater than 0';
    } else if (priceValue > 10000000) {
      errors.price = 'Price must be less than 10,000,000';
    }
  }

  // Image URL validation
  if (!product.imageUrl.trim()) {
    errors.imageUrl = 'Image URL is required';
  } else if (!isValidUrl(product.imageUrl)) {
    errors.imageUrl = 'Please enter a valid image URL';
  } else if (product.imageUrl.length > 500) {
    errors.imageUrl = 'Image URL must be less than 500 characters';
  }

  // Description validation
  if (!product.description.trim()) {
    errors.description = 'Description is required';
  } else if (product.description.trim().length < 10) {
    errors.description = 'Description must be at least 10 characters';
  } else if (product.description.trim().length > 500) {
    errors.description = 'Description must be less than 500 characters';
  }

  return errors;
};

// Auth Validations
export const validateUsername = (username: string): string => {
  if (!username.trim()) {
    return 'Username is required';
  }
  if (username.length < 3) {
    return 'Username must be at least 3 characters';
  }
  if (username.length > 20) {
    return 'Username must be less than 20 characters';
  }
  return '';
};

export const validateEmail = (email: string): string => {
  if (!email.trim()) {
    return 'Email is required';
  }
  
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return 'Please enter a valid email address';
  }
  
  return '';
};

export const validatePassword = (password: string): string => {
  if (!password.trim()) {
    return 'Password is required';
  }
  
  if (password.length < 6) {
    return 'Password must be at least 6 characters';
  }
  
  // Optional: Add more password strength rules
  if (!/(?=.*[a-z])(?=.*[A-Z])/.test(password)) {
    return 'Password should contain both uppercase and lowercase letters';
  }
  
  return '';
};

export const validatePhone = (phone: string): string => {
  if (!phone.trim()) {
    return 'Phone number is required';
  }
  
  // Remove all non-digit characters for validation
  const cleanPhone = phone.replace(/\D/g, '');
  
  if (cleanPhone.length < 10) {
    return 'Phone number must be at least 10 digits';
  }
  
  if (cleanPhone.length > 15) {
    return 'Phone number is too long';
  }
  
  return '';
};

// Profile Validations
export const validateFullName = (name: string): string => {
  if (!name.trim()) {
    return 'Full name is required';
  }
  
  if (name.trim().length < 2) {
    return 'Full name must be at least 2 characters';
  }
  
  if (name.trim().length > 50) {
    return 'Full name must be less than 50 characters';
  }
  
  return '';
};

export const validateAddress = (address: string): string => {
  if (!address.trim()) {
    return 'Address is required';
  }
  
  if (address.trim().length < 10) {
    return 'Address must be at least 10 characters';
  }
  
  return '';
};

// Utility Functions
const isValidUrl = (url: string): boolean => {
  try {
    const newUrl = new URL(url);
    return newUrl.protocol === 'http:' || newUrl.protocol === 'https:';
  } catch {
    return false;
  }
};

// Export all validations as a single object for easier imports
export const Validations = {
  product: validationForm,
  username: validateUsername,
  email: validateEmail,
  password: validatePassword,
  phone: validatePhone,
  fullName: validateFullName,
  address: validateAddress,
};